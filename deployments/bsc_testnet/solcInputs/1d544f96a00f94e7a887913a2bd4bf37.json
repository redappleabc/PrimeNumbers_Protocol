{
  "language": "Solidity",
  "sources": {
    "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.7.0 <0.9.0;\n\n// solhint-disable\n\n/**\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n * supported.\n * Uses the default 'BAL' prefix for the error code\n */\nfunction _require(bool condition, uint256 errorCode) pure {\n    if (!condition) _revert(errorCode);\n}\n\n/**\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n * supported.\n */\nfunction _require(\n    bool condition,\n    uint256 errorCode,\n    bytes3 prefix\n) pure {\n    if (!condition) _revert(errorCode, prefix);\n}\n\n/**\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n * Uses the default 'BAL' prefix for the error code\n */\nfunction _revert(uint256 errorCode) pure {\n    _revert(errorCode, 0x42414c); // This is the raw byte representation of \"BAL\"\n}\n\n/**\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n */\nfunction _revert(uint256 errorCode, bytes3 prefix) pure {\n    uint256 prefixUint = uint256(uint24(prefix));\n    // We're going to dynamically create a revert string based on the error code, with the following format:\n    // 'BAL#{errorCode}'\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\n    //\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\n    // number (8 to 16 bits) than the individual string characters.\n    //\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\n    assembly {\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\n        // the '0' character.\n\n        let units := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let tenths := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let hundreds := add(mod(errorCode, 10), 0x30)\n\n        // With the individual characters, we can now construct the full string.\n        // We first append the '#' character (0x23) to the prefix. In the case of 'BAL', it results in 0x42414c23 ('BAL#')\n        // Then, we shift this by 24 (to provide space for the 3 bytes of the error code), and add the\n        // characters to it, each shifted by a multiple of 8.\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\n        // array).\n        let formattedPrefix := shl(24, add(0x23, shl(8, prefixUint)))\n\n        let revertReason := shl(200, add(formattedPrefix, add(add(units, shl(8, tenths)), shl(16, hundreds))))\n\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\n        // message will have the following layout:\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\n\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\n        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\n        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n        // The string length is fixed: 7 characters.\n        mstore(0x24, 7)\n        // Finally, the string itself is stored.\n        mstore(0x44, revertReason)\n\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\n        revert(0, 100)\n    }\n}\n\nlibrary Errors {\n    // Math\n    uint256 internal constant ADD_OVERFLOW = 0;\n    uint256 internal constant SUB_OVERFLOW = 1;\n    uint256 internal constant SUB_UNDERFLOW = 2;\n    uint256 internal constant MUL_OVERFLOW = 3;\n    uint256 internal constant ZERO_DIVISION = 4;\n    uint256 internal constant DIV_INTERNAL = 5;\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\n    uint256 internal constant INVALID_EXPONENT = 9;\n\n    // Input\n    uint256 internal constant OUT_OF_BOUNDS = 100;\n    uint256 internal constant UNSORTED_ARRAY = 101;\n    uint256 internal constant UNSORTED_TOKENS = 102;\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\n    uint256 internal constant ZERO_TOKEN = 104;\n    uint256 internal constant INSUFFICIENT_DATA = 105;\n\n    // Shared pools\n    uint256 internal constant MIN_TOKENS = 200;\n    uint256 internal constant MAX_TOKENS = 201;\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\n    uint256 internal constant MINIMUM_BPT = 204;\n    uint256 internal constant CALLER_NOT_VAULT = 205;\n    uint256 internal constant UNINITIALIZED = 206;\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\n    uint256 internal constant EXPIRED_PERMIT = 209;\n    uint256 internal constant NOT_TWO_TOKENS = 210;\n    uint256 internal constant DISABLED = 211;\n\n    // Pools\n    uint256 internal constant MIN_AMP = 300;\n    uint256 internal constant MAX_AMP = 301;\n    uint256 internal constant MIN_WEIGHT = 302;\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\n    uint256 internal constant MAX_IN_RATIO = 304;\n    uint256 internal constant MAX_OUT_RATIO = 305;\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\n    uint256 internal constant INVALID_TOKEN = 309;\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\n    uint256 internal constant ZERO_INVARIANT = 311;\n    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\n    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\n    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\n    uint256 internal constant ORACLE_INVALID_INDEX = 315;\n    uint256 internal constant ORACLE_BAD_SECS = 316;\n    uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\n    uint256 internal constant AMP_ONGOING_UPDATE = 318;\n    uint256 internal constant AMP_RATE_TOO_HIGH = 319;\n    uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\n    uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\n    uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\n    uint256 internal constant RELAYER_NOT_CONTRACT = 323;\n    uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\n    uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\n    uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\n    uint256 internal constant SWAPS_DISABLED = 327;\n    uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\n    uint256 internal constant PRICE_RATE_OVERFLOW = 329;\n    uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\n    uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\n    uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\n    uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\n    uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\n    uint256 internal constant OUT_OF_TARGET_RANGE = 335;\n    uint256 internal constant UNHANDLED_EXIT_KIND = 336;\n    uint256 internal constant UNAUTHORIZED_EXIT = 337;\n    uint256 internal constant MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 338;\n    uint256 internal constant UNHANDLED_BY_MANAGED_POOL = 339;\n    uint256 internal constant UNHANDLED_BY_PHANTOM_POOL = 340;\n    uint256 internal constant TOKEN_DOES_NOT_HAVE_RATE_PROVIDER = 341;\n    uint256 internal constant INVALID_INITIALIZATION = 342;\n    uint256 internal constant OUT_OF_NEW_TARGET_RANGE = 343;\n    uint256 internal constant FEATURE_DISABLED = 344;\n    uint256 internal constant UNINITIALIZED_POOL_CONTROLLER = 345;\n    uint256 internal constant SET_SWAP_FEE_DURING_FEE_CHANGE = 346;\n    uint256 internal constant SET_SWAP_FEE_PENDING_FEE_CHANGE = 347;\n    uint256 internal constant CHANGE_TOKENS_DURING_WEIGHT_CHANGE = 348;\n    uint256 internal constant CHANGE_TOKENS_PENDING_WEIGHT_CHANGE = 349;\n    uint256 internal constant MAX_WEIGHT = 350;\n    uint256 internal constant UNAUTHORIZED_JOIN = 351;\n    uint256 internal constant MAX_MANAGEMENT_AUM_FEE_PERCENTAGE = 352;\n    uint256 internal constant FRACTIONAL_TARGET = 353;\n    uint256 internal constant ADD_OR_REMOVE_BPT = 354;\n    uint256 internal constant INVALID_CIRCUIT_BREAKER_BOUNDS = 355;\n    uint256 internal constant CIRCUIT_BREAKER_TRIPPED = 356;\n    uint256 internal constant MALICIOUS_QUERY_REVERT = 357;\n    uint256 internal constant JOINS_EXITS_DISABLED = 358;\n\n    // Lib\n    uint256 internal constant REENTRANCY = 400;\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\n    uint256 internal constant PAUSED = 402;\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\n    uint256 internal constant CALLER_IS_NOT_OWNER = 426;\n    uint256 internal constant NEW_OWNER_IS_ZERO = 427;\n    uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\n    uint256 internal constant CALL_TO_NON_CONTRACT = 429;\n    uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\n    uint256 internal constant NOT_PAUSED = 431;\n    uint256 internal constant ADDRESS_ALREADY_ALLOWLISTED = 432;\n    uint256 internal constant ADDRESS_NOT_ALLOWLISTED = 433;\n    uint256 internal constant ERC20_BURN_EXCEEDS_BALANCE = 434;\n    uint256 internal constant INVALID_OPERATION = 435;\n    uint256 internal constant CODEC_OVERFLOW = 436;\n    uint256 internal constant IN_RECOVERY_MODE = 437;\n    uint256 internal constant NOT_IN_RECOVERY_MODE = 438;\n    uint256 internal constant INDUCED_FAILURE = 439;\n    uint256 internal constant EXPIRED_SIGNATURE = 440;\n    uint256 internal constant MALFORMED_SIGNATURE = 441;\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_UINT64 = 442;\n    uint256 internal constant UNHANDLED_FEE_TYPE = 443;\n    uint256 internal constant BURN_FROM_ZERO = 444;\n\n    // Vault\n    uint256 internal constant INVALID_POOL_ID = 500;\n    uint256 internal constant CALLER_NOT_POOL = 501;\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\n    uint256 internal constant INVALID_SIGNATURE = 504;\n    uint256 internal constant EXIT_BELOW_MIN = 505;\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\n    uint256 internal constant SWAP_LIMIT = 507;\n    uint256 internal constant SWAP_DEADLINE = 508;\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\n    uint256 internal constant INSUFFICIENT_ETH = 516;\n    uint256 internal constant UNALLOCATED_ETH = 517;\n    uint256 internal constant ETH_TRANSFER = 518;\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\n    uint256 internal constant TOKENS_MISMATCH = 520;\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\n    uint256 internal constant POOL_NO_TOKENS = 527;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\n\n    // Fees\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\n    uint256 internal constant AUM_FEE_PERCENTAGE_TOO_HIGH = 603;\n\n    // FeeSplitter\n    uint256 internal constant SPLITTER_FEE_PERCENTAGE_TOO_HIGH = 700;\n\n    // Misc\n    uint256 internal constant UNIMPLEMENTED = 998;\n    uint256 internal constant SHOULD_NOT_HAPPEN = 999;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/interfaces/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroReceiver {\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n    // @param _srcChainId - the source endpoint identifier\n    // @param _srcAddress - the source sending contract address from the source chain\n    // @param _nonce - the ordered message nonce\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/interfaces/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroUserApplicationConfig {\n    // @notice set the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    // @param _config - configuration in the bytes. can encode arbitrary content.\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\n\n    // @notice set the send() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setSendVersion(uint16 _version) external;\n\n    // @notice set the lzReceive() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setReceiveVersion(uint16 _version) external;\n\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n    // @param _srcChainId - the chainId of the source chain\n    // @param _srcAddress - the contract address of the source contract at the source chain\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/LzApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/ILayerZeroReceiver.sol\";\nimport \"../interfaces/ILayerZeroUserApplicationConfig.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\nimport \"../util/BytesLib.sol\";\n\n/*\n * a generic LzReceiver implementation\n */\nabstract contract LzApp is Ownable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), \"LzApp: invalid endpoint caller\");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), \"LzApp: invalid source sending contract\");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, \"LzApp: destination chain is not a trusted source\");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, \"LzApp: minGasLimit not set\");\n        require(providedGasLimit >= minGasLimit, \"LzApp: gas limit is too low\");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, \"LzApp: invalid adapterParams\");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, \"LzApp: payload size is too large\");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _srcChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_srcChainId] = _path;\n        emit SetTrustedRemote(_srcChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, \"LzApp: no trusted path record\");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, \"LzApp: invalid minGas\");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/NonblockingLzApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./LzApp.sol\";\nimport \"../util/ExcessivelySafeCall.sol\";\n\n/*\n * the default LayerZero messaging behaviour is blocking, i.e. any failed message will block the channel\n * this abstract class try-catch all fail messages and store locally for future retry. hence, non-blocking\n * NOTE: if the srcAddress is not configured properly, it will still block the message pathway from (srcChainId, srcAddress)\n */\nabstract contract NonblockingLzApp is LzApp {\n    using ExcessivelySafeCall for address;\n\n    constructor(address _endpoint) LzApp(_endpoint) {}\n\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\n\n    // overriding the virtual function in LzReceiver\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft(), 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            _storeFailedMessage(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function _storeFailedMessage(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload, bytes memory _reason) internal virtual {\n        failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n        emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, _reason);\n    }\n\n    function nonblockingLzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual {\n        // only internal transaction\n        require(_msgSender() == address(this), \"NonblockingLzApp: caller must be LzApp\");\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    //@notice override this function\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public payable virtual {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(payloadHash != bytes32(0), \"NonblockingLzApp: no stored message\");\n        require(keccak256(_payload) == payloadHash, \"NonblockingLzApp: invalid payload\");\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/token/oft/v2/BaseOFTV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./OFTCoreV2.sol\";\nimport \"./IOFTV2.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nabstract contract BaseOFTV2 is OFTCoreV2, ERC165, IOFTV2 {\n\n    constructor(uint8 _sharedDecimals, address _lzEndpoint) OFTCoreV2(_sharedDecimals, _lzEndpoint) {\n    }\n\n    /************************************************************************\n    * public functions\n    ************************************************************************/\n    function sendFrom(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount, LzCallParams calldata _callParams) public payable virtual override {\n        _send(_from, _dstChainId, _toAddress, _amount, _callParams.refundAddress, _callParams.zroPaymentAddress, _callParams.adapterParams);\n    }\n\n    function sendAndCall(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount, bytes calldata _payload, uint64 _dstGasForCall, LzCallParams calldata _callParams) public payable virtual override {\n        _sendAndCall(_from, _dstChainId, _toAddress, _amount, _payload, _dstGasForCall, _callParams.refundAddress, _callParams.zroPaymentAddress, _callParams.adapterParams);\n    }\n\n    /************************************************************************\n    * public view functions\n    ************************************************************************/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IOFTV2).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function estimateSendFee(uint16 _dstChainId, bytes32 _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\n        return _estimateSendFee(_dstChainId, _toAddress, _amount, _useZro, _adapterParams);\n    }\n\n    function estimateSendAndCallFee(uint16 _dstChainId, bytes32 _toAddress, uint _amount, bytes calldata _payload, uint64 _dstGasForCall, bool _useZro, bytes calldata _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\n        return _estimateSendAndCallFee(_dstChainId, _toAddress, _amount, _payload, _dstGasForCall, _useZro, _adapterParams);\n    }\n\n    function circulatingSupply() public view virtual override returns (uint);\n\n    function token() public view virtual override returns (address);\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/token/oft/v2/ICommonOFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface of the IOFT core standard\n */\ninterface ICommonOFT is IERC165 {\n\n    struct LzCallParams {\n        address payable refundAddress;\n        address zroPaymentAddress;\n        bytes adapterParams;\n    }\n\n    /**\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\n     * _dstChainId - L0 defined chain id to send tokens too\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\n     * _amount - amount of the tokens to transfer\n     * _useZro - indicates to use zro to pay L0 fees\n     * _adapterParam - flexible bytes array to indicate messaging adapter services in L0\n     */\n    function estimateSendFee(uint16 _dstChainId, bytes32 _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\n\n    function estimateSendAndCallFee(uint16 _dstChainId, bytes32 _toAddress, uint _amount, bytes calldata _payload, uint64 _dstGasForCall, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\n\n    /**\n     * @dev returns the circulating amount of tokens on current chain\n     */\n    function circulatingSupply() external view returns (uint);\n\n    /**\n     * @dev returns the address of the ERC20 token\n     */\n    function token() external view returns (address);\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/token/oft/v2/IOFTReceiverV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\ninterface IOFTReceiverV2 {\n    /**\n     * @dev Called by the OFT contract when tokens are received from source chain.\n     * @param _srcChainId The chain id of the source chain.\n     * @param _srcAddress The address of the OFT token contract on the source chain.\n     * @param _nonce The nonce of the transaction on the source chain.\n     * @param _from The address of the account who calls the sendAndCall() on the source chain.\n     * @param _amount The amount of tokens to transfer.\n     * @param _payload Additional data with no specified format.\n     */\n    function onOFTReceived(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes32 _from, uint _amount, bytes calldata _payload) external;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/token/oft/v2/IOFTV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"./ICommonOFT.sol\";\n\n/**\n * @dev Interface of the IOFT core standard\n */\ninterface IOFTV2 is ICommonOFT {\n\n    /**\n     * @dev send `_amount` amount of token to (`_dstChainId`, `_toAddress`) from `_from`\n     * `_from` the owner of token\n     * `_dstChainId` the destination chain identifier\n     * `_toAddress` can be any size depending on the `dstChainId`.\n     * `_amount` the quantity of tokens in wei\n     * `_refundAddress` the address LayerZero refunds if too much message fee is sent\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\n     */\n    function sendFrom(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount, LzCallParams calldata _callParams) external payable;\n\n    function sendAndCall(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount, bytes calldata _payload, uint64 _dstGasForCall, LzCallParams calldata _callParams) external payable;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/token/oft/v2/OFTCoreV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../../lzApp/NonblockingLzApp.sol\";\nimport \"../../../util/ExcessivelySafeCall.sol\";\nimport \"./ICommonOFT.sol\";\nimport \"./IOFTReceiverV2.sol\";\n\nabstract contract OFTCoreV2 is NonblockingLzApp {\n    using BytesLib for bytes;\n    using ExcessivelySafeCall for address;\n\n    uint public constant NO_EXTRA_GAS = 0;\n\n    // packet type\n    uint8 public constant PT_SEND = 0;\n    uint8 public constant PT_SEND_AND_CALL = 1;\n\n    uint8 public immutable sharedDecimals;\n\n    bool public useCustomAdapterParams;\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bool))) public creditedPackets;\n\n    /**\n     * @dev Emitted when `_amount` tokens are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\n     * `_nonce` is the outbound nonce\n     */\n    event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes32 indexed _toAddress, uint _amount);\n\n    /**\n     * @dev Emitted when `_amount` tokens are received from `_srcChainId` into the `_toAddress` on the local chain.\n     * `_nonce` is the inbound nonce.\n     */\n    event ReceiveFromChain(uint16 indexed _srcChainId, address indexed _to, uint _amount);\n\n    event SetUseCustomAdapterParams(bool _useCustomAdapterParams);\n\n    event CallOFTReceivedSuccess(uint16 indexed _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _hash);\n\n    event NonContractAddress(address _address);\n\n    // _sharedDecimals should be the minimum decimals on all chains\n    constructor(uint8 _sharedDecimals, address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {\n        sharedDecimals = _sharedDecimals;\n    }\n\n    /************************************************************************\n    * public functions\n    ************************************************************************/\n    function callOnOFTReceived(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes32 _from, address _to, uint _amount, bytes calldata _payload, uint _gasForCall) public virtual {\n        require(_msgSender() == address(this), \"OFTCore: caller must be OFTCore\");\n\n        // send\n        _amount = _transferFrom(address(this), _to, _amount);\n        emit ReceiveFromChain(_srcChainId, _to, _amount);\n\n        // call\n        IOFTReceiverV2(_to).onOFTReceived{gas: _gasForCall}(_srcChainId, _srcAddress, _nonce, _from, _amount, _payload);\n    }\n\n    function setUseCustomAdapterParams(bool _useCustomAdapterParams) public virtual onlyOwner {\n        useCustomAdapterParams = _useCustomAdapterParams;\n        emit SetUseCustomAdapterParams(_useCustomAdapterParams);\n    }\n\n    /************************************************************************\n    * internal functions\n    ************************************************************************/\n    function _estimateSendFee(uint16 _dstChainId, bytes32 _toAddress, uint _amount, bool _useZro, bytes memory _adapterParams) internal view virtual returns (uint nativeFee, uint zroFee) {\n        // mock the payload for sendFrom()\n        bytes memory payload = _encodeSendPayload(_toAddress, _ld2sd(_amount));\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function _estimateSendAndCallFee(uint16 _dstChainId, bytes32 _toAddress, uint _amount, bytes memory _payload, uint64 _dstGasForCall, bool _useZro, bytes memory _adapterParams) internal view virtual returns (uint nativeFee, uint zroFee) {\n        // mock the payload for sendAndCall()\n        bytes memory payload = _encodeSendAndCallPayload(msg.sender, _toAddress, _ld2sd(_amount), _payload, _dstGasForCall);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        uint8 packetType = _payload.toUint8(0);\n\n        if (packetType == PT_SEND) {\n            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n        } else if (packetType == PT_SEND_AND_CALL) {\n            _sendAndCallAck(_srcChainId, _srcAddress, _nonce, _payload);\n        } else {\n            revert(\"OFTCore: unknown packet type\");\n        }\n    }\n\n    function _send(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual returns (uint amount) {\n        _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\n\n        (amount,) = _removeDust(_amount);\n        amount = _debitFrom(_from, _dstChainId, _toAddress, amount); // amount returned should not have dust\n        require(amount > 0, \"OFTCore: amount too small\");\n\n        bytes memory lzPayload = _encodeSendPayload(_toAddress, _ld2sd(amount));\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\n    }\n\n    function _sendAck(uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal virtual {\n        (address to, uint64 amountSD) = _decodeSendPayload(_payload);\n        if (to == address(0)) {\n            to = address(0xdead);\n        }\n\n        uint amount = _sd2ld(amountSD);\n        amount = _creditTo(_srcChainId, to, amount);\n\n        emit ReceiveFromChain(_srcChainId, to, amount);\n    }\n\n    function _sendAndCall(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount, bytes memory _payload, uint64 _dstGasForCall, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual returns (uint amount) {\n        _checkAdapterParams(_dstChainId, PT_SEND_AND_CALL, _adapterParams, _dstGasForCall);\n\n        (amount,) = _removeDust(_amount);\n        amount = _debitFrom(_from, _dstChainId, _toAddress, amount);\n        require(amount > 0, \"OFTCore: amount too small\");\n\n        // encode the msg.sender into the payload instead of _from\n        bytes memory lzPayload = _encodeSendAndCallPayload(msg.sender, _toAddress, _ld2sd(amount), _payload, _dstGasForCall);\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\n    }\n\n    function _sendAndCallAck(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual {\n        (bytes32 from, address to, uint64 amountSD, bytes memory payloadForCall, uint64 gasForCall) = _decodeSendAndCallPayload(_payload);\n\n        bool credited = creditedPackets[_srcChainId][_srcAddress][_nonce];\n        uint amount = _sd2ld(amountSD);\n\n        // credit to this contract first, and then transfer to receiver only if callOnOFTReceived() succeeds\n        if (!credited) {\n            amount = _creditTo(_srcChainId, address(this), amount);\n            creditedPackets[_srcChainId][_srcAddress][_nonce] = true;\n        }\n\n        if (!_isContract(to)) {\n            emit NonContractAddress(to);\n            return;\n        }\n\n        // workaround for stack too deep\n        uint16 srcChainId = _srcChainId;\n        bytes memory srcAddress = _srcAddress;\n        uint64 nonce = _nonce;\n        bytes memory payload = _payload;\n        bytes32 from_ = from;\n        address to_ = to;\n        uint amount_ = amount;\n        bytes memory payloadForCall_ = payloadForCall;\n\n        // no gas limit for the call if retry\n        uint gas = credited ? gasleft() : gasForCall;\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft(), 150, abi.encodeWithSelector(this.callOnOFTReceived.selector, srcChainId, srcAddress, nonce, from_, to_, amount_, payloadForCall_, gas));\n\n        if (success) {\n            bytes32 hash = keccak256(payload);\n            emit CallOFTReceivedSuccess(srcChainId, srcAddress, nonce, hash);\n        } else {\n            // store the failed message into the nonblockingLzApp\n            _storeFailedMessage(srcChainId, srcAddress, nonce, payload, reason);\n        }\n    }\n\n    function _isContract(address _account) internal view returns (bool) {\n        return _account.code.length > 0;\n    }\n\n    function _checkAdapterParams(uint16 _dstChainId, uint16 _pkType, bytes memory _adapterParams, uint _extraGas) internal virtual {\n        if (useCustomAdapterParams) {\n            _checkGasLimit(_dstChainId, _pkType, _adapterParams, _extraGas);\n        } else {\n            require(_adapterParams.length == 0, \"OFTCore: _adapterParams must be empty.\");\n        }\n    }\n\n    function _ld2sd(uint _amount) internal virtual view returns (uint64) {\n        uint amountSD = _amount / _ld2sdRate();\n        require(amountSD <= type(uint64).max, \"OFTCore: amountSD overflow\");\n        return uint64(amountSD);\n    }\n\n    function _sd2ld(uint64 _amountSD) internal virtual view returns (uint) {\n        return _amountSD * _ld2sdRate();\n    }\n\n    function _removeDust(uint _amount) internal virtual view returns (uint amountAfter, uint dust) {\n        dust = _amount % _ld2sdRate();\n        amountAfter = _amount - dust;\n    }\n\n    function _encodeSendPayload(bytes32 _toAddress, uint64 _amountSD) internal virtual view returns (bytes memory) {\n        return abi.encodePacked(PT_SEND, _toAddress, _amountSD);\n    }\n\n    function _decodeSendPayload(bytes memory _payload) internal virtual view returns (address to, uint64 amountSD) {\n        require(_payload.toUint8(0) == PT_SEND && _payload.length == 41, \"OFTCore: invalid payload\");\n\n        to = _payload.toAddress(13); // drop the first 12 bytes of bytes32\n        amountSD = _payload.toUint64(33);\n    }\n\n    function _encodeSendAndCallPayload(address _from, bytes32 _toAddress, uint64 _amountSD, bytes memory _payload, uint64 _dstGasForCall) internal virtual view returns (bytes memory) {\n        return abi.encodePacked(\n            PT_SEND_AND_CALL,\n            _toAddress,\n            _amountSD,\n            _addressToBytes32(_from),\n            _dstGasForCall,\n            _payload\n        );\n    }\n\n    function _decodeSendAndCallPayload(bytes memory _payload) internal virtual view returns (bytes32 from, address to, uint64 amountSD, bytes memory payload, uint64 dstGasForCall) {\n        require(_payload.toUint8(0) == PT_SEND_AND_CALL, \"OFTCore: invalid payload\");\n\n        to = _payload.toAddress(13); // drop the first 12 bytes of bytes32\n        amountSD = _payload.toUint64(33);\n        from = _payload.toBytes32(41);\n        dstGasForCall = _payload.toUint64(73);\n        payload = _payload.slice(81, _payload.length - 81);\n    }\n\n    function _addressToBytes32(address _address) internal pure virtual returns (bytes32) {\n        return bytes32(uint(uint160(_address)));\n    }\n\n    function _debitFrom(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount) internal virtual returns (uint);\n\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual returns (uint);\n\n    function _transferFrom(address _from, address _to, uint _amount) internal virtual returns (uint);\n\n    function _ld2sdRate() internal view virtual returns (uint);\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/token/oft/v2/OFTV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./BaseOFTV2.sol\";\n\ncontract OFTV2 is BaseOFTV2, ERC20 {\n\n    uint internal immutable ld2sdRate;\n\n    constructor(string memory _name, string memory _symbol, uint8 _sharedDecimals, address _lzEndpoint) ERC20(_name, _symbol) BaseOFTV2(_sharedDecimals, _lzEndpoint) {\n        uint8 decimals = decimals();\n        require(_sharedDecimals <= decimals, \"OFT: sharedDecimals must be <= decimals\");\n        ld2sdRate = 10 ** (decimals - _sharedDecimals);\n    }\n\n    /************************************************************************\n    * public functions\n    ************************************************************************/\n    function circulatingSupply() public view virtual override returns (uint) {\n        return totalSupply();\n    }\n\n    function token() public view virtual override returns (address) {\n        return address(this);\n    }\n\n    /************************************************************************\n    * internal functions\n    ************************************************************************/\n    function _debitFrom(address _from, uint16, bytes32, uint _amount) internal virtual override returns (uint) {\n        address spender = _msgSender();\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\n        _burn(_from, _amount);\n        return _amount;\n    }\n\n    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns (uint) {\n        _mint(_toAddress, _amount);\n        return _amount;\n    }\n\n    function _transferFrom(address _from, address _to, uint _amount) internal virtual override returns (uint) {\n        address spender = _msgSender();\n        // if transfer from this contract, no need to check allowance\n        if (_from != address(this) && _from != spender) _spendAllowance(_from, spender, _amount);\n        _transfer(_from, _to, _amount);\n        return _amount;\n    }\n\n    function _ld2sdRate() internal view virtual override returns (uint) {\n        return ld2sdRate;\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/util/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonalo S <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n        // Store the length of the first bytes array at the beginning of\n        // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n        // Maintain a memory counter for the current write location in the\n        // temp bytes array by adding the 32 bytes for the array length to\n        // the starting location.\n            let mc := add(tempBytes, 0x20)\n        // Stop copying when the memory counter reaches the length of the\n        // first bytes array.\n            let end := add(mc, length)\n\n            for {\n            // Initialize a copy counter to the start of the _preBytes data,\n            // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n            // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n            // Write the _preBytes data into the tempBytes memory 32 bytes\n            // at a time.\n                mstore(mc, mload(cc))\n            }\n\n        // Add the length of _postBytes to the current length of tempBytes\n        // and store it as the new length in the first 32 bytes of the\n        // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n        // Move the memory counter back from a multiple of 0x20 to the\n        // actual end of the _preBytes data.\n            mc := end\n        // Stop copying when the memory counter reaches the new combined\n        // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n        // Update the free-memory pointer by padding our last write location\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n        // next 32 byte block, then round down to the nearest multiple of\n        // 32. If the sum of the length of the two arrays is zero then add\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n            not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n        // Read the first 32 bytes of _preBytes storage, which is the length\n        // of the array. (We don't need to use the offset into the slot\n        // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n        // Arrays of 31 bytes or less have an even value in their slot,\n        // while longer arrays have an odd value. The actual length is\n        // the slot divided by two for odd values, and the lowest order\n        // byte divided by two for even values.\n        // If the slot is even, bitwise and the slot with 255 and divide by\n        // two to get the length. If the slot is odd, bitwise and the slot\n        // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n        // slength can contain both the length and contents of the array\n        // if length < 32 bytes so let's prepare for that\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n            // Since the new array still fits in the slot, we just need to\n            // update the contents of the slot.\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                _preBytes.slot,\n                // all the modifications to the slot are inside this\n                // next block\n                add(\n                // we can just add to the slot contents because the\n                // bytes we want to change are the LSBs\n                fslot,\n                add(\n                mul(\n                div(\n                // load the bytes from memory\n                mload(add(_postBytes, 0x20)),\n                // zero all bytes to the right\n                exp(0x100, sub(32, mlength))\n                ),\n                // and now shift left the number of bytes to\n                // leave space for the length in the slot\n                exp(0x100, sub(32, newlength))\n                ),\n                // increase length by the double of the memory\n                // bytes length\n                mul(mlength, 2)\n                )\n                )\n                )\n            }\n            case 1 {\n            // The stored value fits in the slot, but the combined value\n            // will exceed it.\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // The contents of the _postBytes array start 32 bytes into\n            // the structure. Our first read should obtain the `submod`\n            // bytes that can fit into the unused space in the last word\n            // of the stored array. To get this, we read 32 bytes starting\n            // from `submod`, so the data we read overlaps with the array\n            // contents by `submod` bytes. Masking the lowest-order\n            // `submod` bytes allows us to add that value directly to the\n            // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                sc,\n                add(\n                and(\n                fslot,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                ),\n                and(mload(mc), mask)\n                )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n            // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // Copy over the first `submod` bytes of the new data as in\n            // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don't care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we're done copying, we overwrite the full first word with\n            // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin's length\n            // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n            //zero out the 32 bytes slice we are about to return\n            //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n        // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n            // cb is a circuit breaker in the for loop since there's\n            //  no said feature for inline assembly loops\n            // cb = 1 - don't breaker\n            // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                    // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    view\n    returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n        // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n        // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n        // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                    // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                        // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                    // cb is a circuit breaker in the for loop since there's\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don't breaker\n                    // cb = 0 - break\n                        let cb := 1\n\n                    // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                            // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/util/ExcessivelySafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.7.6;\n\nlibrary ExcessivelySafeCall {\n    uint256 constant LOW_28_MASK =\n    0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n            _gas, // gas\n            _target, // recipient\n            0, // ether value\n            add(_calldata, 0x20), // inloc\n            mload(_calldata), // inlen\n            0, // outloc\n            0 // outlen\n            )\n        // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n        // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n        // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeStaticCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n            _gas, // gas\n            _target, // recipient\n            add(_calldata, 0x20), // inloc\n            mload(_calldata), // inlen\n            0, // outloc\n            0 // outlen\n            )\n        // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n        // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n        // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /**\n     * @notice Swaps function selectors in encoded contract calls\n     * @dev Allows reuse of encoded calldata for functions with identical\n     * argument types but different names. It simply swaps out the first 4 bytes\n     * for the new selector. This function modifies memory in place, and should\n     * only be used with caution.\n     * @param _newSelector The new 4-byte selector\n     * @param _buf The encoded contract args\n     */\n    function swapSelector(bytes4 _newSelector, bytes memory _buf)\n    internal\n    pure\n    {\n        require(_buf.length >= 4);\n        uint256 _mask = LOW_28_MASK;\n        assembly {\n        // load the first word of\n            let _word := mload(add(_buf, 0x20))\n        // mask out the top 4 bytes\n        // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@uniswap/lib/contracts/interfaces/IUniswapV2ERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n//solhint-disable-next-line compiler-version\npragma solidity >=0.5.0;\n\n//solhint-disable func-name-mixedcase\ninterface IUniswapV2ERC20 {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@uniswap/lib/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n//solhint-disable-next-line compiler-version\npragma solidity >=0.5.0;\n\n//solhint-disable func-name-mixedcase\n\nimport \"./IUniswapV2ERC20.sol\";\n\ninterface IUniswapV2Pair is IUniswapV2ERC20 {\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(\n        address to\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/lib/contracts/interfaces/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.12;\n\nimport \"./IUniswapV2Router01.sol\";\n\ninterface IUniswapV2Router is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "@uniswap/lib/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.12;\n\n//solhint-disable func-name-mixedcase\n\ninterface IUniswapV2Router01 {\n    function factory() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(\n        uint256 amountIn,\n        address[] calldata path\n    ) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(\n        uint256 amountOut,\n        address[] calldata path\n    ) external view returns (uint256[] memory amounts);\n}\n"
    },
    "@uniswap/lib/contracts/libraries/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.12;\n\n//solhint-disable reason-string\n\nimport \"../interfaces/IUniswapV2Pair.sol\";\n\nlibrary UniswapV2Library {\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(\n        address tokenA,\n        address tokenB\n    ) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            bytes1(0xff),\n                            factory,\n                            keccak256(abi.encodePacked(token0, token1)),\n                            hex\"443533a897cfad2762695078bf6ee9b78b4edcda64ec31e1c83066cee4c90a7e\" // init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(\n            pairFor(factory, tokenA, tokenB)\n        ).getReserves();\n        (reserveA, reserveB) = tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n        require(\n            reserveA > 0 && reserveB > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        amountB = (amountA * reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 numerator = reserveIn * amountOut * 1000;\n        uint256 denominator = (reserveOut - amountOut) * 997;\n        amountIn = numerator / denominator + 1;\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        uint256 amountIn,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                factory,\n                path[i],\n                path[i + 1]\n            );\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address factory,\n        uint256 amountOut,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                factory,\n                path[i - 1],\n                path[i]\n            );\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport {IUniswapV3PoolImmutables} from './pool/IUniswapV3PoolImmutables.sol';\nimport {IUniswapV3PoolState} from './pool/IUniswapV3PoolState.sol';\nimport {IUniswapV3PoolDerivedState} from './pool/IUniswapV3PoolDerivedState.sol';\nimport {IUniswapV3PoolActions} from './pool/IUniswapV3PoolActions.sol';\nimport {IUniswapV3PoolOwnerActions} from './pool/IUniswapV3PoolOwnerActions.sol';\nimport {IUniswapV3PoolErrors} from './pool/IUniswapV3PoolErrors.sol';\nimport {IUniswapV3PoolEvents} from './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolErrors,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Errors emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolErrors {\n    error LOK();\n    error TLU();\n    error TLM();\n    error TUM();\n    error AI();\n    error M0();\n    error M1();\n    error AS();\n    error IIA();\n    error L();\n    error F0();\n    error F1();\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// @return tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// @return observationIndex The index of the last oracle observation that was written,\n    /// @return observationCardinality The current maximum number of observations stored in the pool,\n    /// @return observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// @return feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    /// @return The liquidity at the current price of the pool\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper\n    /// @return liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// @return feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// @return feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// @return tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// @return secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// @return secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// @return initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return liquidity The amount of liquidity in the position,\n    /// @return feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// @return feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// @return tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// @return tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// @return tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// @return secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// @return initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                require(denominator > 0);\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos = (0 - denominator) & denominator;\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            result = mulDiv(a, b, denominator);\n            if (mulmod(a, b, denominator) > 0) {\n                require(result < type(uint256).max);\n                result++;\n            }\n        }\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    error T();\n    error R();\n\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n            if (absTick > uint256(int256(MAX_TICK))) revert T();\n\n            uint256 ratio = absTick & 0x1 != 0\n                ? 0xfffcb933bd6fad37aa2d162d1a594001\n                : 0x100000000000000000000000000000000;\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            if (tick > 0) ratio = type(uint256).max / ratio;\n\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        unchecked {\n            // second inequality must be < because the price can never reach the price at the max tick\n            if (!(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO)) revert R();\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = ratio;\n            uint256 msb = 0;\n\n            assembly {\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(5, gt(r, 0xFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(4, gt(r, 0xFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(3, gt(r, 0xFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(2, gt(r, 0xF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(1, gt(r, 0x3))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := gt(r, 0x1)\n                msb := or(msb, f)\n            }\n\n            if (msb >= 128) r = ratio >> (msb - 127);\n            else r = ratio << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n        }\n    }\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.9.0;\n\nimport '@uniswap/v3-core/contracts/libraries/FullMath.sol';\nimport '@uniswap/v3-core/contracts/libraries/TickMath.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\n\n/// @title Oracle library\n/// @notice Provides functions to integrate with V3 pool oracle\nlibrary OracleLibrary {\n    /// @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool\n    /// @param pool Address of the pool that we want to observe\n    /// @param secondsAgo Number of seconds in the past from which to calculate the time-weighted means\n    /// @return arithmeticMeanTick The arithmetic mean tick from (block.timestamp - secondsAgo) to block.timestamp\n    /// @return harmonicMeanLiquidity The harmonic mean liquidity from (block.timestamp - secondsAgo) to block.timestamp\n    function consult(address pool, uint32 secondsAgo)\n        internal\n        view\n        returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity)\n    {\n        require(secondsAgo != 0, 'BP');\n\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = secondsAgo;\n        secondsAgos[1] = 0;\n\n        (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) = IUniswapV3Pool(pool)\n            .observe(secondsAgos);\n\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n        uint160 secondsPerLiquidityCumulativesDelta = secondsPerLiquidityCumulativeX128s[1] -\n            secondsPerLiquidityCumulativeX128s[0];\n\n        arithmeticMeanTick = int24(tickCumulativesDelta / int56(uint56(secondsAgo)));\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(uint56(secondsAgo)) != 0)) arithmeticMeanTick--;\n\n        // We are multiplying here instead of shifting to ensure that harmonicMeanLiquidity doesn't overflow uint128\n        uint192 secondsAgoX160 = uint192(secondsAgo) * type(uint160).max;\n        harmonicMeanLiquidity = uint128(secondsAgoX160 / (uint192(secondsPerLiquidityCumulativesDelta) << 32));\n    }\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    function getQuoteAtTick(\n        int24 tick,\n        uint128 baseAmount,\n        address baseToken,\n        address quoteToken\n    ) internal pure returns (uint256 quoteAmount) {\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n        if (sqrtRatioX96 <= type(uint128).max) {\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n        } else {\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n        }\n    }\n\n    /// @notice Given a pool, it returns the number of seconds ago of the oldest stored observation\n    /// @param pool Address of Uniswap V3 pool that we want to observe\n    /// @return secondsAgo The number of seconds ago of the oldest observation stored for the pool\n    function getOldestObservationSecondsAgo(address pool) internal view returns (uint32 secondsAgo) {\n        (, , uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n        require(observationCardinality > 0, 'NI');\n\n        (uint32 observationTimestamp, , , bool initialized) = IUniswapV3Pool(pool).observations(\n            (observationIndex + 1) % observationCardinality\n        );\n\n        // The next index might not be initialized if the cardinality is in the process of increasing\n        // In this case the oldest observation is always in index 0\n        if (!initialized) {\n            (observationTimestamp, , , ) = IUniswapV3Pool(pool).observations(0);\n        }\n\n        unchecked {\n            secondsAgo = uint32(block.timestamp) - observationTimestamp;\n        }\n    }\n\n    /// @notice Given a pool, it returns the tick value as of the start of the current block\n    /// @param pool Address of Uniswap V3 pool\n    /// @return The tick that the pool was in at the start of the current block\n    function getBlockStartingTickAndLiquidity(address pool) internal view returns (int24, uint128) {\n        (, int24 tick, uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n\n        // 2 observations are needed to reliably calculate the block starting tick\n        require(observationCardinality > 1, 'NEO');\n\n        // If the latest observation occurred in the past, then no tick-changing trades have happened in this block\n        // therefore the tick in `slot0` is the same as at the beginning of the current block.\n        // We don't need to check if this observation is initialized - it is guaranteed to be.\n        (\n            uint32 observationTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n\n        ) = IUniswapV3Pool(pool).observations(observationIndex);\n        if (observationTimestamp != uint32(block.timestamp)) {\n            return (tick, IUniswapV3Pool(pool).liquidity());\n        }\n\n        uint256 prevIndex = (uint256(observationIndex) + observationCardinality - 1) % observationCardinality;\n        (\n            uint32 prevObservationTimestamp,\n            int56 prevTickCumulative,\n            uint160 prevSecondsPerLiquidityCumulativeX128,\n            bool prevInitialized\n        ) = IUniswapV3Pool(pool).observations(prevIndex);\n\n        require(prevInitialized, 'ONI');\n\n        uint32 delta = observationTimestamp - prevObservationTimestamp;\n        tick = int24((tickCumulative - int56(uint56(prevTickCumulative))) / int56(uint56(delta)));\n        uint128 liquidity = uint128(\n            (uint192(delta) * type(uint160).max) /\n                (uint192(secondsPerLiquidityCumulativeX128 - prevSecondsPerLiquidityCumulativeX128) << 32)\n        );\n        return (tick, liquidity);\n    }\n\n    /// @notice Information for calculating a weighted arithmetic mean tick\n    struct WeightedTickData {\n        int24 tick;\n        uint128 weight;\n    }\n\n    /// @notice Given an array of ticks and weights, calculates the weighted arithmetic mean tick\n    /// @param weightedTickData An array of ticks and weights\n    /// @return weightedArithmeticMeanTick The weighted arithmetic mean tick\n    /// @dev Each entry of `weightedTickData` should represents ticks from pools with the same underlying pool tokens. If they do not,\n    /// extreme care must be taken to ensure that ticks are comparable (including decimal differences).\n    /// @dev Note that the weighted arithmetic mean tick corresponds to the weighted geometric mean price.\n    function getWeightedArithmeticMeanTick(WeightedTickData[] memory weightedTickData)\n        internal\n        pure\n        returns (int24 weightedArithmeticMeanTick)\n    {\n        // Accumulates the sum of products between each tick and its weight\n        int256 numerator;\n\n        // Accumulates the sum of the weights\n        uint256 denominator;\n\n        // Products fit in 152 bits, so it would take an array of length ~2**104 to overflow this logic\n        for (uint256 i; i < weightedTickData.length; i++) {\n            numerator += weightedTickData[i].tick * int256(uint256(weightedTickData[i].weight));\n            denominator += weightedTickData[i].weight;\n        }\n\n        weightedArithmeticMeanTick = int24(numerator / int256(denominator));\n        // Always round to negative infinity\n        if (numerator < 0 && (numerator % int256(denominator) != 0)) weightedArithmeticMeanTick--;\n    }\n\n    /// @notice Returns the \"synthetic\" tick which represents the price of the first entry in `tokens` in terms of the last\n    /// @dev Useful for calculating relative prices along routes.\n    /// @dev There must be one tick for each pairwise set of tokens.\n    /// @param tokens The token contract addresses\n    /// @param ticks The ticks, representing the price of each token pair in `tokens`\n    /// @return syntheticTick The synthetic tick, representing the relative price of the outermost tokens in `tokens`\n    function getChainedPrice(address[] memory tokens, int24[] memory ticks)\n        internal\n        pure\n        returns (int256 syntheticTick)\n    {\n        require(tokens.length - 1 == ticks.length, 'DL');\n        for (uint256 i = 1; i <= ticks.length; i++) {\n            // check the tokens for address sort order, then accumulate the\n            // ticks into the running synthetic tick, ensuring that intermediate tokens \"cancel out\"\n            tokens[i - 1] < tokens[i] ? syntheticTick += ticks[i - 1] : syntheticTick -= ticks[i - 1];\n        }\n    }\n}\n"
    },
    "contracts/dependencies/math/BConst.sol": {
      "content": "// https://github.com/balancer-labs/balancer-core/blob/master/contracts/BConst.sol\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.8.12;\n\ncontract BConst {\n\tuint public constant BONE = 10 ** 18;\n\n\tuint public constant MIN_BOUND_TOKENS = 2;\n\tuint public constant MAX_BOUND_TOKENS = 8;\n\n\tuint public constant MIN_FEE = BONE / 10 ** 6;\n\tuint public constant MAX_FEE = BONE / 10;\n\tuint public constant EXIT_FEE = 0;\n\n\tuint public constant MIN_WEIGHT = BONE;\n\tuint public constant MAX_WEIGHT = BONE * 50;\n\tuint public constant MAX_TOTAL_WEIGHT = BONE * 50;\n\tuint public constant MIN_BALANCE = BONE / 10 ** 12;\n\n\tuint public constant INIT_POOL_SUPPLY = BONE * 100;\n\n\tuint public constant MIN_BPOW_BASE = 1 wei;\n\tuint public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n\tuint public constant BPOW_PRECISION = BONE / 10 ** 10;\n\n\tuint public constant MAX_IN_RATIO = BONE / 2;\n\tuint public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n}\n"
    },
    "contracts/dependencies/math/BNum.sol": {
      "content": "// https://github.com/balancer-labs/balancer-core/blob/master/contracts/BNum.sol\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.8.12;\n\nimport \"./BConst.sol\";\n\ncontract BNum is BConst {\n\tfunction btoi(uint a) internal pure returns (uint) {\n\t\treturn a / BONE;\n\t}\n\n\tfunction bfloor(uint a) internal pure returns (uint) {\n\t\treturn btoi(a) * BONE;\n\t}\n\n\tfunction badd(uint a, uint b) internal pure returns (uint) {\n\t\tuint c = a + b;\n\t\trequire(c >= a, \"ERR_ADD_OVERFLOW\");\n\t\treturn c;\n\t}\n\n\tfunction bsub(uint a, uint b) internal pure returns (uint) {\n\t\t(uint c, bool flag) = bsubSign(a, b);\n\t\trequire(!flag, \"ERR_SUB_UNDERFLOW\");\n\t\treturn c;\n\t}\n\n\tfunction bsubSign(uint a, uint b) internal pure returns (uint, bool) {\n\t\tif (a >= b) {\n\t\t\treturn (a - b, false);\n\t\t} else {\n\t\t\treturn (b - a, true);\n\t\t}\n\t}\n\n\tfunction bmul(uint a, uint b) internal pure returns (uint) {\n\t\tuint c0 = a * b;\n\t\trequire(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n\t\tuint c1 = c0 + (BONE / 2);\n\t\trequire(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n\t\tuint c2 = c1 / BONE;\n\t\treturn c2;\n\t}\n\n\tfunction bdiv(uint a, uint b) internal pure returns (uint) {\n\t\trequire(b != 0, \"ERR_DIV_ZERO\");\n\t\tuint c0 = a * BONE;\n\t\trequire(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n\t\tuint c1 = c0 + (b / 2);\n\t\trequire(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n\t\tuint c2 = c1 / b;\n\t\treturn c2;\n\t}\n\n\t// DSMath.wpow\n\tfunction bpowi(uint a, uint n) internal pure returns (uint) {\n\t\tuint z = n % 2 != 0 ? a : BONE;\n\n\t\tfor (n /= 2; n != 0; n /= 2) {\n\t\t\ta = bmul(a, a);\n\n\t\t\tif (n % 2 != 0) {\n\t\t\t\tz = bmul(z, a);\n\t\t\t}\n\t\t}\n\t\treturn z;\n\t}\n\n\t// Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n\t// Use `bpowi` for `b^e` and `bpowK` for k iterations\n\t// of approximation of b^0.w\n\tfunction bpow(uint base, uint exp) internal pure returns (uint) {\n\t\trequire(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\n\t\trequire(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\n\n\t\tuint whole = bfloor(exp);\n\t\tuint remain = bsub(exp, whole);\n\n\t\tuint wholePow = bpowi(base, btoi(whole));\n\n\t\tif (remain == 0) {\n\t\t\treturn wholePow;\n\t\t}\n\n\t\tuint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n\t\treturn bmul(wholePow, partialResult);\n\t}\n\n\tfunction bpowApprox(uint base, uint exp, uint precision) internal pure returns (uint) {\n\t\t// term 0:\n\t\tuint a = exp;\n\t\t(uint x, bool xneg) = bsubSign(base, BONE);\n\t\tuint term = BONE;\n\t\tuint sum = term;\n\t\tbool negative = false;\n\n\t\t// term(k) = numer / denom\n\t\t//         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n\t\t// each iteration, multiply previous term by (a-(k-1)) * x / k\n\t\t// continue until term is less than precision\n\t\tfor (uint i = 1; term >= precision; i++) {\n\t\t\tuint bigK = i * BONE;\n\t\t\t(uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n\t\t\tterm = bmul(term, bmul(c, x));\n\t\t\tterm = bdiv(term, bigK);\n\t\t\tif (term == 0) break;\n\n\t\t\tif (xneg) negative = !negative;\n\t\t\tif (cneg) negative = !negative;\n\t\t\tif (negative) {\n\t\t\t\tsum = bsub(sum, term);\n\t\t\t} else {\n\t\t\t\tsum = badd(sum, term);\n\t\t\t}\n\t\t}\n\n\t\treturn sum;\n\t}\n}\n"
    },
    "contracts/dependencies/math/HomoraMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nlibrary HomoraMath {\n\tusing SafeMath for uint;\n\n\tfunction divCeil(uint lhs, uint rhs) internal pure returns (uint) {\n\t\treturn lhs.add(rhs).sub(1) / rhs;\n\t}\n\n\tfunction fmul(uint lhs, uint rhs) internal pure returns (uint) {\n\t\treturn lhs.mul(rhs) / (2 ** 112);\n\t}\n\n\tfunction fdiv(uint lhs, uint rhs) internal pure returns (uint) {\n\t\treturn lhs.mul(2 ** 112) / rhs;\n\t}\n\n\t// implementation from https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c5292fb8291a0\n\t// original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n\tfunction sqrt(uint x) internal pure returns (uint) {\n\t\tif (x == 0) return 0;\n\t\tuint xx = x;\n\t\tuint r = 1;\n\n\t\tif (xx >= 0x100000000000000000000000000000000) {\n\t\t\txx >>= 128;\n\t\t\tr <<= 64;\n\t\t}\n\n\t\tif (xx >= 0x10000000000000000) {\n\t\t\txx >>= 64;\n\t\t\tr <<= 32;\n\t\t}\n\t\tif (xx >= 0x100000000) {\n\t\t\txx >>= 32;\n\t\t\tr <<= 16;\n\t\t}\n\t\tif (xx >= 0x10000) {\n\t\t\txx >>= 16;\n\t\t\tr <<= 8;\n\t\t}\n\t\tif (xx >= 0x100) {\n\t\t\txx >>= 8;\n\t\t\tr <<= 4;\n\t\t}\n\t\tif (xx >= 0x10) {\n\t\t\txx >>= 4;\n\t\t\tr <<= 2;\n\t\t}\n\t\tif (xx >= 0x8) {\n\t\t\tr <<= 1;\n\t\t}\n\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1; // Seven iterations should be enough\n\t\tuint r1 = x / r;\n\t\treturn (r < r1 ? r : r1);\n\t}\n}\n"
    },
    "contracts/dependencies/openzeppelin/contracts/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n\tfunction _msgSender() internal view virtual returns (address payable) {\n\t\treturn payable(msg.sender);\n\t}\n\n\tfunction _msgData() internal view virtual returns (bytes memory) {\n\t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\t\treturn msg.data;\n\t}\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/AdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./BaseAdminUpgradeabilityProxy.sol\";\n\n/**\n * @title AdminUpgradeabilityProxy\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for\n * initializing the implementation, admin, and init data.\n */\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\n\t/**\n\t * Contract constructor.\n\t * @param _logic address of the initial implementation.\n\t * @param _admin Address of the proxy administrator.\n\t * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n\t * It should include the signature and the parameters of the function to be called, as described in\n\t * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n\t * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n\t */\n\tconstructor(address _logic, address _admin, bytes memory _data) payable UpgradeabilityProxy(_logic, _data) {\n\t\tassert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n\t\t_setAdmin(_admin);\n\t}\n\n\t/**\n\t * @dev Only fall back when the sender is not the admin.\n\t */\n\tfunction _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) {\n\t\tBaseAdminUpgradeabilityProxy._willFallback();\n\t}\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/BaseAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./UpgradeabilityProxy.sol\";\n\n/**\n * @title BaseAdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n\t/**\n\t * @dev Emitted when the administration has been transferred.\n\t * @param previousAdmin Address of the previous admin.\n\t * @param newAdmin Address of the new admin.\n\t */\n\tevent AdminChanged(address previousAdmin, address newAdmin);\n\n\t/**\n\t * @dev Storage slot with the admin of the contract.\n\t * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n\t * validated in the constructor.\n\t */\n\tbytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n\t/**\n\t * @dev Modifier to check whether the `msg.sender` is the admin.\n\t * If it is, it will run the function. Otherwise, it will delegate the call\n\t * to the implementation.\n\t */\n\tmodifier ifAdmin() {\n\t\tif (msg.sender == _admin()) {\n\t\t\t_;\n\t\t} else {\n\t\t\t_fallback();\n\t\t}\n\t}\n\n\t/**\n\t * @return _address The address of the proxy admin.\n\t */\n\tfunction admin() external ifAdmin returns (address _address) {\n\t\treturn _admin();\n\t}\n\n\t/**\n\t * @return _address The address of the implementation.\n\t */\n\tfunction implementation() external ifAdmin returns (address _address) {\n\t\treturn _implementation();\n\t}\n\n\t/**\n\t * @dev Changes the admin of the proxy.\n\t * Only the current admin can call this function.\n\t * @param newAdmin Address to transfer proxy administration to.\n\t */\n\tfunction changeAdmin(address newAdmin) external ifAdmin {\n\t\trequire(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n\t\temit AdminChanged(_admin(), newAdmin);\n\t\t_setAdmin(newAdmin);\n\t}\n\n\t/**\n\t * @dev Upgrade the backing implementation of the proxy.\n\t * Only the admin can call this function.\n\t * @param newImplementation Address of the new implementation.\n\t */\n\tfunction upgradeTo(address newImplementation) external ifAdmin {\n\t\t_upgradeTo(newImplementation);\n\t}\n\n\t/**\n\t * @dev Upgrade the backing implementation of the proxy and call a function\n\t * on the new implementation.\n\t * This is useful to initialize the proxied contract.\n\t * @param newImplementation Address of the new implementation.\n\t * @param data Data to send as msg.data in the low level call.\n\t * It should include the signature and the parameters of the function to be called, as described in\n\t * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n\t */\n\tfunction upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n\t\t_upgradeTo(newImplementation);\n\t\t(bool success, ) = newImplementation.delegatecall(data);\n\t\trequire(success);\n\t}\n\n\t/**\n\t * @return adm The admin slot.\n\t */\n\tfunction _admin() internal view returns (address adm) {\n\t\tbytes32 slot = ADMIN_SLOT;\n\t\t//solium-disable-next-line\n\t\tassembly {\n\t\t\tadm := sload(slot)\n\t\t}\n\t}\n\n\t/**\n\t * @dev Sets the address of the proxy admin.\n\t * @param newAdmin Address of the new proxy admin.\n\t */\n\tfunction _setAdmin(address newAdmin) internal {\n\t\tbytes32 slot = ADMIN_SLOT;\n\t\t//solium-disable-next-line\n\t\tassembly {\n\t\t\tsstore(slot, newAdmin)\n\t\t}\n\t}\n\n\t/**\n\t * @dev Only fall back when the sender is not the admin.\n\t */\n\tfunction _willFallback() internal virtual override {\n\t\trequire(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n\t\tsuper._willFallback();\n\t}\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./Proxy.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title BaseUpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract BaseUpgradeabilityProxy is Proxy {\n\t/**\n\t * @dev Emitted when the implementation is upgraded.\n\t * @param implementation Address of the new implementation.\n\t */\n\tevent Upgraded(address indexed implementation);\n\n\t/**\n\t * @dev Storage slot with the address of the current implementation.\n\t * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n\t * validated in the constructor.\n\t */\n\tbytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n\t/**\n\t * @dev Returns the current implementation.\n\t * @return impl Address of the current implementation\n\t */\n\tfunction _implementation() internal view override returns (address impl) {\n\t\tbytes32 slot = IMPLEMENTATION_SLOT;\n\t\t//solium-disable-next-line\n\t\tassembly {\n\t\t\timpl := sload(slot)\n\t\t}\n\t}\n\n\t/**\n\t * @dev Upgrades the proxy to a new implementation.\n\t * @param newImplementation Address of the new implementation.\n\t */\n\tfunction _upgradeTo(address newImplementation) internal {\n\t\t_setImplementation(newImplementation);\n\t\temit Upgraded(newImplementation);\n\t}\n\n\t/**\n\t * @dev Sets the implementation address of the proxy.\n\t * @param newImplementation Address of the new implementation.\n\t */\n\tfunction _setImplementation(address newImplementation) internal {\n\t\trequire(Address.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n\t\tbytes32 slot = IMPLEMENTATION_SLOT;\n\n\t\t//solium-disable-next-line\n\t\tassembly {\n\t\t\tsstore(slot, newImplementation)\n\t\t}\n\t}\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./Initializable.sol\";\n\ncontract ContextUpgradeable is Initializable {\n\tfunction __Context_init() internal onlyInitializing {}\n\n\tfunction __Context_init_unchained() internal onlyInitializing {}\n\n\tfunction _msgSender() internal view virtual returns (address payable) {\n\t\treturn payable(msg.sender);\n\t}\n\n\tfunction _msgData() internal view virtual returns (bytes memory) {\n\t\tthis;\n\t\treturn msg.data;\n\t}\n\n\tuint256[50] private __gap;\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/Initializable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\t/**\n\t * @dev Indicates that the contract has been initialized.\n\t */\n\tbool private initialized;\n\n\t/**\n\t * @dev Indicates that the contract is in the process of being initialized.\n\t */\n\tbool private initializing;\n\n\t/**\n\t * @dev Modifier to use in the initializer function of a contract.\n\t */\n\tmodifier initializer() {\n\t\trequire(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n\t\tbool isTopLevelCall = !initializing;\n\t\tif (isTopLevelCall) {\n\t\t\tinitializing = true;\n\t\t\tinitialized = true;\n\t\t}\n\n\t\t_;\n\n\t\tif (isTopLevelCall) {\n\t\t\tinitializing = false;\n\t\t}\n\t}\n\n\t/// @dev Returns true if and only if the function is running in the constructor\n\tfunction isConstructor() private view returns (bool) {\n\t\t// extcodesize checks the size of the code stored in an address, and\n\t\t// address returns the current address. Since the code is still not\n\t\t// deployed when running a constructor, any checks on its code size will\n\t\t// yield zero, making it an effective way to detect if a contract is\n\t\t// under construction or not.\n\t\tuint256 cs;\n\t\t//solium-disable-next-line\n\t\tassembly {\n\t\t\tcs := extcodesize(address())\n\t\t}\n\t\treturn cs == 0;\n\t}\n\n\tmodifier onlyInitializing() {\n\t\trequire(initializing, \"Initializable: contract is not initializing\");\n\t\t_;\n\t}\n\n\t// Reserved storage space to allow for layout changes in the future.\n\tuint256[50] private ______gap;\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/InitializableAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./BaseAdminUpgradeabilityProxy.sol\";\nimport \"./InitializableUpgradeabilityProxy.sol\";\n\n/**\n * @title InitializableAdminUpgradeabilityProxy\n * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for\n * initializing the implementation, admin, and init data.\n */\ncontract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {\n\t/**\n\t * Contract initializer.\n\t * @param logic address of the initial implementation.\n\t * @param admin Address of the proxy administrator.\n\t * @param data Data to send as msg.data to the implementation to initialize the proxied contract.\n\t * It should include the signature and the parameters of the function to be called, as described in\n\t * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n\t * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n\t */\n\tfunction initialize(address logic, address admin, bytes memory data) public payable {\n\t\trequire(_implementation() == address(0));\n\t\tInitializableUpgradeabilityProxy.initialize(logic, data);\n\t\tassert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n\t\t_setAdmin(admin);\n\t}\n\n\t/**\n\t * @dev Only fall back when the sender is not the admin.\n\t */\n\tfunction _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) {\n\t\tBaseAdminUpgradeabilityProxy._willFallback();\n\t}\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./BaseUpgradeabilityProxy.sol\";\n\n/**\n * @title InitializableUpgradeabilityProxy\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\n * implementation and init data.\n */\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\n\t/**\n\t * @dev Contract initializer.\n\t * @param _logic Address of the initial implementation.\n\t * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n\t * It should include the signature and the parameters of the function to be called, as described in\n\t * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n\t * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n\t */\n\tfunction initialize(address _logic, bytes memory _data) public payable {\n\t\trequire(_implementation() == address(0));\n\t\tassert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n\t\t_setImplementation(_logic);\n\t\tif (_data.length > 0) {\n\t\t\t(bool success, ) = _logic.delegatecall(_data);\n\t\t\trequire(success);\n\t\t}\n\t}\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./Initializable.sol\";\nimport \"./ContextUpgradeable.sol\";\n\ncontract OwnableUpgradeable is Initializable, ContextUpgradeable {\n\taddress private _owner;\n\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\tfunction __Ownable_init() internal onlyInitializing {\n\t\t__Ownable_init_unchained();\n\t}\n\n\tfunction __Ownable_init_unchained() internal onlyInitializing {\n\t\t_transferOwnership(_msgSender());\n\t}\n\n\tfunction owner() public view virtual returns (address) {\n\t\treturn _owner;\n\t}\n\n\tmodifier onlyOwner() {\n\t\trequire(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n\t\t_;\n\t}\n\n\tfunction renounceOwnership() public virtual onlyOwner {\n\t\t_transferOwnership(address(0));\n\t}\n\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\t_transferOwnership(newOwner);\n\t}\n\n\tfunction _transferOwnership(address newOwner) internal virtual {\n\t\taddress oldOwner = _owner;\n\t\t_owner = newOwner;\n\t\temit OwnershipTransferred(oldOwner, newOwner);\n\t}\n\n\tuint256[49] private __gap;\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./Initializable.sol\";\nimport \"./ContextUpgradeable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n\t/**\n\t * @dev Emitted when the pause is triggered by `account`.\n\t */\n\tevent Paused(address account);\n\n\t/**\n\t * @dev Emitted when the pause is lifted by `account`.\n\t */\n\tevent Unpaused(address account);\n\n\tbool private _paused;\n\n\t/**\n\t * @dev Initializes the contract in unpaused state.\n\t */\n\tfunction __Pausable_init() internal onlyInitializing {\n\t\t__Pausable_init_unchained();\n\t}\n\n\tfunction __Pausable_init_unchained() internal onlyInitializing {\n\t\t_paused = false;\n\t}\n\n\t/**\n\t * @dev Modifier to make a function callable only when the contract is not paused.\n\t *\n\t * Requirements:\n\t *\n\t * - The contract must not be paused.\n\t */\n\tmodifier whenNotPaused() {\n\t\t_requireNotPaused();\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Modifier to make a function callable only when the contract is paused.\n\t *\n\t * Requirements:\n\t *\n\t * - The contract must be paused.\n\t */\n\tmodifier whenPaused() {\n\t\t_requirePaused();\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Returns true if the contract is paused, and false otherwise.\n\t */\n\tfunction paused() public view virtual returns (bool) {\n\t\treturn _paused;\n\t}\n\n\t/**\n\t * @dev Throws if the contract is paused.\n\t */\n\tfunction _requireNotPaused() internal view virtual {\n\t\trequire(!paused(), \"Pausable: paused\");\n\t}\n\n\t/**\n\t * @dev Throws if the contract is not paused.\n\t */\n\tfunction _requirePaused() internal view virtual {\n\t\trequire(paused(), \"Pausable: not paused\");\n\t}\n\n\t/**\n\t * @dev Triggers stopped state.\n\t *\n\t * Requirements:\n\t *\n\t * - The contract must not be paused.\n\t */\n\tfunction _pause() internal virtual whenNotPaused {\n\t\t_paused = true;\n\t\temit Paused(_msgSender());\n\t}\n\n\t/**\n\t * @dev Returns to normal state.\n\t *\n\t * Requirements:\n\t *\n\t * - The contract must be paused.\n\t */\n\tfunction _unpause() internal virtual whenPaused {\n\t\t_paused = false;\n\t\temit Unpaused(_msgSender());\n\t}\n\n\t/**\n\t * @dev This empty reserved space is put in place to allow future versions to add new\n\t * variables without shifting down storage in the inheritance chain.\n\t * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\t */\n\tuint256[49] private __gap;\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/Proxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\nabstract contract Proxy {\n\t/**\n\t * @dev Fallback function.\n\t * Implemented entirely in `_fallback`.\n\t */\n\tfallback() external payable {\n\t\t_fallback();\n\t}\n\n\t/**\n\t * @return The Address of the implementation.\n\t */\n\tfunction _implementation() internal view virtual returns (address);\n\n\t/**\n\t * @dev Delegates execution to an implementation contract.\n\t * This is a low level function that doesn't return to its internal call site.\n\t * It will return to the external caller whatever the implementation returns.\n\t * @param implementation Address to delegate.\n\t */\n\tfunction _delegate(address implementation) internal {\n\t\t//solium-disable-next-line\n\t\tassembly {\n\t\t\t// Copy msg.data. We take full control of memory in this inline assembly\n\t\t\t// block because it will not return to Solidity code. We overwrite the\n\t\t\t// Solidity scratch pad at memory position 0.\n\t\t\tcalldatacopy(0, 0, calldatasize())\n\n\t\t\t// Call the implementation.\n\t\t\t// out and outsize are 0 because we don't know the size yet.\n\t\t\tlet result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n\t\t\t// Copy the returned data.\n\t\t\treturndatacopy(0, 0, returndatasize())\n\n\t\t\tswitch result\n\t\t\t// delegatecall returns 0 on error.\n\t\t\tcase 0 {\n\t\t\t\trevert(0, returndatasize())\n\t\t\t}\n\t\t\tdefault {\n\t\t\t\treturn(0, returndatasize())\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @dev Function that is run as the first thing in the fallback function.\n\t * Can be redefined in derived contracts to add functionality.\n\t * Redefinitions must call super._willFallback().\n\t */\n\tfunction _willFallback() internal virtual {}\n\n\t/**\n\t * @dev fallback implementation.\n\t * Extracted to enable manual triggering.\n\t */\n\tfunction _fallback() internal {\n\t\t_willFallback();\n\t\t_delegate(_implementation());\n\t}\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/UpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./BaseUpgradeabilityProxy.sol\";\n\n/**\n * @title UpgradeabilityProxy\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\n * implementation and init data.\n */\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\n\t/**\n\t * @dev Contract constructor.\n\t * @param _logic Address of the initial implementation.\n\t * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n\t * It should include the signature and the parameters of the function to be called, as described in\n\t * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n\t * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n\t */\n\tconstructor(address _logic, bytes memory _data) payable {\n\t\tassert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n\t\t_setImplementation(_logic);\n\t\tif (_data.length > 0) {\n\t\t\t(bool success, ) = _logic.delegatecall(_data);\n\t\t\trequire(success);\n\t\t}\n\t}\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n\t// credit for this implementation goes to\n\t// https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n\tfunction sqrt(uint256 x) internal pure returns (uint256) {\n\t\tif (x == 0) return 0;\n\t\t// this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n\t\t// however that code costs significantly more gas\n\t\tuint256 xx = x;\n\t\tuint256 r = 1;\n\t\tif (xx >= 0x100000000000000000000000000000000) {\n\t\t\txx >>= 128;\n\t\t\tr <<= 64;\n\t\t}\n\t\tif (xx >= 0x10000000000000000) {\n\t\t\txx >>= 64;\n\t\t\tr <<= 32;\n\t\t}\n\t\tif (xx >= 0x100000000) {\n\t\t\txx >>= 32;\n\t\t\tr <<= 16;\n\t\t}\n\t\tif (xx >= 0x10000) {\n\t\t\txx >>= 16;\n\t\t\tr <<= 8;\n\t\t}\n\t\tif (xx >= 0x100) {\n\t\t\txx >>= 8;\n\t\t\tr <<= 4;\n\t\t}\n\t\tif (xx >= 0x10) {\n\t\t\txx >>= 4;\n\t\t\tr <<= 2;\n\t\t}\n\t\tif (xx >= 0x8) {\n\t\t\tr <<= 1;\n\t\t}\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1; // Seven iterations should be enough\n\t\tuint256 r1 = x / r;\n\t\treturn (r < r1 ? r : r1);\n\t}\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\nlibrary BitMath {\n\t// returns the 0 indexed position of the most significant bit of the input x\n\t// s.t. x >= 2**msb and x < 2**(msb+1)\n\tfunction mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n\t\trequire(x > 0, \"BitMath::mostSignificantBit: zero\");\n\n\t\tif (x >= 0x100000000000000000000000000000000) {\n\t\t\tx >>= 128;\n\t\t\tr += 128;\n\t\t}\n\t\tif (x >= 0x10000000000000000) {\n\t\t\tx >>= 64;\n\t\t\tr += 64;\n\t\t}\n\t\tif (x >= 0x100000000) {\n\t\t\tx >>= 32;\n\t\t\tr += 32;\n\t\t}\n\t\tif (x >= 0x10000) {\n\t\t\tx >>= 16;\n\t\t\tr += 16;\n\t\t}\n\t\tif (x >= 0x100) {\n\t\t\tx >>= 8;\n\t\t\tr += 8;\n\t\t}\n\t\tif (x >= 0x10) {\n\t\t\tx >>= 4;\n\t\t\tr += 4;\n\t\t}\n\t\tif (x >= 0x4) {\n\t\t\tx >>= 2;\n\t\t\tr += 2;\n\t\t}\n\t\tif (x >= 0x2) r += 1;\n\t}\n\n\t// returns the 0 indexed position of the least significant bit of the input x\n\t// s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\n\t// i.e. the bit at the index is set and the mask of all lower bits is 0\n\tfunction leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n\t\trequire(x > 0, \"BitMath::leastSignificantBit: zero\");\n\n\t\tr = 255;\n\t\tif (x & type(uint128).max > 0) {\n\t\t\tr -= 128;\n\t\t} else {\n\t\t\tx >>= 128;\n\t\t}\n\t\tif (x & type(uint64).max > 0) {\n\t\t\tr -= 64;\n\t\t} else {\n\t\t\tx >>= 64;\n\t\t}\n\t\tif (x & type(uint32).max > 0) {\n\t\t\tr -= 32;\n\t\t} else {\n\t\t\tx >>= 32;\n\t\t}\n\t\tif (x & type(uint16).max > 0) {\n\t\t\tr -= 16;\n\t\t} else {\n\t\t\tx >>= 16;\n\t\t}\n\t\tif (x & type(uint8).max > 0) {\n\t\t\tr -= 8;\n\t\t} else {\n\t\t\tx >>= 8;\n\t\t}\n\t\tif (x & 0xf > 0) {\n\t\t\tr -= 4;\n\t\t} else {\n\t\t\tx >>= 4;\n\t\t}\n\t\tif (x & 0x3 > 0) {\n\t\t\tr -= 2;\n\t\t} else {\n\t\t\tx >>= 2;\n\t\t}\n\t\tif (x & 0x1 > 0) r -= 1;\n\t}\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.12;\n\nimport \"./FullMath.sol\";\nimport \"./Babylonian.sol\";\nimport \"./BitMath.sol\";\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n\t// range: [0, 2**112 - 1]\n\t// resolution: 1 / 2**112\n\tstruct uq112x112 {\n\t\tuint224 _x;\n\t}\n\n\t// range: [0, 2**144 - 1]\n\t// resolution: 1 / 2**112\n\tstruct uq144x112 {\n\t\tuint256 _x;\n\t}\n\n\tuint8 public constant RESOLUTION = 112;\n\tuint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112\n\tuint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224\n\tuint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n\t// encode a uint112 as a UQ112x112\n\tfunction encode(uint112 x) internal pure returns (uq112x112 memory) {\n\t\treturn uq112x112(uint224(x) << RESOLUTION);\n\t}\n\n\t// encodes a uint144 as a UQ144x112\n\tfunction encode144(uint144 x) internal pure returns (uq144x112 memory) {\n\t\treturn uq144x112(uint256(x) << RESOLUTION);\n\t}\n\n\t// decode a UQ112x112 into a uint112 by truncating after the radix point\n\tfunction decode(uq112x112 memory self) internal pure returns (uint112) {\n\t\treturn uint112(self._x >> RESOLUTION);\n\t}\n\n\t// decode a UQ144x112 into a uint144 by truncating after the radix point\n\tfunction decode144(uq144x112 memory self) internal pure returns (uint144) {\n\t\treturn uint144(self._x >> RESOLUTION);\n\t}\n\n\t// multiply a UQ112x112 by a uint, returning a UQ144x112\n\t// reverts on overflow\n\tfunction mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n\t\tuint256 z = 0;\n\t\trequire(y == 0 || (z = self._x * y) / y == self._x, \"FixedPoint::mul: overflow\");\n\t\treturn uq144x112(z);\n\t}\n\n\t// multiply a UQ112x112 by an int and decode, returning an int\n\t// reverts on overflow\n\tfunction muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\n\t\tuint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);\n\t\trequire(z < 2 ** 255, \"FixedPoint::muli: overflow\");\n\t\treturn y < 0 ? -int256(z) : int256(z);\n\t}\n\n\t// multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\n\t// lossy\n\tfunction muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n\t\tif (self._x == 0 || other._x == 0) {\n\t\t\treturn uq112x112(0);\n\t\t}\n\t\tuint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\n\t\tuint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\n\t\tuint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\n\t\tuint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\n\n\t\t// partial products\n\t\tuint224 upper = uint224(upper_self) * upper_other; // * 2^0\n\t\tuint224 lower = uint224(lower_self) * lower_other; // * 2^-224\n\t\tuint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\n\t\tuint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\n\n\t\t// so the bit shift does not overflow\n\t\trequire(upper <= type(uint112).max, \"FixedPoint::muluq: upper overflow\");\n\n\t\t// this cannot exceed 256 bits, all values are 224 bits\n\t\tuint256 sum = uint256(upper << RESOLUTION) + uppers_lowero + uppero_lowers + (lower >> RESOLUTION);\n\n\t\t// so the cast does not overflow\n\t\trequire(sum <= type(uint224).max, \"FixedPoint::muluq: sum overflow\");\n\n\t\treturn uq112x112(uint224(sum));\n\t}\n\n\t// divide a UQ112x112 by a UQ112x112, returning a UQ112x112\n\tfunction divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n\t\trequire(other._x > 0, \"FixedPoint::divuq: division by zero\");\n\t\tif (self._x == other._x) {\n\t\t\treturn uq112x112(uint224(Q112));\n\t\t}\n\t\tif (self._x <= type(uint144).max) {\n\t\t\tuint256 value = (uint256(self._x) << RESOLUTION) / other._x;\n\t\t\trequire(value <= type(uint224).max, \"FixedPoint::divuq: overflow\");\n\t\t\treturn uq112x112(uint224(value));\n\t\t}\n\n\t\tuint256 result = FullMath.mulDiv(Q112, self._x, other._x);\n\t\trequire(result <= type(uint224).max, \"FixedPoint::divuq: overflow\");\n\t\treturn uq112x112(uint224(result));\n\t}\n\n\t// returns a UQ112x112 which represents the ratio of the numerator to the denominator\n\t// can be lossy\n\tfunction fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n\t\trequire(denominator > 0, \"FixedPoint::fraction: division by zero\");\n\t\tif (numerator == 0) return FixedPoint.uq112x112(0);\n\n\t\tif (numerator <= type(uint144).max) {\n\t\t\tuint256 result = (numerator << RESOLUTION) / denominator;\n\t\t\trequire(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n\t\t\treturn uq112x112(uint224(result));\n\t\t} else {\n\t\t\tuint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n\t\t\trequire(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n\t\t\treturn uq112x112(uint224(result));\n\t\t}\n\t}\n\n\t// take the reciprocal of a UQ112x112\n\t// reverts on overflow\n\t// lossy\n\tfunction reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n\t\trequire(self._x != 0, \"FixedPoint::reciprocal: reciprocal of zero\");\n\t\trequire(self._x != 1, \"FixedPoint::reciprocal: overflow\");\n\t\treturn uq112x112(uint224(Q224 / self._x));\n\t}\n\n\t// square root of a UQ112x112\n\t// lossy between 0/1 and 40 bits\n\tfunction sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n\t\tif (self._x <= type(uint144).max) {\n\t\t\treturn uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\n\t\t}\n\n\t\tuint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\n\t\tsafeShiftBits -= safeShiftBits % 2;\n\t\treturn uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\n\t}\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n\t/// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n\t/// @param a The multiplicand\n\t/// @param b The multiplier\n\t/// @param denominator The divisor\n\t/// @return result The 256-bit result\n\t/// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n\tfunction mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n\t\tunchecked {\n\t\t\t// 512-bit multiply [prod1 prod0] = a * b\n\t\t\t// Compute the product mod 2**256 and mod 2**256 - 1\n\t\t\t// then use the Chinese Remainder Theorem to reconstruct\n\t\t\t// the 512 bit result. The result is stored in two 256\n\t\t\t// variables such that product = prod1 * 2**256 + prod0\n\t\t\tuint256 prod0; // Least significant 256 bits of the product\n\t\t\tuint256 prod1; // Most significant 256 bits of the product\n\t\t\tassembly {\n\t\t\t\tlet mm := mulmod(a, b, not(0))\n\t\t\t\tprod0 := mul(a, b)\n\t\t\t\tprod1 := sub(sub(mm, prod0), lt(mm, prod0))\n\t\t\t}\n\n\t\t\t// Handle non-overflow cases, 256 by 256 division\n\t\t\tif (prod1 == 0) {\n\t\t\t\trequire(denominator > 0);\n\t\t\t\tassembly {\n\t\t\t\t\tresult := div(prod0, denominator)\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// Make sure the result is less than 2**256.\n\t\t\t// Also prevents denominator == 0\n\t\t\trequire(denominator > prod1);\n\n\t\t\t///////////////////////////////////////////////\n\t\t\t// 512 by 256 division.\n\t\t\t///////////////////////////////////////////////\n\n\t\t\t// Make division exact by subtracting the remainder from [prod1 prod0]\n\t\t\t// Compute remainder using mulmod\n\t\t\tuint256 remainder;\n\t\t\tassembly {\n\t\t\t\tremainder := mulmod(a, b, denominator)\n\t\t\t}\n\t\t\t// Subtract 256 bit number from 512 bit number\n\t\t\tassembly {\n\t\t\t\tprod1 := sub(prod1, gt(remainder, prod0))\n\t\t\t\tprod0 := sub(prod0, remainder)\n\t\t\t}\n\n\t\t\t// Factor powers of two out of denominator\n\t\t\t// Compute largest power of two divisor of denominator.\n\t\t\t// Always >= 1.\n\t\t\tuint256 twos = (0 - denominator) & denominator;\n\t\t\t// Divide denominator by power of two\n\t\t\tassembly {\n\t\t\t\tdenominator := div(denominator, twos)\n\t\t\t}\n\n\t\t\t// Divide [prod1 prod0] by the factors of two\n\t\t\tassembly {\n\t\t\t\tprod0 := div(prod0, twos)\n\t\t\t}\n\t\t\t// Shift in bits from prod1 into prod0. For this we need\n\t\t\t// to flip `twos` such that it is 2**256 / twos.\n\t\t\t// If twos is zero, then it becomes one\n\t\t\tassembly {\n\t\t\t\ttwos := add(div(sub(0, twos), twos), 1)\n\t\t\t}\n\t\t\tprod0 |= prod1 * twos;\n\n\t\t\t// Invert denominator mod 2**256\n\t\t\t// Now that denominator is an odd number, it has an inverse\n\t\t\t// modulo 2**256 such that denominator * inv = 1 mod 2**256.\n\t\t\t// Compute the inverse by starting with a seed that is correct\n\t\t\t// correct for four bits. That is, denominator * inv = 1 mod 2**4\n\t\t\tuint256 inv = (3 * denominator) ^ 2;\n\t\t\t// Now use Newton-Raphson iteration to improve the precision.\n\t\t\t// Thanks to Hensel's lifting lemma, this also works in modular\n\t\t\t// arithmetic, doubling the correct bits in each step.\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**8\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**16\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**32\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**64\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**128\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**256\n\n\t\t\t// Because the division is now exact we can divide by multiplying\n\t\t\t// with the modular inverse of denominator. This will give us the\n\t\t\t// correct result modulo 2**256. Since the precoditions guarantee\n\t\t\t// that the outcome is less than 2**256, this is the final result.\n\t\t\t// We don't need to compute the high bits of the result and prod1\n\t\t\t// is no longer required.\n\t\t\tresult = prod0 * inv;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n\t/// @param a The multiplicand\n\t/// @param b The multiplier\n\t/// @param denominator The divisor\n\t/// @return result The 256-bit result\n\tfunction mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n\t\tunchecked {\n\t\t\tresult = mulDiv(a, b, denominator);\n\t\t\tif (mulmod(a, b, denominator) > 0) {\n\t\t\t\trequire(result < type(uint256).max);\n\t\t\t\tresult++;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/UniswapV2OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"./FixedPoint.sol\";\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n\tusing FixedPoint for *;\n\n\t// helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n\tfunction currentBlockTimestamp() internal view returns (uint32) {\n\t\treturn uint32(block.timestamp % 2 ** 32);\n\t}\n\n\t// produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n\tfunction currentCumulativePrices(\n\t\taddress pair\n\t) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n\t\tblockTimestamp = currentBlockTimestamp();\n\t\tprice0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n\t\tprice1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n\t\t// if time has elapsed since the last update on the pair, mock the accumulated price values\n\t\t(uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n\t\tif (blockTimestampLast != blockTimestamp) {\n\t\t\t// subtraction overflow is desired\n\t\t\tuint32 timeElapsed = blockTimestamp - blockTimestampLast;\n\t\t\t// addition overflow is desired\n\t\t\t// counterfactual\n\t\t\tprice0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n\t\t\t// counterfactual\n\t\t\tprice1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n\t\t}\n\t}\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/IUniswapV3Pool.sol": {
      "content": "pragma solidity >=0.6.11;\n\nimport \"./pool/IUniswapV3PoolImmutables.sol\";\nimport \"./pool/IUniswapV3PoolState.sol\";\nimport \"./pool/IUniswapV3PoolDerivedState.sol\";\nimport \"./pool/IUniswapV3PoolActions.sol\";\nimport \"./pool/IUniswapV3PoolOwnerActions.sol\";\nimport \"./pool/IUniswapV3PoolEvents.sol\";\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n\tIUniswapV3PoolImmutables,\n\tIUniswapV3PoolState,\n\tIUniswapV3PoolDerivedState,\n\tIUniswapV3PoolActions,\n\tIUniswapV3PoolOwnerActions,\n\tIUniswapV3PoolEvents\n{\n\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/math/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n\t/// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n\t/// @param a The multiplicand\n\t/// @param b The multiplier\n\t/// @param denominator The divisor\n\t/// @return result The 256-bit result\n\t/// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n\tfunction mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n\t\tunchecked {\n\t\t\t// 512-bit multiply [prod1 prod0] = a * b\n\t\t\t// Compute the product mod 2**256 and mod 2**256 - 1\n\t\t\t// then use the Chinese Remainder Theorem to reconstruct\n\t\t\t// the 512 bit result. The result is stored in two 256\n\t\t\t// variables such that product = prod1 * 2**256 + prod0\n\t\t\tuint256 prod0; // Least significant 256 bits of the product\n\t\t\tuint256 prod1; // Most significant 256 bits of the product\n\t\t\tassembly {\n\t\t\t\tlet mm := mulmod(a, b, not(0))\n\t\t\t\tprod0 := mul(a, b)\n\t\t\t\tprod1 := sub(sub(mm, prod0), lt(mm, prod0))\n\t\t\t}\n\n\t\t\t// Handle non-overflow cases, 256 by 256 division\n\t\t\tif (prod1 == 0) {\n\t\t\t\trequire(denominator > 0);\n\t\t\t\tassembly {\n\t\t\t\t\tresult := div(prod0, denominator)\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// Make sure the result is less than 2**256.\n\t\t\t// Also prevents denominator == 0\n\t\t\trequire(denominator > prod1);\n\n\t\t\t///////////////////////////////////////////////\n\t\t\t// 512 by 256 division.\n\t\t\t///////////////////////////////////////////////\n\n\t\t\t// Make division exact by subtracting the remainder from [prod1 prod0]\n\t\t\t// Compute remainder using mulmod\n\t\t\tuint256 remainder;\n\t\t\tassembly {\n\t\t\t\tremainder := mulmod(a, b, denominator)\n\t\t\t}\n\t\t\t// Subtract 256 bit number from 512 bit number\n\t\t\tassembly {\n\t\t\t\tprod1 := sub(prod1, gt(remainder, prod0))\n\t\t\t\tprod0 := sub(prod0, remainder)\n\t\t\t}\n\n\t\t\t// Factor powers of two out of denominator\n\t\t\t// Compute largest power of two divisor of denominator.\n\t\t\t// Always >= 1.\n\t\t\tuint256 twos = (0 - denominator) & denominator;\n\t\t\t// Divide denominator by power of two\n\t\t\tassembly {\n\t\t\t\tdenominator := div(denominator, twos)\n\t\t\t}\n\n\t\t\t// Divide [prod1 prod0] by the factors of two\n\t\t\tassembly {\n\t\t\t\tprod0 := div(prod0, twos)\n\t\t\t}\n\t\t\t// Shift in bits from prod1 into prod0. For this we need\n\t\t\t// to flip `twos` such that it is 2**256 / twos.\n\t\t\t// If twos is zero, then it becomes one\n\t\t\tassembly {\n\t\t\t\ttwos := add(div(sub(0, twos), twos), 1)\n\t\t\t}\n\t\t\tprod0 |= prod1 * twos;\n\n\t\t\t// Invert denominator mod 2**256\n\t\t\t// Now that denominator is an odd number, it has an inverse\n\t\t\t// modulo 2**256 such that denominator * inv = 1 mod 2**256.\n\t\t\t// Compute the inverse by starting with a seed that is correct\n\t\t\t// correct for four bits. That is, denominator * inv = 1 mod 2**4\n\t\t\tuint256 inv = (3 * denominator) ^ 2;\n\t\t\t// Now use Newton-Raphson iteration to improve the precision.\n\t\t\t// Thanks to Hensel's lifting lemma, this also works in modular\n\t\t\t// arithmetic, doubling the correct bits in each step.\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**8\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**16\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**32\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**64\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**128\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**256\n\n\t\t\t// Because the division is now exact we can divide by multiplying\n\t\t\t// with the modular inverse of denominator. This will give us the\n\t\t\t// correct result modulo 2**256. Since the precoditions guarantee\n\t\t\t// that the outcome is less than 2**256, this is the final result.\n\t\t\t// We don't need to compute the high bits of the result and prod1\n\t\t\t// is no longer required.\n\t\t\tresult = prod0 * inv;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n\t/// @param a The multiplicand\n\t/// @param b The multiplier\n\t/// @param denominator The divisor\n\t/// @return result The 256-bit result\n\tfunction mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n\t\tunchecked {\n\t\t\tresult = mulDiv(a, b, denominator);\n\t\t\tif (mulmod(a, b, denominator) > 0) {\n\t\t\t\trequire(result < type(uint256).max);\n\t\t\t\tresult++;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/math/SafeMath.sol": {
      "content": "pragma solidity >=0.6.11;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n\t/**\n\t * @dev Returns the addition of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `+` operator.\n\t *\n\t * Requirements:\n\t * - Addition cannot overflow.\n\t */\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot overflow.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\trequire(b <= a, errorMessage);\n\t\tuint256 c = a - b;\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `*` operator.\n\t *\n\t * Requirements:\n\t * - Multiplication cannot overflow.\n\t */\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\t\t// benefit is lost if 'b' is also tested.\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn div(a, b, \"SafeMath: division by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b > 0, errorMessage);\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn mod(a, b, \"SafeMath: modulo by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts with custom message when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\trequire(b != 0, errorMessage);\n\t\treturn a % b;\n\t}\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/math/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.12;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n\terror T();\n\terror R();\n\n\t/// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n\tint24 internal constant MIN_TICK = -887272;\n\t/// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n\tint24 internal constant MAX_TICK = -MIN_TICK;\n\n\t/// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n\tuint160 internal constant MIN_SQRT_RATIO = 4295128739;\n\t/// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n\tuint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n\t/// @notice Calculates sqrt(1.0001^tick) * 2^96\n\t/// @dev Throws if |tick| > max tick\n\t/// @param tick The input tick for the above formula\n\t/// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n\t/// at the given tick\n\tfunction getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n\t\tunchecked {\n\t\t\tuint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n\t\t\tif (absTick > uint256(int256(MAX_TICK))) revert T();\n\n\t\t\tuint256 ratio = absTick & 0x1 != 0\n\t\t\t\t? 0xfffcb933bd6fad37aa2d162d1a594001\n\t\t\t\t: 0x100000000000000000000000000000000;\n\t\t\tif (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n\t\t\tif (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n\t\t\tif (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n\t\t\tif (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n\t\t\tif (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n\t\t\tif (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n\t\t\tif (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n\t\t\tif (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n\t\t\tif (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n\t\t\tif (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n\t\t\tif (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n\t\t\tif (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n\t\t\tif (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n\t\t\tif (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n\t\t\tif (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n\t\t\tif (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n\t\t\tif (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n\t\t\tif (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n\t\t\tif (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n\t\t\tif (tick > 0) ratio = type(uint256).max / ratio;\n\n\t\t\t// this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n\t\t\t// we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n\t\t\t// we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n\t\t\tsqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n\t\t}\n\t}\n\n\t/// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n\t/// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n\t/// ever return.\n\t/// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n\t/// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n\tfunction getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n\t\tunchecked {\n\t\t\t// second inequality must be < because the price can never reach the price at the max tick\n\t\t\tif (!(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO)) revert R();\n\t\t\tuint256 ratio = uint256(sqrtPriceX96) << 32;\n\n\t\t\tuint256 r = ratio;\n\t\t\tuint256 msb = 0;\n\n\t\t\tassembly {\n\t\t\t\tlet f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n\t\t\t\tmsb := or(msb, f)\n\t\t\t\tr := shr(f, r)\n\t\t\t}\n\t\t\tassembly {\n\t\t\t\tlet f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n\t\t\t\tmsb := or(msb, f)\n\t\t\t\tr := shr(f, r)\n\t\t\t}\n\t\t\tassembly {\n\t\t\t\tlet f := shl(5, gt(r, 0xFFFFFFFF))\n\t\t\t\tmsb := or(msb, f)\n\t\t\t\tr := shr(f, r)\n\t\t\t}\n\t\t\tassembly {\n\t\t\t\tlet f := shl(4, gt(r, 0xFFFF))\n\t\t\t\tmsb := or(msb, f)\n\t\t\t\tr := shr(f, r)\n\t\t\t}\n\t\t\tassembly {\n\t\t\t\tlet f := shl(3, gt(r, 0xFF))\n\t\t\t\tmsb := or(msb, f)\n\t\t\t\tr := shr(f, r)\n\t\t\t}\n\t\t\tassembly {\n\t\t\t\tlet f := shl(2, gt(r, 0xF))\n\t\t\t\tmsb := or(msb, f)\n\t\t\t\tr := shr(f, r)\n\t\t\t}\n\t\t\tassembly {\n\t\t\t\tlet f := shl(1, gt(r, 0x3))\n\t\t\t\tmsb := or(msb, f)\n\t\t\t\tr := shr(f, r)\n\t\t\t}\n\t\t\tassembly {\n\t\t\t\tlet f := gt(r, 0x1)\n\t\t\t\tmsb := or(msb, f)\n\t\t\t}\n\n\t\t\tif (msb >= 128) r = ratio >> (msb - 127);\n\t\t\telse r = ratio << (127 - msb);\n\n\t\t\tint256 log_2 = (int256(msb) - 128) << 64;\n\n\t\t\tassembly {\n\t\t\t\tr := shr(127, mul(r, r))\n\t\t\t\tlet f := shr(128, r)\n\t\t\t\tlog_2 := or(log_2, shl(63, f))\n\t\t\t\tr := shr(f, r)\n\t\t\t}\n\t\t\tassembly {\n\t\t\t\tr := shr(127, mul(r, r))\n\t\t\t\tlet f := shr(128, r)\n\t\t\t\tlog_2 := or(log_2, shl(62, f))\n\t\t\t\tr := shr(f, r)\n\t\t\t}\n\t\t\tassembly {\n\t\t\t\tr := shr(127, mul(r, r))\n\t\t\t\tlet f := shr(128, r)\n\t\t\t\tlog_2 := or(log_2, shl(61, f))\n\t\t\t\tr := shr(f, r)\n\t\t\t}\n\t\t\tassembly {\n\t\t\t\tr := shr(127, mul(r, r))\n\t\t\t\tlet f := shr(128, r)\n\t\t\t\tlog_2 := or(log_2, shl(60, f))\n\t\t\t\tr := shr(f, r)\n\t\t\t}\n\t\t\tassembly {\n\t\t\t\tr := shr(127, mul(r, r))\n\t\t\t\tlet f := shr(128, r)\n\t\t\t\tlog_2 := or(log_2, shl(59, f))\n\t\t\t\tr := shr(f, r)\n\t\t\t}\n\t\t\tassembly {\n\t\t\t\tr := shr(127, mul(r, r))\n\t\t\t\tlet f := shr(128, r)\n\t\t\t\tlog_2 := or(log_2, shl(58, f))\n\t\t\t\tr := shr(f, r)\n\t\t\t}\n\t\t\tassembly {\n\t\t\t\tr := shr(127, mul(r, r))\n\t\t\t\tlet f := shr(128, r)\n\t\t\t\tlog_2 := or(log_2, shl(57, f))\n\t\t\t\tr := shr(f, r)\n\t\t\t}\n\t\t\tassembly {\n\t\t\t\tr := shr(127, mul(r, r))\n\t\t\t\tlet f := shr(128, r)\n\t\t\t\tlog_2 := or(log_2, shl(56, f))\n\t\t\t\tr := shr(f, r)\n\t\t\t}\n\t\t\tassembly {\n\t\t\t\tr := shr(127, mul(r, r))\n\t\t\t\tlet f := shr(128, r)\n\t\t\t\tlog_2 := or(log_2, shl(55, f))\n\t\t\t\tr := shr(f, r)\n\t\t\t}\n\t\t\tassembly {\n\t\t\t\tr := shr(127, mul(r, r))\n\t\t\t\tlet f := shr(128, r)\n\t\t\t\tlog_2 := or(log_2, shl(54, f))\n\t\t\t\tr := shr(f, r)\n\t\t\t}\n\t\t\tassembly {\n\t\t\t\tr := shr(127, mul(r, r))\n\t\t\t\tlet f := shr(128, r)\n\t\t\t\tlog_2 := or(log_2, shl(53, f))\n\t\t\t\tr := shr(f, r)\n\t\t\t}\n\t\t\tassembly {\n\t\t\t\tr := shr(127, mul(r, r))\n\t\t\t\tlet f := shr(128, r)\n\t\t\t\tlog_2 := or(log_2, shl(52, f))\n\t\t\t\tr := shr(f, r)\n\t\t\t}\n\t\t\tassembly {\n\t\t\t\tr := shr(127, mul(r, r))\n\t\t\t\tlet f := shr(128, r)\n\t\t\t\tlog_2 := or(log_2, shl(51, f))\n\t\t\t\tr := shr(f, r)\n\t\t\t}\n\t\t\tassembly {\n\t\t\t\tr := shr(127, mul(r, r))\n\t\t\t\tlet f := shr(128, r)\n\t\t\t\tlog_2 := or(log_2, shl(50, f))\n\t\t\t}\n\n\t\t\tint256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n\t\t\tint24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n\t\t\tint24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n\t\t\ttick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n\t\t}\n\t}\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/OracleLibrary.sol": {
      "content": "pragma solidity >=0.6.12;\n\nimport \"./math/FullMath.sol\";\nimport \"./math/TickMath.sol\";\nimport \"./IUniswapV3Pool.sol\";\n\n/// @title Oracle library\n/// @notice Provides functions to integrate with V3 pool oracle\nlibrary OracleLibrary {\n\t/// @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool\n\t/// @param pool Address of the pool that we want to observe\n\t/// @param secondsAgo Number of seconds in the past from which to calculate the time-weighted means\n\t/// @return arithmeticMeanTick The arithmetic mean tick from (block.timestamp - secondsAgo) to block.timestamp\n\t/// @return harmonicMeanLiquidity The harmonic mean liquidity from (block.timestamp - secondsAgo) to block.timestamp\n\tfunction consult(\n\t\taddress pool,\n\t\tuint32 secondsAgo\n\t) internal view returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity) {\n\t\trequire(secondsAgo != 0, \"BP\");\n\n\t\tuint32[] memory secondsAgos = new uint32[](2);\n\t\tsecondsAgos[0] = secondsAgo;\n\t\tsecondsAgos[1] = 0;\n\n\t\t(int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) = IUniswapV3Pool(pool)\n\t\t\t.observe(secondsAgos);\n\n\t\tint56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n\t\tuint160 secondsPerLiquidityCumulativesDelta = secondsPerLiquidityCumulativeX128s[1] -\n\t\t\tsecondsPerLiquidityCumulativeX128s[0];\n\n\t\tarithmeticMeanTick = int24(tickCumulativesDelta / int32(secondsAgo));\n\t\t// Always round to negative infinity\n\t\tif (tickCumulativesDelta < 0 && (tickCumulativesDelta % int32(secondsAgo) != 0)) arithmeticMeanTick--;\n\n\t\t// We are multiplying here instead of shifting to ensure that harmonicMeanLiquidity doesn't overflow uint128\n\t\tuint192 secondsAgoX160 = uint192(secondsAgo) * type(uint160).max;\n\t\tharmonicMeanLiquidity = uint128(secondsAgoX160 / (uint192(secondsPerLiquidityCumulativesDelta) << 32));\n\t}\n\n\t/// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n\t/// @param tick Tick value used to calculate the quote\n\t/// @param baseAmount Amount of token to be converted\n\t/// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n\t/// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n\t/// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n\tfunction getQuoteAtTick(\n\t\tint24 tick,\n\t\tuint128 baseAmount,\n\t\taddress baseToken,\n\t\taddress quoteToken\n\t) internal pure returns (uint256 quoteAmount) {\n\t\tuint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n\t\t// Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n\t\tif (sqrtRatioX96 <= type(uint128).max) {\n\t\t\tuint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n\t\t\tquoteAmount = baseToken < quoteToken\n\t\t\t\t? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n\t\t\t\t: FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n\t\t} else {\n\t\t\tuint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n\t\t\tquoteAmount = baseToken < quoteToken\n\t\t\t\t? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n\t\t\t\t: FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n\t\t}\n\t}\n\n\t/// @notice Given a pool, it returns the number of seconds ago of the oldest stored observation\n\t/// @param pool Address of Uniswap V3 pool that we want to observe\n\t/// @return secondsAgo The number of seconds ago of the oldest observation stored for the pool\n\tfunction getOldestObservationSecondsAgo(address pool) internal view returns (uint32 secondsAgo) {\n\t\t(, , uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n\t\trequire(observationCardinality > 0, \"NI\");\n\n\t\t(uint32 observationTimestamp, , , bool initialized) = IUniswapV3Pool(pool).observations(\n\t\t\t(observationIndex + 1) % observationCardinality\n\t\t);\n\n\t\t// The next index might not be initialized if the cardinality is in the process of increasing\n\t\t// In this case the oldest observation is always in index 0\n\t\tif (!initialized) {\n\t\t\t(observationTimestamp, , , ) = IUniswapV3Pool(pool).observations(0);\n\t\t}\n\n\t\tsecondsAgo = uint32(block.timestamp) - observationTimestamp;\n\t}\n\n\t/// @notice Given a pool, it returns the tick value as of the start of the current block\n\t/// @param pool Address of Uniswap V3 pool\n\t/// @return The tick that the pool was in at the start of the current block\n\tfunction getBlockStartingTickAndLiquidity(address pool) internal view returns (int24, uint128) {\n\t\t(, int24 tick, uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n\n\t\t// 2 observations are needed to reliably calculate the block starting tick\n\t\trequire(observationCardinality > 1, \"NEO\");\n\n\t\t// If the latest observation occurred in the past, then no tick-changing trades have happened in this block\n\t\t// therefore the tick in `slot0` is the same as at the beginning of the current block.\n\t\t// We don't need to check if this observation is initialized - it is guaranteed to be.\n\t\t(\n\t\t\tuint32 observationTimestamp,\n\t\t\tint56 tickCumulative,\n\t\t\tuint160 secondsPerLiquidityCumulativeX128,\n\n\t\t) = IUniswapV3Pool(pool).observations(observationIndex);\n\t\tif (observationTimestamp != uint32(block.timestamp)) {\n\t\t\treturn (tick, IUniswapV3Pool(pool).liquidity());\n\t\t}\n\n\t\tuint256 prevIndex = (uint256(observationIndex) + observationCardinality - 1) % observationCardinality;\n\t\t(\n\t\t\tuint32 prevObservationTimestamp,\n\t\t\tint56 prevTickCumulative,\n\t\t\tuint160 prevSecondsPerLiquidityCumulativeX128,\n\t\t\tbool prevInitialized\n\t\t) = IUniswapV3Pool(pool).observations(prevIndex);\n\n\t\trequire(prevInitialized, \"ONI\");\n\n\t\tuint32 delta = observationTimestamp - prevObservationTimestamp;\n\t\ttick = int24((tickCumulative - prevTickCumulative) / int56(int32(delta)));\n\t\tuint128 liquidity = uint128(\n\t\t\t(uint192(delta) * type(uint160).max) /\n\t\t\t\t(uint192(secondsPerLiquidityCumulativeX128 - prevSecondsPerLiquidityCumulativeX128) << 32)\n\t\t);\n\t\treturn (tick, liquidity);\n\t}\n\n\t/// @notice Information for calculating a weighted arithmetic mean tick\n\tstruct WeightedTickData {\n\t\tint24 tick;\n\t\tuint128 weight;\n\t}\n\n\t/// @notice Given an array of ticks and weights, calculates the weighted arithmetic mean tick\n\t/// @param weightedTickData An array of ticks and weights\n\t/// @return weightedArithmeticMeanTick The weighted arithmetic mean tick\n\t/// @dev Each entry of `weightedTickData` should represents ticks from pools with the same underlying pool tokens. If they do not,\n\t/// extreme care must be taken to ensure that ticks are comparable (including decimal differences).\n\t/// @dev Note that the weighted arithmetic mean tick corresponds to the weighted geometric mean price.\n\tfunction getWeightedArithmeticMeanTick(\n\t\tWeightedTickData[] memory weightedTickData\n\t) internal pure returns (int24 weightedArithmeticMeanTick) {\n\t\t// Accumulates the sum of products between each tick and its weight\n\t\tint256 numerator;\n\n\t\t// Accumulates the sum of the weights\n\t\tuint256 denominator;\n\n\t\t// Products fit in 152 bits, so it would take an array of length ~2**104 to overflow this logic\n\t\tfor (uint256 i; i < weightedTickData.length; i++) {\n\t\t\tnumerator += weightedTickData[i].tick * int256(int128(weightedTickData[i].weight));\n\t\t\tdenominator += weightedTickData[i].weight;\n\t\t}\n\n\t\tweightedArithmeticMeanTick = int24(numerator / int256(denominator));\n\t\t// Always round to negative infinity\n\t\tif (numerator < 0 && (numerator % int256(denominator) != 0)) weightedArithmeticMeanTick--;\n\t}\n\n\t/// @notice Returns the \"synthetic\" tick which represents the price of the first entry in `tokens` in terms of the last\n\t/// @dev Useful for calculating relative prices along routes.\n\t/// @dev There must be one tick for each pairwise set of tokens.\n\t/// @param tokens The token contract addresses\n\t/// @param ticks The ticks, representing the price of each token pair in `tokens`\n\t/// @return syntheticTick The synthetic tick, representing the relative price of the outermost tokens in `tokens`\n\tfunction getChainedPrice(\n\t\taddress[] memory tokens,\n\t\tint24[] memory ticks\n\t) internal pure returns (int256 syntheticTick) {\n\t\trequire(tokens.length - 1 == ticks.length, \"DL\");\n\t\tfor (uint256 i = 1; i <= ticks.length; i++) {\n\t\t\t// check the tokens for address sort order, then accumulate the\n\t\t\t// ticks into the running synthetic tick, ensuring that intermediate tokens \"cancel out\"\n\t\t\ttokens[i - 1] < tokens[i] ? syntheticTick += ticks[i - 1] : syntheticTick -= ticks[i - 1];\n\t\t}\n\t}\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/pool/AggregatorV3Interface.sol": {
      "content": "pragma solidity >=0.6.0;\n\ninterface AggregatorV3Interface {\n\tfunction decimals() external view returns (uint8);\n\n\tfunction description() external view returns (string memory);\n\n\tfunction version() external view returns (uint256);\n\n\t// getRoundData and latestRoundData should both raise \"No data present\"\n\t// if they do not have data to report, instead of returning unset values\n\t// which could be misinterpreted as actual reported values.\n\tfunction getRoundData(\n\t\tuint80 _roundId\n\t)\n\t\texternal\n\t\tview\n\t\treturns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n\tfunction latestRoundData()\n\t\texternal\n\t\tview\n\t\treturns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/pool/IUniswapV3PoolActions.sol": {
      "content": "pragma solidity >=0.6.11;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n\t/// @notice Sets the initial price for the pool\n\t/// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n\t/// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n\tfunction initialize(uint160 sqrtPriceX96) external;\n\n\t/// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n\t/// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n\t/// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n\t/// on tickLower, tickUpper, the amount of liquidity, and the current price.\n\t/// @param recipient The address for which the liquidity will be created\n\t/// @param tickLower The lower tick of the position in which to add liquidity\n\t/// @param tickUpper The upper tick of the position in which to add liquidity\n\t/// @param amount The amount of liquidity to mint\n\t/// @param data Any data that should be passed through to the callback\n\t/// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n\t/// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n\tfunction mint(\n\t\taddress recipient,\n\t\tint24 tickLower,\n\t\tint24 tickUpper,\n\t\tuint128 amount,\n\t\tbytes calldata data\n\t) external returns (uint256 amount0, uint256 amount1);\n\n\t/// @notice Collects tokens owed to a position\n\t/// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n\t/// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n\t/// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n\t/// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n\t/// @param recipient The address which should receive the fees collected\n\t/// @param tickLower The lower tick of the position for which to collect fees\n\t/// @param tickUpper The upper tick of the position for which to collect fees\n\t/// @param amount0Requested How much token0 should be withdrawn from the fees owed\n\t/// @param amount1Requested How much token1 should be withdrawn from the fees owed\n\t/// @return amount0 The amount of fees collected in token0\n\t/// @return amount1 The amount of fees collected in token1\n\tfunction collect(\n\t\taddress recipient,\n\t\tint24 tickLower,\n\t\tint24 tickUpper,\n\t\tuint128 amount0Requested,\n\t\tuint128 amount1Requested\n\t) external returns (uint128 amount0, uint128 amount1);\n\n\t/// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n\t/// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n\t/// @dev Fees must be collected separately via a call to #collect\n\t/// @param tickLower The lower tick of the position for which to burn liquidity\n\t/// @param tickUpper The upper tick of the position for which to burn liquidity\n\t/// @param amount How much liquidity to burn\n\t/// @return amount0 The amount of token0 sent to the recipient\n\t/// @return amount1 The amount of token1 sent to the recipient\n\tfunction burn(int24 tickLower, int24 tickUpper, uint128 amount) external returns (uint256 amount0, uint256 amount1);\n\n\t/// @notice Swap token0 for token1, or token1 for token0\n\t/// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n\t/// @param recipient The address to receive the output of the swap\n\t/// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n\t/// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n\t/// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n\t/// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n\t/// @param data Any data to be passed through to the callback\n\t/// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n\t/// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n\tfunction swap(\n\t\taddress recipient,\n\t\tbool zeroForOne,\n\t\tint256 amountSpecified,\n\t\tuint160 sqrtPriceLimitX96,\n\t\tbytes calldata data\n\t) external returns (int256 amount0, int256 amount1);\n\n\t/// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n\t/// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n\t/// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n\t/// with 0 amount{0,1} and sending the donation amount(s) from the callback\n\t/// @param recipient The address which will receive the token0 and token1 amounts\n\t/// @param amount0 The amount of token0 to send\n\t/// @param amount1 The amount of token1 to send\n\t/// @param data Any data to be passed through to the callback\n\tfunction flash(address recipient, uint256 amount0, uint256 amount1, bytes calldata data) external;\n\n\t/// @notice Increase the maximum number of price and liquidity observations that this pool will store\n\t/// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n\t/// the input observationCardinalityNext.\n\t/// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n\tfunction increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "pragma solidity >=0.6.11;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n\t/// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n\t/// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n\t/// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n\t/// you must call it with secondsAgos = [3600, 0].\n\t/// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n\t/// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n\t/// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n\t/// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n\t/// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n\t/// timestamp\n\tfunction observe(\n\t\tuint32[] calldata secondsAgos\n\t) external view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n\t/// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n\t/// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n\t/// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n\t/// snapshot is taken and the second snapshot is taken.\n\t/// @param tickLower The lower tick of the range\n\t/// @param tickUpper The upper tick of the range\n\t/// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n\t/// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n\t/// @return secondsInside The snapshot of seconds per liquidity for the range\n\tfunction snapshotCumulativesInside(\n\t\tint24 tickLower,\n\t\tint24 tickUpper\n\t) external view returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside);\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/pool/IUniswapV3PoolEvents.sol": {
      "content": "pragma solidity >=0.6.11;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n\t/// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n\t/// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n\t/// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n\t/// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n\tevent Initialize(uint160 sqrtPriceX96, int24 tick);\n\n\t/// @notice Emitted when liquidity is minted for a given position\n\t/// @param sender The address that minted the liquidity\n\t/// @param owner The owner of the position and recipient of any minted liquidity\n\t/// @param tickLower The lower tick of the position\n\t/// @param tickUpper The upper tick of the position\n\t/// @param amount The amount of liquidity minted to the position range\n\t/// @param amount0 How much token0 was required for the minted liquidity\n\t/// @param amount1 How much token1 was required for the minted liquidity\n\tevent Mint(\n\t\taddress sender,\n\t\taddress indexed owner,\n\t\tint24 indexed tickLower,\n\t\tint24 indexed tickUpper,\n\t\tuint128 amount,\n\t\tuint256 amount0,\n\t\tuint256 amount1\n\t);\n\n\t/// @notice Emitted when fees are collected by the owner of a position\n\t/// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n\t/// @param owner The owner of the position for which fees are collected\n\t/// @param tickLower The lower tick of the position\n\t/// @param tickUpper The upper tick of the position\n\t/// @param amount0 The amount of token0 fees collected\n\t/// @param amount1 The amount of token1 fees collected\n\tevent Collect(\n\t\taddress indexed owner,\n\t\taddress recipient,\n\t\tint24 indexed tickLower,\n\t\tint24 indexed tickUpper,\n\t\tuint128 amount0,\n\t\tuint128 amount1\n\t);\n\n\t/// @notice Emitted when a position's liquidity is removed\n\t/// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n\t/// @param owner The owner of the position for which liquidity is removed\n\t/// @param tickLower The lower tick of the position\n\t/// @param tickUpper The upper tick of the position\n\t/// @param amount The amount of liquidity to remove\n\t/// @param amount0 The amount of token0 withdrawn\n\t/// @param amount1 The amount of token1 withdrawn\n\tevent Burn(\n\t\taddress indexed owner,\n\t\tint24 indexed tickLower,\n\t\tint24 indexed tickUpper,\n\t\tuint128 amount,\n\t\tuint256 amount0,\n\t\tuint256 amount1\n\t);\n\n\t/// @notice Emitted by the pool for any swaps between token0 and token1\n\t/// @param sender The address that initiated the swap call, and that received the callback\n\t/// @param recipient The address that received the output of the swap\n\t/// @param amount0 The delta of the token0 balance of the pool\n\t/// @param amount1 The delta of the token1 balance of the pool\n\t/// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n\t/// @param liquidity The liquidity of the pool after the swap\n\t/// @param tick The log base 1.0001 of price of the pool after the swap\n\tevent Swap(\n\t\taddress indexed sender,\n\t\taddress indexed recipient,\n\t\tint256 amount0,\n\t\tint256 amount1,\n\t\tuint160 sqrtPriceX96,\n\t\tuint128 liquidity,\n\t\tint24 tick\n\t);\n\n\t/// @notice Emitted by the pool for any flashes of token0/token1\n\t/// @param sender The address that initiated the swap call, and that received the callback\n\t/// @param recipient The address that received the tokens from flash\n\t/// @param amount0 The amount of token0 that was flashed\n\t/// @param amount1 The amount of token1 that was flashed\n\t/// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n\t/// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n\tevent Flash(\n\t\taddress indexed sender,\n\t\taddress indexed recipient,\n\t\tuint256 amount0,\n\t\tuint256 amount1,\n\t\tuint256 paid0,\n\t\tuint256 paid1\n\t);\n\n\t/// @notice Emitted by the pool for increases to the number of observations that can be stored\n\t/// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n\t/// just before a mint/swap/burn.\n\t/// @param observationCardinalityNextOld The previous value of the next observation cardinality\n\t/// @param observationCardinalityNextNew The updated value of the next observation cardinality\n\tevent IncreaseObservationCardinalityNext(\n\t\tuint16 observationCardinalityNextOld,\n\t\tuint16 observationCardinalityNextNew\n\t);\n\n\t/// @notice Emitted when the protocol fee is changed by the pool\n\t/// @param feeProtocol0Old The previous value of the token0 protocol fee\n\t/// @param feeProtocol1Old The previous value of the token1 protocol fee\n\t/// @param feeProtocol0New The updated value of the token0 protocol fee\n\t/// @param feeProtocol1New The updated value of the token1 protocol fee\n\tevent SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n\t/// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n\t/// @param sender The address that collects the protocol fees\n\t/// @param recipient The address that receives the collected protocol fees\n\t/// @param amount0 The amount of token0 protocol fees that is withdrawn\n\t/// @param amount0 The amount of token1 protocol fees that is withdrawn\n\tevent CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/pool/IUniswapV3PoolImmutables.sol": {
      "content": "pragma solidity >=0.6.11;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n\t/// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n\t/// @return The contract address\n\tfunction factory() external view returns (address);\n\n\t/// @notice The first of the two tokens of the pool, sorted by address\n\t/// @return The token contract address\n\tfunction token0() external view returns (address);\n\n\t/// @notice The second of the two tokens of the pool, sorted by address\n\t/// @return The token contract address\n\tfunction token1() external view returns (address);\n\n\t/// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n\t/// @return The fee\n\tfunction fee() external view returns (uint24);\n\n\t/// @notice The pool tick spacing\n\t/// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n\t/// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n\t/// This value is an int24 to avoid casting even though it is always positive.\n\t/// @return The tick spacing\n\tfunction tickSpacing() external view returns (int24);\n\n\t/// @notice The maximum amount of position liquidity that can use any tick in the range\n\t/// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n\t/// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n\t/// @return The max amount of liquidity per tick\n\tfunction maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "pragma solidity >=0.6.11;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n\t/// @notice Set the denominator of the protocol's % share of the fees\n\t/// @param feeProtocol0 new protocol fee for token0 of the pool\n\t/// @param feeProtocol1 new protocol fee for token1 of the pool\n\tfunction setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n\t/// @notice Collect the protocol fee accrued to the pool\n\t/// @param recipient The address to which collected protocol fees should be sent\n\t/// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n\t/// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n\t/// @return amount0 The protocol fee collected in token0\n\t/// @return amount1 The protocol fee collected in token1\n\tfunction collectProtocol(\n\t\taddress recipient,\n\t\tuint128 amount0Requested,\n\t\tuint128 amount1Requested\n\t) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/pool/IUniswapV3PoolState.sol": {
      "content": "pragma solidity >=0.6.11;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n\t/// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n\t/// when accessed externally.\n\t/// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n\t/// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n\t/// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n\t/// boundary.\n\t/// observationIndex The index of the last oracle observation that was written,\n\t/// observationCardinality The current maximum number of observations stored in the pool,\n\t/// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n\t/// feeProtocol The protocol fee for both tokens of the pool.\n\t/// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n\t/// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n\t/// unlocked Whether the pool is currently locked to reentrancy\n\tfunction slot0()\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint160 sqrtPriceX96,\n\t\t\tint24 tick,\n\t\t\tuint16 observationIndex,\n\t\t\tuint16 observationCardinality,\n\t\t\tuint16 observationCardinalityNext,\n\t\t\tuint8 feeProtocol,\n\t\t\tbool unlocked\n\t\t);\n\n\t/// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n\t/// @dev This value can overflow the uint256\n\tfunction feeGrowthGlobal0X128() external view returns (uint256);\n\n\t/// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n\t/// @dev This value can overflow the uint256\n\tfunction feeGrowthGlobal1X128() external view returns (uint256);\n\n\t/// @notice The amounts of token0 and token1 that are owed to the protocol\n\t/// @dev Protocol fees will never exceed uint128 max in either token\n\tfunction protocolFees() external view returns (uint128 token0, uint128 token1);\n\n\t/// @notice The currently in range liquidity available to the pool\n\t/// @dev This value has no relationship to the total liquidity across all ticks\n\tfunction liquidity() external view returns (uint128);\n\n\t/// @notice Look up information about a specific tick in the pool\n\t/// @param tick The tick to look up\n\t/// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n\t/// tick upper,\n\t/// liquidityNet how much liquidity changes when the pool price crosses the tick,\n\t/// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n\t/// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n\t/// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n\t/// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n\t/// secondsOutside the seconds spent on the other side of the tick from the current tick,\n\t/// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n\t/// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n\t/// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n\t/// a specific position.\n\tfunction ticks(\n\t\tint24 tick\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint128 liquidityGross,\n\t\t\tint128 liquidityNet,\n\t\t\tuint256 feeGrowthOutside0X128,\n\t\t\tuint256 feeGrowthOutside1X128,\n\t\t\tint56 tickCumulativeOutside,\n\t\t\tuint160 secondsPerLiquidityOutsideX128,\n\t\t\tuint32 secondsOutside,\n\t\t\tbool initialized\n\t\t);\n\n\t/// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n\tfunction tickBitmap(int16 wordPosition) external view returns (uint256);\n\n\t/// @notice Returns the information about a position by the position's key\n\t/// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n\t/// @return _liquidity The amount of liquidity in the position,\n\t/// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n\t/// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n\t/// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n\t/// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n\tfunction positions(\n\t\tbytes32 key\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint128 _liquidity,\n\t\t\tuint256 feeGrowthInside0LastX128,\n\t\t\tuint256 feeGrowthInside1LastX128,\n\t\t\tuint128 tokensOwed0,\n\t\t\tuint128 tokensOwed1\n\t\t);\n\n\t/// @notice Returns data about a specific observation index\n\t/// @param index The element of the observations array to fetch\n\t/// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n\t/// ago, rather than at a specific index in the array.\n\t/// @return blockTimestamp The timestamp of the observation,\n\t/// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n\t/// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n\t/// Returns initialized whether the observation has been initialized and the values are safe to use\n\tfunction observations(\n\t\tuint256 index\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint32 blockTimestamp,\n\t\t\tint56 tickCumulative,\n\t\t\tuint160 secondsPerLiquidityCumulativeX128,\n\t\t\tbool initialized\n\t\t);\n}\n"
    },
    "contracts/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\ninterface AggregatorInterface {\n\tfunction latestAnswer() external view returns (int256);\n\n\tfunction latestTimestamp() external view returns (uint256);\n\n\tfunction latestRound() external view returns (uint256);\n\n\tfunction getAnswer(uint256 roundId) external view returns (int256);\n\n\tfunction getTimestamp(uint256 roundId) external view returns (uint256);\n\n\tevent AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n\tevent NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "contracts/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\ninterface AggregatorV3Interface {\n\tfunction decimals() external view returns (uint8);\n\n\tfunction description() external view returns (string memory);\n\n\tfunction version() external view returns (uint256);\n\n\t// getRoundData and latestRoundData should both raise \"No data present\"\n\t// if they do not have data to report, instead of returning unset values\n\t// which could be misinterpreted as actual reported values.\n\tfunction getRoundData(\n\t\tuint80 _roundId\n\t)\n\t\texternal\n\t\tview\n\t\treturns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n\tfunction latestRoundData()\n\t\texternal\n\t\tview\n\t\treturns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "contracts/interfaces/balancer/IWeightedPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBasePool is IERC20 {\n\tfunction getSwapFeePercentage() external view returns (uint256);\n\n\tfunction setSwapFeePercentage(uint256 swapFeePercentage) external;\n\n\tfunction setAssetManagerPoolConfig(IERC20 token, IAssetManager.PoolConfig memory poolConfig) external;\n\n\tfunction setPaused(bool paused) external;\n\n\tfunction getVault() external view returns (IVault);\n\n\tfunction getPoolId() external view returns (bytes32);\n\n\tfunction getOwner() external view returns (address);\n}\n\ninterface IWeightedPoolFactory {\n\tfunction create(\n\t\tstring memory name,\n\t\tstring memory symbol,\n\t\tIERC20[] memory tokens,\n\t\tuint256[] memory weights,\n\t\taddress[] memory rateProviders,\n\t\tuint256 swapFeePercentage,\n\t\taddress owner\n\t) external returns (address);\n}\n\ninterface IWeightedPool is IBasePool {\n\tfunction getSwapEnabled() external view returns (bool);\n\n\tfunction getNormalizedWeights() external view returns (uint256[] memory);\n\n\tfunction getGradualWeightUpdateParams()\n\t\texternal\n\t\tview\n\t\treturns (uint256 startTime, uint256 endTime, uint256[] memory endWeights);\n\n\tfunction setSwapEnabled(bool swapEnabled) external;\n\n\tfunction updateWeightsGradually(uint256 startTime, uint256 endTime, uint256[] memory endWeights) external;\n\n\tfunction withdrawCollectedManagementFees(address recipient) external;\n\n\tenum JoinKind {\n\t\tINIT,\n\t\tEXACT_TOKENS_IN_FOR_BPT_OUT,\n\t\tTOKEN_IN_FOR_EXACT_BPT_OUT\n\t}\n\tenum ExitKind {\n\t\tEXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n\t\tEXACT_BPT_IN_FOR_TOKENS_OUT,\n\t\tBPT_IN_FOR_EXACT_TOKENS_OUT\n\t}\n}\n\ninterface IAssetManager {\n\tstruct PoolConfig {\n\t\tuint64 targetPercentage;\n\t\tuint64 criticalPercentage;\n\t\tuint64 feePercentage;\n\t}\n\n\tfunction setPoolConfig(bytes32 poolId, PoolConfig calldata config) external;\n}\n\ninterface IAsset {}\n\ninterface IVault {\n\tfunction hasApprovedRelayer(address user, address relayer) external view returns (bool);\n\n\tfunction setRelayerApproval(address sender, address relayer, bool approved) external;\n\n\tevent RelayerApprovalChanged(address indexed relayer, address indexed sender, bool approved);\n\n\tfunction getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);\n\n\tfunction manageUserBalance(UserBalanceOp[] memory ops) external payable;\n\n\tstruct UserBalanceOp {\n\t\tUserBalanceOpKind kind;\n\t\tIAsset asset;\n\t\tuint256 amount;\n\t\taddress sender;\n\t\taddress payable recipient;\n\t}\n\n\tenum UserBalanceOpKind {\n\t\tDEPOSIT_INTERNAL,\n\t\tWITHDRAW_INTERNAL,\n\t\tTRANSFER_INTERNAL,\n\t\tTRANSFER_EXTERNAL\n\t}\n\tevent InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\n\tevent ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\n\n\tenum PoolSpecialization {\n\t\tGENERAL,\n\t\tMINIMAL_SWAP_INFO,\n\t\tTWO_TOKEN\n\t}\n\n\tfunction registerPool(PoolSpecialization specialization) external returns (bytes32);\n\n\tevent PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\n\n\tfunction getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n\n\tfunction registerTokens(bytes32 poolId, IERC20[] memory tokens, address[] memory assetManagers) external;\n\n\tevent TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\n\n\tfunction deregisterTokens(bytes32 poolId, IERC20[] memory tokens) external;\n\n\tevent TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\n\n\tfunction getPoolTokenInfo(\n\t\tbytes32 poolId,\n\t\tIERC20 token\n\t) external view returns (uint256 cash, uint256 managed, uint256 lastChangeBlock, address assetManager);\n\n\tfunction getPoolTokens(\n\t\tbytes32 poolId\n\t) external view returns (IERC20[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);\n\n\tfunction joinPool(\n\t\tbytes32 poolId,\n\t\taddress sender,\n\t\taddress recipient,\n\t\tJoinPoolRequest memory request\n\t) external payable;\n\n\tstruct JoinPoolRequest {\n\t\tIAsset[] assets;\n\t\tuint256[] maxAmountsIn;\n\t\tbytes userData;\n\t\tbool fromInternalBalance;\n\t}\n\n\tfunction exitPool(\n\t\tbytes32 poolId,\n\t\taddress sender,\n\t\taddress payable recipient,\n\t\tExitPoolRequest memory request\n\t) external;\n\n\tstruct ExitPoolRequest {\n\t\tIAsset[] assets;\n\t\tuint256[] minAmountsOut;\n\t\tbytes userData;\n\t\tbool toInternalBalance;\n\t}\n\n\tevent PoolBalanceChanged(\n\t\tbytes32 indexed poolId,\n\t\taddress indexed liquidityProvider,\n\t\tIERC20[] tokens,\n\t\tint256[] deltas,\n\t\tuint256[] protocolFeeAmounts\n\t);\n\n\tenum PoolBalanceChangeKind {\n\t\tJOIN,\n\t\tEXIT\n\t}\n\n\tenum SwapKind {\n\t\tGIVEN_IN,\n\t\tGIVEN_OUT\n\t}\n\n\tfunction swap(\n\t\tSingleSwap memory singleSwap,\n\t\tFundManagement memory funds,\n\t\tuint256 limit,\n\t\tuint256 deadline\n\t) external payable returns (uint256);\n\n\tstruct SingleSwap {\n\t\tbytes32 poolId;\n\t\tSwapKind kind;\n\t\tIAsset assetIn;\n\t\tIAsset assetOut;\n\t\tuint256 amount;\n\t\tbytes userData;\n\t}\n\n\tfunction batchSwap(\n\t\tSwapKind kind,\n\t\tBatchSwapStep[] memory swaps,\n\t\tIAsset[] memory assets,\n\t\tFundManagement memory funds,\n\t\tint256[] memory limits,\n\t\tuint256 deadline\n\t) external payable returns (int256[] memory);\n\n\tstruct BatchSwapStep {\n\t\tbytes32 poolId;\n\t\tuint256 assetInIndex;\n\t\tuint256 assetOutIndex;\n\t\tuint256 amount;\n\t\tbytes userData;\n\t}\n\n\tevent Swap(\n\t\tbytes32 indexed poolId,\n\t\tIERC20 indexed tokenIn,\n\t\tIERC20 indexed tokenOut,\n\t\tuint256 amountIn,\n\t\tuint256 amountOut\n\t);\n\tstruct FundManagement {\n\t\taddress sender;\n\t\tbool fromInternalBalance;\n\t\taddress payable recipient;\n\t\tbool toInternalBalance;\n\t}\n\n\tfunction queryBatchSwap(\n\t\tSwapKind kind,\n\t\tBatchSwapStep[] memory swaps,\n\t\tIAsset[] memory assets,\n\t\tFundManagement memory funds\n\t) external returns (int256[] memory assetDeltas);\n\n\tfunction managePoolBalance(PoolBalanceOp[] memory ops) external;\n\n\tstruct PoolBalanceOp {\n\t\tPoolBalanceOpKind kind;\n\t\tbytes32 poolId;\n\t\tIERC20 token;\n\t\tuint256 amount;\n\t}\n\n\tenum PoolBalanceOpKind {\n\t\tWITHDRAW,\n\t\tDEPOSIT,\n\t\tUPDATE\n\t}\n\tevent PoolBalanceManaged(\n\t\tbytes32 indexed poolId,\n\t\taddress indexed assetManager,\n\t\tIERC20 indexed token,\n\t\tint256 cashDelta,\n\t\tint256 managedDelta\n\t);\n\n\tfunction setPaused(bool paused) external;\n}\n\ninterface IBalancerQueries {\n    function querySwap(IVault.SingleSwap memory singleSwap, IVault.FundManagement memory funds)\n        external\n        returns (uint256);\n\n    function queryBatchSwap(\n        IVault.SwapKind kind,\n        IVault.BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        IVault.FundManagement memory funds\n    ) external returns (int256[] memory assetDeltas);\n\n    function queryJoin(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        IVault.JoinPoolRequest memory request\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn);\n\n    function queryExit(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        IVault.ExitPoolRequest memory request\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut);\n}\n"
    },
    "contracts/interfaces/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\ninterface IAaveIncentivesController {\n\tevent RewardsAccrued(address indexed user, uint256 amount);\n\n\tevent RewardsClaimed(address indexed user, address indexed to, uint256 amount);\n\n\tevent RewardsClaimed(address indexed user, address indexed to, address indexed claimer, uint256 amount);\n\n\tevent ClaimerSet(address indexed user, address indexed claimer);\n\n\t/*\n\t * @dev Returns the configuration of the distribution for a certain asset\n\t * @param asset The address of the reference asset of the distribution\n\t * @return The asset index, the emission per second and the last updated timestamp\n\t **/\n\tfunction getAssetData(address asset) external view returns (uint256, uint256, uint256);\n\n\t/**\n\t * @dev Whitelists an address to claim the rewards on behalf of another address\n\t * @param user The address of the user\n\t * @param claimer The address of the claimer\n\t */\n\tfunction setClaimer(address user, address claimer) external;\n\n\t/**\n\t * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\n\t * @param user The address of the user\n\t * @return The claimer address\n\t */\n\tfunction getClaimer(address user) external view returns (address);\n\n\t/**\n\t * @dev Configure assets for a certain rewards emission\n\t * @param assets The assets to incentivize\n\t * @param emissionsPerSecond The emission for each asset\n\t */\n\tfunction configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond) external;\n\n\t/**\n\t * @dev Called by the corresponding asset on any update that affects the rewards distribution\n\t * @param user The address of the user\n\t **/\n\tfunction handleActionBefore(address user) external;\n\n\t/**\n\t * @dev Called by the corresponding asset on any update that affects the rewards distribution\n\t * @param user The address of the user\n\t * @param userBalance The balance of the user of the asset in the lending pool\n\t * @param totalSupply The total supply of the asset in the lending pool\n\t **/\n\tfunction handleActionAfter(address user, uint256 userBalance, uint256 totalSupply) external;\n\n\t/**\n\t * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n\t * @param user The address of the user\n\t * @return The rewards\n\t **/\n\tfunction getRewardsBalance(address[] calldata assets, address user) external view returns (uint256);\n\n\t/**\n\t * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\n\t * @param amount Amount of rewards to claim\n\t * @param to Address that will be receiving the rewards\n\t * @return Rewards claimed\n\t **/\n\tfunction claimRewards(address[] calldata assets, uint256 amount, address to) external returns (uint256);\n\n\t/**\n\t * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\n\t * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n\t * @param amount Amount of rewards to claim\n\t * @param user Address to check and claim rewards\n\t * @param to Address that will be receiving the rewards\n\t * @return Rewards claimed\n\t **/\n\tfunction claimRewardsOnBehalf(\n\t\taddress[] calldata assets,\n\t\tuint256 amount,\n\t\taddress user,\n\t\taddress to\n\t) external returns (uint256);\n\n\t/**\n\t * @dev returns the unclaimed rewards of the user\n\t * @param user the address of the user\n\t * @return the unclaimed user rewards\n\t */\n\tfunction getUserUnclaimedRewards(address user) external view returns (uint256);\n\n\t/**\n\t * @dev returns the unclaimed rewards of the user\n\t * @param user the address of the user\n\t * @param asset The asset to incentivize\n\t * @return the user index for the asset\n\t */\n\tfunction getUserAssetData(address user, address asset) external view returns (uint256);\n\n\t/**\n\t * @dev for backward compatibility with previous implementation of the Incentives controller\n\t */\n\tfunction REWARD_TOKEN() external view returns (address);\n\n\t/**\n\t * @dev for backward compatibility with previous implementation of the Incentives controller\n\t */\n\tfunction PRECISION() external view returns (uint8);\n\n\t/**\n\t * @dev Gets the distribution end timestamp of the emissions\n\t */\n\tfunction DISTRIBUTION_END() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IAaveOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title IAaveOracle interface\n * @notice Interface for the Aave oracle.\n **/\n\ninterface IAaveOracle {\n\tfunction BASE_CURRENCY() external view returns (address); // if usd returns 0x0, if eth returns weth address\n\n\tfunction BASE_CURRENCY_UNIT() external view returns (uint256);\n\n\t/***********\n    @dev returns the asset price in ETH\n     */\n\tfunction getAssetPrice(address asset) external view returns (uint256);\n\n\tfunction getSourceOfAsset(address asset) external view returns (address);\n}\n"
    },
    "contracts/interfaces/IAaveProtocolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\ninterface IAaveProtocolDataProvider {\n\tstruct TokenData {\n\t\tstring symbol;\n\t\taddress tokenAddress;\n\t}\n\n\tfunction getAllReservesTokens() external view returns (TokenData[] memory);\n\n\tfunction getAllATokens() external view returns (TokenData[] memory);\n\n\tfunction getReserveConfigurationData(\n\t\taddress asset\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 decimals,\n\t\t\tuint256 ltv,\n\t\t\tuint256 liquidationThreshold,\n\t\t\tuint256 liquidationBonus,\n\t\t\tuint256 reserveFactor,\n\t\t\tbool usageAsCollateralEnabled,\n\t\t\tbool borrowingEnabled,\n\t\t\tbool stableBorrowRateEnabled,\n\t\t\tbool isActive,\n\t\t\tbool isFrozen\n\t\t);\n\n\tfunction getReserveData(\n\t\taddress asset\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 availableLiquidity,\n\t\t\tuint256 totalStableDebt,\n\t\t\tuint256 totalVariableDebt,\n\t\t\tuint256 liquidityRate,\n\t\t\tuint256 variableBorrowRate,\n\t\t\tuint256 stableBorrowRate,\n\t\t\tuint256 averageStableBorrowRate,\n\t\t\tuint256 liquidityIndex,\n\t\t\tuint256 variableBorrowIndex,\n\t\t\tuint40 lastUpdateTimestamp\n\t\t);\n\n\tfunction getUserReserveData(\n\t\taddress asset,\n\t\taddress user\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 currentATokenBalance,\n\t\t\tuint256 currentStableDebt,\n\t\t\tuint256 currentVariableDebt,\n\t\t\tuint256 principalStableDebt,\n\t\t\tuint256 scaledVariableDebt,\n\t\t\tuint256 stableBorrowRate,\n\t\t\tuint256 liquidityRate,\n\t\t\tuint40 stableRateLastUpdated,\n\t\t\tbool usageAsCollateralEnabled\n\t\t);\n\n\tfunction getReserveTokensAddresses(\n\t\taddress asset\n\t) external view returns (address aTokenAddress, address stableDebtTokenAddress, address variableDebtTokenAddress);\n}\n"
    },
    "contracts/interfaces/IArbitrumSequencerUptimeFeed.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface IArbitrumSequencerUptimeFeed {\n\tfunction aliasedL1MessageSender() external view returns (address);\n\n\tfunction updateStatus(bool status, uint64 timestamp) external;\n}\n"
    },
    "contracts/interfaces/IAToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IScaledBalanceToken} from \"./IScaledBalanceToken.sol\";\nimport {IInitializableAToken} from \"./IInitializableAToken.sol\";\nimport {IAaveIncentivesController} from \"./IAaveIncentivesController.sol\";\n\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\n\t/**\n\t * @dev Emitted after the mint action\n\t * @param from The address performing the mint\n\t * @param value The amount being\n\t * @param index The new liquidity index of the reserve\n\t **/\n\tevent Mint(address indexed from, uint256 value, uint256 index);\n\n\t/**\n\t * @dev Mints `amount` aTokens to `user`\n\t * @param user The address receiving the minted tokens\n\t * @param amount The amount of tokens getting minted\n\t * @param index The new liquidity index of the reserve\n\t * @return `true` if the the previous balance of the user was 0\n\t */\n\tfunction mint(address user, uint256 amount, uint256 index) external returns (bool);\n\n\t/**\n\t * @dev Emitted after aTokens are burned\n\t * @param from The owner of the aTokens, getting them burned\n\t * @param target The address that will receive the underlying\n\t * @param value The amount being burned\n\t * @param index The new liquidity index of the reserve\n\t **/\n\tevent Burn(address indexed from, address indexed target, uint256 value, uint256 index);\n\n\t/**\n\t * @dev Emitted during the transfer action\n\t * @param from The user whose tokens are being transferred\n\t * @param to The recipient\n\t * @param value The amount being transferred\n\t * @param index The new liquidity index of the reserve\n\t **/\n\tevent BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\n\n\t/**\n\t * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n\t * @param user The owner of the aTokens, getting them burned\n\t * @param receiverOfUnderlying The address that will receive the underlying\n\t * @param amount The amount being burned\n\t * @param index The new liquidity index of the reserve\n\t **/\n\tfunction burn(address user, address receiverOfUnderlying, uint256 amount, uint256 index) external;\n\n\t/**\n\t * @dev Mints aTokens to the reserve treasury\n\t * @param amount The amount of tokens getting minted\n\t * @param index The new liquidity index of the reserve\n\t */\n\tfunction mintToTreasury(uint256 amount, uint256 index) external;\n\n\t/**\n\t * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n\t * @param from The address getting liquidated, current owner of the aTokens\n\t * @param to The recipient\n\t * @param value The amount of tokens getting transferred\n\t **/\n\tfunction transferOnLiquidation(address from, address to, uint256 value) external;\n\n\t/**\n\t * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\n\t * assets in borrow(), withdraw() and flashLoan()\n\t * @param user The recipient of the underlying\n\t * @param amount The amount getting transferred\n\t * @return The amount transferred\n\t **/\n\tfunction transferUnderlyingTo(address user, uint256 amount) external returns (uint256);\n\n\t/**\n\t * @dev Invoked to execute actions on the aToken side after a repayment.\n\t * @param user The user executing the repayment\n\t * @param amount The amount getting repaid\n\t **/\n\tfunction handleRepayment(address user, uint256 amount) external;\n\n\t/**\n\t * @dev Returns the address of the incentives controller contract\n\t **/\n\tfunction getIncentivesController() external view returns (IAaveIncentivesController);\n\n\t/**\n\t * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n\t **/\n\tfunction UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IBaseOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ninterface IBaseOracle {\n\tfunction latestAnswer() external view returns (uint256 price);\n\n\tfunction latestAnswerInEth() external view returns (uint256 price);\n\n\tfunction update() external;\n\n\tfunction canUpdate() external view returns (bool);\n\n\tfunction consult() external view returns (uint256 price);\n}\n"
    },
    "contracts/interfaces/IBountyManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ninterface IBountyManager {\n\tfunction quote(address _param) external returns (uint256 bounty);\n\n\tfunction claim(address _param) external returns (uint256 bounty);\n\n\tfunction minDLPBalance() external view returns (uint256 amt);\n\n\tfunction executeBounty(\n\t\taddress _user,\n\t\tbool _execute,\n\t\tuint256 _actionType\n\t) external returns (uint256 bounty, uint256 actionType);\n}\n"
    },
    "contracts/interfaces/IChainlinkAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\ninterface IChainlinkAdapter {\n\tfunction latestAnswer() external view returns (uint256 price);\n}\n"
    },
    "contracts/interfaces/IChainlinkAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Code from https://github.com/smartcontractkit/chainlink/blob/master/evm-contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\n\npragma solidity 0.8.12;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface IChainlinkAggregator is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "contracts/interfaces/IChefIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\ninterface IChefIncentivesController {\n\t/**\n\t * @dev Called by the corresponding asset on any update that affects the rewards distribution\n\t * @param user The address of the user\n\t **/\n\tfunction handleActionBefore(address user) external;\n\n\t/**\n\t * @dev Called by the corresponding asset on any update that affects the rewards distribution\n\t * @param user The address of the user\n\t * @param userBalance The balance of the user of the asset in the lending pool\n\t * @param totalSupply The total supply of the asset in the lending pool\n\t **/\n\tfunction handleActionAfter(address user, uint256 userBalance, uint256 totalSupply) external;\n\n\t/**\n\t * @dev Called by the locking contracts after locking or unlocking happens\n\t * @param user The address of the user\n\t **/\n\tfunction beforeLockUpdate(address user) external;\n\n\t/**\n\t * @notice Hook for lock update.\n\t * @dev Called by the locking contracts after locking or unlocking happens\n\t */\n\tfunction afterLockUpdate(address _user) external;\n\n\tfunction addPool(address _token, uint256 _allocPoint) external;\n\n\tfunction claim(address _user, address[] calldata _tokens) external;\n\n\tfunction setClaimReceiver(address _user, address _receiver) external;\n\n\tfunction getRegisteredTokens() external view returns (address[] memory);\n\n\tfunction disqualifyUser(address _user, address _hunter) external returns (uint256 bounty);\n\n\tfunction bountyForUser(address _user) external view returns (uint256 bounty);\n\n\tfunction allPendingRewards(address _user) external view returns (uint256 pending);\n\n\tfunction claimAll(address _user) external;\n\n\tfunction claimBounty(address _user, bool _execute) external returns (bool issueBaseBounty);\n\n\tfunction setEligibilityExempt(address _address, bool _value) external;\n}\n"
    },
    "contracts/interfaces/ICompounder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\ninterface ICompounder {\n\tfunction claimCompound(address _user, bool _execute, uint256 _slippage) external returns (uint256 tokensOut);\n\n\tfunction viewPendingRewards(address user) external view returns (address[] memory tokens, uint256[] memory amts);\n\n\tfunction estimateReturns(address _in, address _out, uint256 amtIn) external view returns (uint256 amtOut);\n}\n"
    },
    "contracts/interfaces/ICreditDelegationToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface ICreditDelegationToken {\n\tevent BorrowAllowanceDelegated(address indexed fromUser, address indexed toUser, address asset, uint256 amount);\n\n\t/**\n\t * @dev delegates borrowing power to a user on the specific debt token\n\t * @param delegatee the address receiving the delegated borrowing power\n\t * @param amount the maximum amount being delegated. Delegation will still\n\t * respect the liquidation constraints (even if delegated, a delegatee cannot\n\t * force a delegator HF to go below 1)\n\t **/\n\tfunction approveDelegation(address delegatee, uint256 amount) external;\n\n\t/**\n\t * @dev returns the borrow allowance of the user\n\t * @param fromUser The user to giving allowance\n\t * @param toUser The user to give allowance to\n\t * @return the current allowance of toUser\n\t **/\n\tfunction borrowAllowance(address fromUser, address toUser) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IDelegationToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title IDelegationToken\n * @dev Implements an interface for tokens with delegation COMP/UNI compatible\n * @author Aave\n **/\ninterface IDelegationToken {\n\tfunction delegate(address delegatee) external;\n}\n"
    },
    "contracts/interfaces/IEligibilityDataProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\ninterface IEligibilityDataProvider {\n\tfunction refresh(address user) external returns (bool currentEligibility);\n\n\tfunction updatePrice() external;\n\n\tfunction requiredEthValue(address user) external view returns (uint256 required);\n\n\tfunction isEligibleForRewards(address _user) external view returns (bool isEligible);\n\n\tfunction lastEligibleTime(address user) external view returns (uint256 lastEligibleTimestamp);\n\n\tfunction lockedUsdValue(address user) external view returns (uint256);\n\n\tfunction requiredUsdValue(address user) external view returns (uint256 required);\n\n\tfunction lastEligibleStatus(address user) external view returns (bool);\n\n\tfunction rewardEligibleAmount(address token) external view returns (uint256);\n\n\tfunction setDqTime(address _user, uint256 _time) external;\n\n\tfunction getDqTime(address _user) external view returns (uint256);\n\n\tfunction autoprune() external returns (uint256 processed);\n\n\tfunction requiredDepositRatio() external view returns (uint256);\n\n\tfunction RATIO_DIVISOR() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IERC20DetailedBytes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC20DetailedBytes is IERC20 {\n\tfunction name() external view returns (bytes32);\n\n\tfunction symbol() external view returns (bytes32);\n\n\tfunction decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IExchangeAdapter.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IExchangeAdapter {\n\tevent Exchange(\n\t\taddress indexed from,\n\t\taddress indexed to,\n\t\taddress indexed platform,\n\t\tuint256 fromAmount,\n\t\tuint256 toAmount\n\t);\n\n\tfunction approveExchange(IERC20[] calldata tokens) external;\n\n\tfunction exchange(address from, address to, uint256 amount, uint256 maxSlippage) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"./LockedBalance.sol\";\n\ninterface IFeeDistribution {\n\tstruct RewardData {\n\t\taddress token;\n\t\tuint256 amount;\n\t}\n\n\tfunction addReward(address rewardsToken) external;\n\n\tfunction removeReward(address _rewardToken) external;\n}\n"
    },
    "contracts/interfaces/IIncentivizedERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IScaledBalanceToken} from \"./IScaledBalanceToken.sol\";\nimport {IInitializableAToken} from \"./IInitializableAToken.sol\";\nimport {IAaveIncentivesController} from \"./IAaveIncentivesController.sol\";\n\ninterface IIncentivizedERC20 {\n\tfunction getAssetPrice() external view returns (uint256);\n\n\tfunction decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IInitializableAToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {ILendingPool} from \"./ILendingPool.sol\";\nimport {IAaveIncentivesController} from \"./IAaveIncentivesController.sol\";\n\n/**\n * @title IInitializableAToken\n * @notice Interface for the initialize function on AToken\n * @author Aave\n **/\ninterface IInitializableAToken {\n\t/**\n\t * @dev Emitted when an aToken is initialized\n\t * @param underlyingAsset The address of the underlying asset\n\t * @param pool The address of the associated lending pool\n\t * @param treasury The address of the treasury\n\t * @param incentivesController The address of the incentives controller for this aToken\n\t * @param aTokenDecimals the decimals of the underlying\n\t * @param aTokenName the name of the aToken\n\t * @param aTokenSymbol the symbol of the aToken\n\t * @param params A set of encoded parameters for additional initialization\n\t **/\n\tevent Initialized(\n\t\taddress indexed underlyingAsset,\n\t\taddress indexed pool,\n\t\taddress treasury,\n\t\taddress incentivesController,\n\t\tuint8 aTokenDecimals,\n\t\tstring aTokenName,\n\t\tstring aTokenSymbol,\n\t\tbytes params\n\t);\n\n\t/**\n\t * @dev Initializes the aToken\n\t * @param pool The address of the lending pool where this aToken will be used\n\t * @param treasury The address of the Aave treasury, receiving the fees on this aToken\n\t * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n\t * @param incentivesController The smart contract managing potential incentives distribution\n\t * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\n\t * @param aTokenName The name of the aToken\n\t * @param aTokenSymbol The symbol of the aToken\n\t */\n\tfunction initialize(\n\t\tILendingPool pool,\n\t\taddress treasury,\n\t\taddress underlyingAsset,\n\t\tIAaveIncentivesController incentivesController,\n\t\tuint8 aTokenDecimals,\n\t\tstring calldata aTokenName,\n\t\tstring calldata aTokenSymbol,\n\t\tbytes calldata params\n\t) external;\n}\n"
    },
    "contracts/interfaces/IInitializableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {ILendingPool} from \"./ILendingPool.sol\";\nimport {IAaveIncentivesController} from \"./IAaveIncentivesController.sol\";\n\n/**\n * @title IInitializableDebtToken\n * @notice Interface for the initialize function common between debt tokens\n * @author Aave\n **/\ninterface IInitializableDebtToken {\n\t/**\n\t * @dev Emitted when a debt token is initialized\n\t * @param underlyingAsset The address of the underlying asset\n\t * @param pool The address of the associated lending pool\n\t * @param incentivesController The address of the incentives controller for this aToken\n\t * @param debtTokenDecimals the decimals of the debt token\n\t * @param debtTokenName the name of the debt token\n\t * @param debtTokenSymbol the symbol of the debt token\n\t * @param params A set of encoded parameters for additional initialization\n\t **/\n\tevent Initialized(\n\t\taddress indexed underlyingAsset,\n\t\taddress indexed pool,\n\t\taddress incentivesController,\n\t\tuint8 debtTokenDecimals,\n\t\tstring debtTokenName,\n\t\tstring debtTokenSymbol,\n\t\tbytes params\n\t);\n\n\t/**\n\t * @dev Initializes the debt token.\n\t * @param pool The address of the lending pool where this aToken will be used\n\t * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n\t * @param incentivesController The smart contract managing potential incentives distribution\n\t * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's\n\t * @param debtTokenName The name of the token\n\t * @param debtTokenSymbol The symbol of the token\n\t */\n\tfunction initialize(\n\t\tILendingPool pool,\n\t\taddress underlyingAsset,\n\t\tIAaveIncentivesController incentivesController,\n\t\tuint8 debtTokenDecimals,\n\t\tstring memory debtTokenName,\n\t\tstring memory debtTokenSymbol,\n\t\tbytes calldata params\n\t) external;\n}\n"
    },
    "contracts/interfaces/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPoolAddressesProvider} from \"./ILendingPoolAddressesProvider.sol\";\nimport {DataTypes} from \"../lending/libraries/types/DataTypes.sol\";\n\ninterface ILendingPool {\n\t/**\n\t * @dev Emitted on deposit()\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param user The address initiating the deposit\n\t * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n\t * @param amount The amount deposited\n\t * @param referral The referral code used\n\t **/\n\tevent Deposit(\n\t\taddress indexed reserve,\n\t\taddress user,\n\t\taddress indexed onBehalfOf,\n\t\tuint256 amount,\n\t\tuint16 indexed referral\n\t);\n\n\t/**\n\t * @dev Emitted on withdraw()\n\t * @param reserve The address of the underlyng asset being withdrawn\n\t * @param user The address initiating the withdrawal, owner of aTokens\n\t * @param to Address that will receive the underlying\n\t * @param amount The amount to be withdrawn\n\t **/\n\tevent Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n\t/**\n\t * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n\t * @param reserve The address of the underlying asset being borrowed\n\t * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n\t * initiator of the transaction on flashLoan()\n\t * @param onBehalfOf The address that will be getting the debt\n\t * @param amount The amount borrowed out\n\t * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n\t * @param borrowRate The numeric rate at which the user has borrowed\n\t * @param referral The referral code used\n\t **/\n\tevent Borrow(\n\t\taddress indexed reserve,\n\t\taddress user,\n\t\taddress indexed onBehalfOf,\n\t\tuint256 amount,\n\t\tuint256 borrowRateMode,\n\t\tuint256 borrowRate,\n\t\tuint16 indexed referral\n\t);\n\n\t/**\n\t * @dev Emitted on repay()\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param user The beneficiary of the repayment, getting his debt reduced\n\t * @param repayer The address of the user initiating the repay(), providing the funds\n\t * @param amount The amount repaid\n\t **/\n\tevent Repay(address indexed reserve, address indexed user, address indexed repayer, uint256 amount);\n\n\t/**\n\t * @dev Emitted on swapBorrowRateMode()\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param user The address of the user swapping his rate mode\n\t * @param rateMode The rate mode that the user wants to swap to\n\t **/\n\tevent Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n\t/**\n\t * @dev Emitted on setUserUseReserveAsCollateral()\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param user The address of the user enabling the usage as collateral\n\t **/\n\tevent ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n\t/**\n\t * @dev Emitted on setUserUseReserveAsCollateral()\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param user The address of the user enabling the usage as collateral\n\t **/\n\tevent ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n\t/**\n\t * @dev Emitted on rebalanceStableBorrowRate()\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param user The address of the user for which the rebalance has been executed\n\t **/\n\tevent RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n\t/**\n\t * @dev Emitted on flashLoan()\n\t * @param target The address of the flash loan receiver contract\n\t * @param initiator The address initiating the flash loan\n\t * @param asset The address of the asset being flash borrowed\n\t * @param amount The amount flash borrowed\n\t * @param premium The fee flash borrowed\n\t * @param referralCode The referral code used\n\t **/\n\tevent FlashLoan(\n\t\taddress indexed target,\n\t\taddress indexed initiator,\n\t\taddress indexed asset,\n\t\tuint256 amount,\n\t\tuint256 premium,\n\t\tuint16 referralCode\n\t);\n\n\t/**\n\t * @dev Emitted when the pause is triggered.\n\t */\n\tevent Paused();\n\n\t/**\n\t * @dev Emitted when the pause is lifted.\n\t */\n\tevent Unpaused();\n\n\t/**\n\t * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n\t * LendingPoolCollateral manager using a DELEGATECALL\n\t * This allows to have the events in the generated ABI for LendingPool.\n\t * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n\t * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n\t * @param user The address of the borrower getting liquidated\n\t * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n\t * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n\t * @param liquidator The address of the liquidator\n\t * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n\t * to receive the underlying collateral asset directly\n\t **/\n\tevent LiquidationCall(\n\t\taddress indexed collateralAsset,\n\t\taddress indexed debtAsset,\n\t\taddress indexed user,\n\t\tuint256 debtToCover,\n\t\tuint256 liquidatedCollateralAmount,\n\t\taddress liquidator,\n\t\tbool receiveAToken\n\t);\n\n\t/**\n\t * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n\t * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n\t * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n\t * gets added to the LendingPool ABI\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param liquidityRate The new liquidity rate\n\t * @param stableBorrowRate The new stable borrow rate\n\t * @param variableBorrowRate The new variable borrow rate\n\t * @param liquidityIndex The new liquidity index\n\t * @param variableBorrowIndex The new variable borrow index\n\t **/\n\tevent ReserveDataUpdated(\n\t\taddress indexed reserve,\n\t\tuint256 liquidityRate,\n\t\tuint256 stableBorrowRate,\n\t\tuint256 variableBorrowRate,\n\t\tuint256 liquidityIndex,\n\t\tuint256 variableBorrowIndex\n\t);\n\n\tfunction initialize(ILendingPoolAddressesProvider provider) external;\n\n\t/**\n\t * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n\t * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n\t * @param asset The address of the underlying asset to deposit\n\t * @param amount The amount to be deposited\n\t * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n\t *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n\t *   is a different wallet\n\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n\t *   0 if the action is executed directly by the user, without any middle-man\n\t **/\n\tfunction deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n\tfunction depositWithAutoDLP(\n\t\taddress asset,\n\t\tuint256 amount,\n\t\taddress onBehalfOf,\n\t\tuint16 referralCode\n\t) external;\n\n\t/**\n\t * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n\t * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n\t * @param asset The address of the underlying asset to withdraw\n\t * @param amount The underlying amount to be withdrawn\n\t *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n\t * @param to Address that will receive the underlying, same as msg.sender if the user\n\t *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n\t *   different wallet\n\t * @return The final amount withdrawn\n\t **/\n\tfunction withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n\t/**\n\t * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n\t * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n\t * corresponding debt token (StableDebtToken or VariableDebtToken)\n\t * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n\t *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n\t * @param asset The address of the underlying asset to borrow\n\t * @param amount The amount to be borrowed\n\t * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n\t *   0 if the action is executed directly by the user, without any middle-man\n\t * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n\t * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n\t * if he has been given credit delegation allowance\n\t **/\n\tfunction borrow(\n\t\taddress asset,\n\t\tuint256 amount,\n\t\tuint256 interestRateMode,\n\t\tuint16 referralCode,\n\t\taddress onBehalfOf\n\t) external;\n\n\t/**\n\t * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n\t * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n\t * @param asset The address of the borrowed underlying asset previously borrowed\n\t * @param amount The amount to repay\n\t * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n\t * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n\t * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n\t * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n\t * other borrower whose debt should be removed\n\t * @return The final amount repaid\n\t **/\n\tfunction repay(address asset, uint256 amount, uint256 rateMode, address onBehalfOf) external returns (uint256);\n\n\t/**\n\t * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n\t * @param asset The address of the underlying asset borrowed\n\t * @param rateMode The rate mode that the user wants to swap to\n\t **/\n\tfunction swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n\t/**\n\t * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n\t * - Users can be rebalanced if the following conditions are satisfied:\n\t *     1. Usage ratio is above 95%\n\t *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n\t *        borrowed at a stable rate and depositors are not earning enough\n\t * @param asset The address of the underlying asset borrowed\n\t * @param user The address of the user to be rebalanced\n\t **/\n\tfunction rebalanceStableBorrowRate(address asset, address user) external;\n\n\t/**\n\t * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n\t * @param asset The address of the underlying asset deposited\n\t * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n\t **/\n\tfunction setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n\t/**\n\t * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n\t * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n\t *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n\t * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n\t * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n\t * @param user The address of the borrower getting liquidated\n\t * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n\t * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n\t * to receive the underlying collateral asset directly\n\t **/\n\tfunction liquidationCall(\n\t\taddress collateralAsset,\n\t\taddress debtAsset,\n\t\taddress user,\n\t\tuint256 debtToCover,\n\t\tbool receiveAToken\n\t) external;\n\n\t/**\n\t * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n\t * as long as the amount taken plus a fee is returned.\n\t * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n\t * For further details please visit https://developers.aave.com\n\t * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n\t * @param assets The addresses of the assets being flash-borrowed\n\t * @param amounts The amounts amounts being flash-borrowed\n\t * @param modes Types of the debt to open if the flash loan is not returned:\n\t *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n\t *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n\t *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n\t * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n\t * @param params Variadic packed params to pass to the receiver as extra information\n\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n\t *   0 if the action is executed directly by the user, without any middle-man\n\t **/\n\tfunction flashLoan(\n\t\taddress receiverAddress,\n\t\taddress[] calldata assets,\n\t\tuint256[] calldata amounts,\n\t\tuint256[] calldata modes,\n\t\taddress onBehalfOf,\n\t\tbytes calldata params,\n\t\tuint16 referralCode\n\t) external;\n\n\t/**\n\t * @dev Returns the user account data across all the reserves\n\t * @param user The address of the user\n\t * @return totalCollateralETH the total collateral in ETH of the user\n\t * @return totalDebtETH the total debt in ETH of the user\n\t * @return availableBorrowsETH the borrowing power left of the user\n\t * @return currentLiquidationThreshold the liquidation threshold of the user\n\t * @return ltv the loan to value of the user\n\t * @return healthFactor the current health factor of the user\n\t **/\n\tfunction getUserAccountData(\n\t\taddress user\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 totalCollateralETH,\n\t\t\tuint256 totalDebtETH,\n\t\t\tuint256 availableBorrowsETH,\n\t\t\tuint256 currentLiquidationThreshold,\n\t\t\tuint256 ltv,\n\t\t\tuint256 healthFactor\n\t\t);\n\n\tfunction initReserve(\n\t\taddress reserve,\n\t\taddress aTokenAddress,\n\t\taddress stableDebtAddress,\n\t\taddress variableDebtAddress,\n\t\taddress interestRateStrategyAddress\n\t) external;\n\n\tfunction setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;\n\n\tfunction setConfiguration(address reserve, uint256 configuration) external;\n\n\t/**\n\t * @dev Returns the configuration of the reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The configuration of the reserve\n\t **/\n\tfunction getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n\t/**\n\t * @dev Returns the configuration of the user across all the reserves\n\t * @param user The user address\n\t * @return The configuration of the user\n\t **/\n\tfunction getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\n\n\t/**\n\t * @dev Returns the normalized income normalized income of the reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The reserve's normalized income\n\t */\n\tfunction getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n\t/**\n\t * @dev Returns the normalized variable debt per unit of asset\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The reserve normalized variable debt\n\t */\n\tfunction getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n\t/**\n\t * @dev Returns the state and configuration of the reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The state of the reserve\n\t **/\n\tfunction getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n\tfunction finalizeTransfer(\n\t\taddress asset,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount,\n\t\tuint256 balanceFromAfter,\n\t\tuint256 balanceToBefore\n\t) external;\n\n\tfunction getReservesList() external view returns (address[] memory);\n\n\tfunction getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\n\n\tfunction setPause(bool val) external;\n\n\tfunction paused() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ILendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n\tevent MarketIdSet(string newMarketId);\n\tevent LendingPoolUpdated(address indexed newAddress);\n\tevent ConfigurationAdminUpdated(address indexed newAddress);\n\tevent EmergencyAdminUpdated(address indexed newAddress);\n\tevent LendingPoolConfiguratorUpdated(address indexed newAddress);\n\tevent LendingPoolCollateralManagerUpdated(address indexed newAddress);\n\tevent PriceOracleUpdated(address indexed newAddress);\n\tevent LendingRateOracleUpdated(address indexed newAddress);\n\tevent ProxyCreated(bytes32 id, address indexed newAddress);\n\tevent AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n\tfunction getMarketId() external view returns (string memory);\n\n\tfunction setMarketId(string calldata marketId) external;\n\n\tfunction setAddress(bytes32 id, address newAddress) external;\n\n\tfunction setAddressAsProxy(bytes32 id, address impl) external;\n\n\tfunction getAddress(bytes32 id) external view returns (address);\n\n\tfunction getLendingPool() external view returns (address);\n\n\tfunction setLendingPoolImpl(address pool) external;\n\n\tfunction getLendingPoolConfigurator() external view returns (address);\n\n\tfunction setLendingPoolConfiguratorImpl(address configurator) external;\n\n\tfunction getLendingPoolCollateralManager() external view returns (address);\n\n\tfunction setLendingPoolCollateralManager(address manager) external;\n\n\tfunction getPoolAdmin() external view returns (address);\n\n\tfunction setPoolAdmin(address admin) external;\n\n\tfunction getEmergencyAdmin() external view returns (address);\n\n\tfunction setEmergencyAdmin(address admin) external;\n\n\tfunction getPriceOracle() external view returns (address);\n\n\tfunction setPriceOracle(address priceOracle) external;\n\n\tfunction getLendingRateOracle() external view returns (address);\n\n\tfunction setLendingRateOracle(address lendingRateOracle) external;\n\n\tfunction getLiquidationFeeTo() external view returns (address);\n\n\tfunction setLiquidationFeeTo(address liquidationFeeTo) external;\n}\n"
    },
    "contracts/interfaces/ILendingPoolAddressesProviderRegistry.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title LendingPoolAddressesProviderRegistry contract\n * @dev Main registry of LendingPoolAddressesProvider of multiple Aave protocol's markets\n * - Used for indexing purposes of Aave protocol's markets\n * - The id assigned to a LendingPoolAddressesProvider refers to the market it is connected with,\n *   for example with `0` for the Aave main market and `1` for the next created\n * @author Aave\n **/\ninterface ILendingPoolAddressesProviderRegistry {\n\tevent AddressesProviderRegistered(address indexed newAddress);\n\tevent AddressesProviderUnregistered(address indexed newAddress);\n\n\tfunction getAddressesProvidersList() external view returns (address[] memory);\n\n\tfunction getAddressesProviderIdByAddress(address addressesProvider) external view returns (uint256);\n\n\tfunction registerAddressesProvider(address provider, uint256 id) external;\n\n\tfunction unregisterAddressesProvider(address provider) external;\n}\n"
    },
    "contracts/interfaces/ILendingPoolCollateralManager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title ILendingPoolCollateralManager\n * @author Aave\n * @notice Defines the actions involving management of collateral in the protocol.\n **/\ninterface ILendingPoolCollateralManager {\n\t/**\n\t * @dev Emitted when a borrower is liquidated\n\t * @param collateral The address of the collateral being liquidated\n\t * @param principal The address of the reserve\n\t * @param user The address of the user being liquidated\n\t * @param debtToCover The total amount liquidated\n\t * @param liquidatedCollateralAmount The amount of collateral being liquidated\n\t * @param liquidator The address of the liquidator\n\t * @param receiveAToken true if the liquidator wants to receive aTokens, false otherwise\n\t **/\n\tevent LiquidationCall(\n\t\taddress indexed collateral,\n\t\taddress indexed principal,\n\t\taddress indexed user,\n\t\tuint256 debtToCover,\n\t\tuint256 liquidatedCollateralAmount,\n\t\taddress liquidator,\n\t\tbool receiveAToken,\n\t\taddress liquidationFeeTo\n\t);\n\n\t/**\n\t * @dev Emitted when a reserve is disabled as collateral for an user\n\t * @param reserve The address of the reserve\n\t * @param user The address of the user\n\t **/\n\tevent ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n\t/**\n\t * @dev Emitted when a reserve is enabled as collateral for an user\n\t * @param reserve The address of the reserve\n\t * @param user The address of the user\n\t **/\n\tevent ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n\t/**\n\t * @dev Users can invoke this function to liquidate an undercollateralized position.\n\t * @param collateral The address of the collateral to liquidated\n\t * @param principal The address of the principal reserve\n\t * @param user The address of the borrower\n\t * @param debtToCover The amount of principal that the liquidator wants to repay\n\t * @param receiveAToken true if the liquidators wants to receive the aTokens, false if\n\t * he wants to receive the underlying asset directly\n\t **/\n\tfunction liquidationCall(\n\t\taddress collateral,\n\t\taddress principal,\n\t\taddress user,\n\t\tuint256 debtToCover,\n\t\tbool receiveAToken,\n\t\taddress liquidationFeeTo\n\t) external returns (uint256, string memory);\n}\n"
    },
    "contracts/interfaces/ILendingPoolConfigurator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\ninterface ILendingPoolConfigurator {\n\tstruct InitReserveInput {\n\t\taddress aTokenImpl;\n\t\taddress stableDebtTokenImpl;\n\t\taddress variableDebtTokenImpl;\n\t\tuint8 underlyingAssetDecimals;\n\t\taddress interestRateStrategyAddress;\n\t\taddress underlyingAsset;\n\t\taddress treasury;\n\t\taddress incentivesController;\n\t\tuint256 allocPoint;\n\t\tstring underlyingAssetName;\n\t\tstring aTokenName;\n\t\tstring aTokenSymbol;\n\t\tstring variableDebtTokenName;\n\t\tstring variableDebtTokenSymbol;\n\t\tstring stableDebtTokenName;\n\t\tstring stableDebtTokenSymbol;\n\t\tbytes params;\n\t}\n\n\tstruct UpdateATokenInput {\n\t\taddress asset;\n\t\taddress treasury;\n\t\taddress incentivesController;\n\t\tstring name;\n\t\tstring symbol;\n\t\taddress implementation;\n\t\tbytes params;\n\t}\n\n\tstruct UpdateDebtTokenInput {\n\t\taddress asset;\n\t\taddress incentivesController;\n\t\tstring name;\n\t\tstring symbol;\n\t\taddress implementation;\n\t\tbytes params;\n\t}\n\n\t/**\n\t * @dev Emitted when a reserve is initialized.\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param aToken The address of the associated aToken contract\n\t * @param stableDebtToken The address of the associated stable rate debt token\n\t * @param variableDebtToken The address of the associated variable rate debt token\n\t * @param interestRateStrategyAddress The address of the interest rate strategy for the reserve\n\t **/\n\tevent ReserveInitialized(\n\t\taddress indexed asset,\n\t\taddress indexed aToken,\n\t\taddress stableDebtToken,\n\t\taddress variableDebtToken,\n\t\taddress interestRateStrategyAddress\n\t);\n\n\t/**\n\t * @dev Emitted when borrowing is enabled on a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param stableRateEnabled True if stable rate borrowing is enabled, false otherwise\n\t **/\n\tevent BorrowingEnabledOnReserve(address indexed asset, bool stableRateEnabled);\n\n\t/**\n\t * @dev Emitted when borrowing is disabled on a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tevent BorrowingDisabledOnReserve(address indexed asset);\n\n\t/**\n\t * @dev Emitted when the collateralization risk parameters for the specified asset are updated.\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param ltv The loan to value of the asset when used as collateral\n\t * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\n\t * @param liquidationBonus The bonus liquidators receive to liquidate this asset\n\t **/\n\tevent CollateralConfigurationChanged(\n\t\taddress indexed asset,\n\t\tuint256 ltv,\n\t\tuint256 liquidationThreshold,\n\t\tuint256 liquidationBonus\n\t);\n\n\t/**\n\t * @dev Emitted when stable rate borrowing is enabled on a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tevent StableRateEnabledOnReserve(address indexed asset);\n\n\t/**\n\t * @dev Emitted when stable rate borrowing is disabled on a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tevent StableRateDisabledOnReserve(address indexed asset);\n\n\t/**\n\t * @dev Emitted when a reserve is activated\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tevent ReserveActivated(address indexed asset);\n\n\t/**\n\t * @dev Emitted when a reserve is deactivated\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tevent ReserveDeactivated(address indexed asset);\n\n\t/**\n\t * @dev Emitted when a reserve is frozen\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tevent ReserveFrozen(address indexed asset);\n\n\t/**\n\t * @dev Emitted when a reserve is unfrozen\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tevent ReserveUnfrozen(address indexed asset);\n\n\t/**\n\t * @dev Emitted when a reserve factor is updated\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param factor The new reserve factor\n\t **/\n\tevent ReserveFactorChanged(address indexed asset, uint256 factor);\n\n\t/**\n\t * @dev Emitted when the reserve decimals are updated\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param decimals The new decimals\n\t **/\n\tevent ReserveDecimalsChanged(address indexed asset, uint256 decimals);\n\n\t/**\n\t * @dev Emitted when a reserve interest strategy contract is updated\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param strategy The new address of the interest strategy contract\n\t **/\n\tevent ReserveInterestRateStrategyChanged(address indexed asset, address strategy);\n\n\t/**\n\t * @dev Emitted when an aToken implementation is upgraded\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param proxy The aToken proxy address\n\t * @param implementation The new aToken implementation\n\t **/\n\tevent ATokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);\n\n\t/**\n\t * @dev Emitted when the implementation of a stable debt token is upgraded\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param proxy The stable debt token proxy address\n\t * @param implementation The new aToken implementation\n\t **/\n\tevent StableDebtTokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);\n\n\t/**\n\t * @dev Emitted when the implementation of a variable debt token is upgraded\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param proxy The variable debt token proxy address\n\t * @param implementation The new aToken implementation\n\t **/\n\tevent VariableDebtTokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);\n}\n"
    },
    "contracts/interfaces/ILendingRateOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title ILendingRateOracle interface\n * @notice Interface for the Aave borrow rate oracle. Provides the average market borrow rate to be used as a base for the stable borrow rate calculations\n **/\n\ninterface ILendingRateOracle {\n\t/**\n    @dev returns the market borrow rate in ray\n    **/\n\tfunction getMarketBorrowRate(address asset) external view returns (uint256);\n\n\t/**\n    @dev sets the market borrow rate. Rate value must be in ray\n    **/\n\tfunction setMarketBorrowRate(address asset, uint256 rate) external;\n}\n"
    },
    "contracts/interfaces/ILeverager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\ninterface ILeverager {\n\tfunction wethToZap(address user) external view returns (uint256);\n\n\tfunction zapWETHWithBorrow(uint256 amount, address borrower) external returns (uint256 liquidity);\n}\n"
    },
    "contracts/interfaces/ILiquidityZap.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface ILiquidityZap {\n\tfunction _WETH() external view returns (address);\n\n\tfunction token() external view returns (address);\n\n\tfunction tokenWETHPair() external view returns (address);\n\n\tfunction addLiquidityETHOnly(address to) external returns (uint256 liquidity);\n\n\tfunction addLiquidityTokensOnly(address from, address to, uint256 amount) external returns (uint256 liquidity);\n\n\tfunction getLPTokenPerEthUnit(uint256 ethAmt) external view returns (uint256 liquidity);\n\n\tfunction initLiquidityZap(address token, address WETH, address tokenWethPair, address helper) external;\n\n\tfunction quote(uint256 wethAmount) external view returns (uint256 optimalTokenAmount);\n\n\tfunction quoteFromToken(uint256 tokenAmount) external view returns (uint256 optimalWETHAmount);\n\n\tfunction removeAllLiquidityETHOnly(address to) external returns (uint256 amount);\n\n\tfunction removeAllLiquidityTokenOnly(address to) external returns (uint256 amount);\n\n\tfunction removeLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 liquidity,\n\t\taddress to\n\t) external returns (uint256 amountA, uint256 amountB);\n\n\tfunction removeLiquidityETHOnly(address to, uint256 liquidity) external returns (uint256 amountOut);\n\n\tfunction removeLiquidityTokenOnly(address to, uint256 liquidity) external returns (uint256 amount);\n\n\tfunction standardAdd(\n\t\tuint256 tokenAmount,\n\t\tuint256 _wethAmt,\n\t\taddress to\n\t) external payable returns (uint256 liquidity);\n\n\tfunction unzap() external returns (uint256 amountToken, uint256 amountETH);\n\n\tfunction unzapToETH() external returns (uint256 amount);\n\n\tfunction unzapToTokens() external returns (uint256 amount);\n\n\tfunction zapETH(address payable _onBehalf) external payable returns (uint256 liquidity);\n\n\tfunction zapTokens(uint256 amount) external returns (uint256 liquidity);\n\n\tfunction addLiquidityWETHOnly(uint256 _amount, address payable to) external returns (uint256 liquidity);\n}\n"
    },
    "contracts/interfaces/ILockerList.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\ninterface ILockerList {\n\tfunction lockersCount() external view returns (uint256);\n\n\tfunction getUsers(uint256 page, uint256 limit) external view returns (address[] memory);\n\n\tfunction addToList(address user) external;\n\n\tfunction removeFromList(address user) external;\n}\n"
    },
    "contracts/interfaces/ILockZap.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\ninterface ILockZap {\n\tfunction zap(\n\t\tbool _borrow,\n\t\taddress _asset,\n\t\tuint256 _assetAmt,\n\t\tuint256 _prntAmt,\n\t\tuint256 _lockTypeIndex,\n\t\tuint256 _slippage\n\t) external returns (uint256 liquidity);\n\n\tfunction zapOnBehalf(\n\t\tbool _borrow,\n\t\taddress _asset,\n\t\tuint256 _assetAmt,\n\t\tuint256 _prntAmt,\n\t\taddress _onBehalf,\n\t\tuint256 _slippage\n\t) external returns (uint256 liquidity);\n}\n"
    },
    "contracts/interfaces/IMiddleFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"./LockedBalance.sol\";\nimport {IFeeDistribution} from \"./IMultiFeeDistribution.sol\";\n\ninterface IMiddleFeeDistribution is IFeeDistribution {\n\tfunction forwardReward(address[] memory _rewardTokens) external;\n\n\tfunction getPrntTokenAddress() external view returns (address);\n\n\tfunction getMultiFeeDistributionAddress() external view returns (address);\n\n\tfunction operationExpenseRatio() external view returns (uint256);\n\n\tfunction operationExpenses() external view returns (address);\n\n\tfunction isRewardToken(address) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IMintableToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IMintableToken is IERC20 {\n\tfunction mint(address _receiver, uint256 _amount) external returns (bool);\n\n\tfunction burn(uint256 _amount) external returns (bool);\n\n\tfunction setMinter(address _minter) external returns (bool);\n\n\tfunction priceProvider() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IMultiFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"./LockedBalance.sol\";\nimport \"./IFeeDistribution.sol\";\nimport \"./IMintableToken.sol\";\n\ninterface IMultiFeeDistribution is IFeeDistribution {\n\tfunction exit(bool claimRewards) external;\n\n\tfunction stake(uint256 amount, address onBehalfOf, uint256 typeIndex) external;\n\n\tfunction prntToken() external view returns (IMintableToken);\n\n\tfunction getPriceProvider() external view returns (address);\n\n\tfunction lockInfo(address user) external view returns (LockedBalance[] memory);\n\n\tfunction autocompoundEnabled(address user) external view returns (bool);\n\n\tfunction defaultLockIndex(address _user) external view returns (uint256);\n\n\tfunction autoRelockDisabled(address user) external view returns (bool);\n\n\tfunction totalBalance(address user) external view returns (uint256);\n\n\tfunction lockedBalance(address user) external view returns (uint256);\n\n\tfunction lockedBalances(\n\t\taddress user\n\t) external view returns (uint256, uint256, uint256, uint256, LockedBalance[] memory);\n\n\tfunction getBalances(address _user) external view returns (Balances memory);\n\n\tfunction zapVestingToLp(address _address) external returns (uint256);\n\n\tfunction claimableRewards(address account) external view returns (IFeeDistribution.RewardData[] memory rewards);\n\n\tfunction setDefaultRelockTypeIndex(uint256 _index) external;\n\n\tfunction daoTreasury() external view returns (address);\n\n\tfunction stakingToken() external view returns (address);\n\n\tfunction userSlippage(address) external view returns (uint256);\n\n\tfunction claimFromConverter(address) external;\n\n\tfunction vestTokens(address user, uint256 amount, bool withPenalty) external;\n}\n\ninterface IMFDPlus is IMultiFeeDistribution {\n\tfunction getLastClaimTime(address _user) external returns (uint256);\n\n\tfunction claimBounty(address _user, bool _execute) external returns (bool issueBaseBounty);\n\n\tfunction claimCompound(address _user, bool _execute, uint256 _slippage) external returns (uint256 bountyAmt);\n\n\tfunction setAutocompound(bool _newVal) external;\n\n\tfunction getAutocompoundEnabled(address _user) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IOnwardIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ninterface IOnwardIncentivesController {\n\tfunction handleAction(address _token, address _user, uint256 _balance, uint256 _totalSupply) external;\n}\n"
    },
    "contracts/interfaces/IPoolHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IPoolHelper {\n\tfunction lpTokenAddr() external view returns (address);\n\n\tfunction zapWETH(uint256 amount) external returns (uint256);\n\n\tfunction zapTokens(uint256 _wethAmt, uint256 _prntAmt) external returns (uint256);\n\n\tfunction quoteFromToken(uint256 tokenAmount) external view returns (uint256 optimalWETHAmount);\n\n\tfunction quoteWETH(uint256 lpAmount) external view returns (uint256 wethAmount);\n\n\tfunction getLpPrice(uint256 prntPriceInEth) external view returns (uint256 priceInEth);\n\n\tfunction getReserves() external view returns (uint256 prnt, uint256 weth, uint256 lpTokenSupply);\n\n\tfunction getPrice() external view returns (uint256 priceInEth);\n\n\tfunction quoteSwap(address _inToken, uint256 _wethAmount) external view returns (uint256 tokenAmount);\n\n\tfunction swapToWeth(address _inToken, uint256 _amount, uint256 _minAmountOut) external;\n}\n\ninterface IBalancerPoolHelper is IPoolHelper {\n\tfunction initializePool(string calldata _tokenName, string calldata _tokenSymbol) external;\n}\n\ninterface IUniswapPoolHelper is IPoolHelper {\n\tfunction initializePool() external;\n}\n\ninterface ITestPoolHelper is IPoolHelper {\n\tfunction sell(uint256 _amount) external returns (uint256 amountOut);\n}\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/************\n@title IPriceOracle interface\n@notice Interface for the Aave price oracle.*/\ninterface IPriceOracle {\n\t/***********\n    @dev returns the asset price in ETH\n     */\n\tfunction getAssetPrice(address asset) external view returns (uint256);\n\n\t/***********\n    @dev sets the asset price, in wei\n     */\n\tfunction setAssetPrice(address asset, uint256 price) external;\n}\n"
    },
    "contracts/interfaces/IPriceOracleGetter.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title IPriceOracleGetter interface\n * @notice Interface for the Aave price oracle.\n **/\n\ninterface IPriceOracleGetter {\n\t/**\n\t * @dev returns the asset price in ETH\n\t * @param asset the address of the asset\n\t * @return the ETH price of the asset\n\t **/\n\tfunction getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ninterface IPriceProvider {\n\tfunction getTokenPrice() external view returns (uint256);\n\n\tfunction getTokenPriceUsd() external view returns (uint256);\n\n\tfunction getLpTokenPrice() external view returns (uint256);\n\n\tfunction getLpTokenPriceUsd() external view returns (uint256);\n\n\tfunction decimals() external view returns (uint256);\n\n\tfunction update() external;\n\n\tfunction baseAssetChainlinkAdapter() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IReserveInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title IReserveInterestRateStrategyInterface interface\n * @dev Interface for the calculation of the interest rates\n * @author Aave\n */\ninterface IReserveInterestRateStrategy {\n\tfunction baseVariableBorrowRate() external view returns (uint256);\n\n\tfunction getMaxVariableBorrowRate() external view returns (uint256);\n\n\tfunction calculateInterestRates(\n\t\taddress reserve,\n\t\tuint256 availableLiquidity,\n\t\tuint256 totalStableDebt,\n\t\tuint256 totalVariableDebt,\n\t\tuint256 averageStableBorrowRate,\n\t\tuint256 reserveFactor\n\t) external view returns (uint256, uint256, uint256);\n\n\tfunction calculateInterestRates(\n\t\taddress reserve,\n\t\taddress aToken,\n\t\tuint256 liquidityAdded,\n\t\tuint256 liquidityTaken,\n\t\tuint256 totalStableDebt,\n\t\tuint256 totalVariableDebt,\n\t\tuint256 averageStableBorrowRate,\n\t\tuint256 reserveFactor\n\t) external view returns (uint256 liquidityRate, uint256 stableBorrowRate, uint256 variableBorrowRate);\n}\n"
    },
    "contracts/interfaces/IRouterETH.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.12;\n\ninterface IRouterETH {\n\tfunction swapETH(\n\t\tuint16 _dstChainId, // destination Stargate chainId\n\t\taddress payable _refundAddress, // refund additional messageFee to this address\n\t\tbytes calldata _toAddress, // the receiver of the destination ETH\n\t\tuint256 _amountLD, // the amount, in Local Decimals, to be swapped\n\t\tuint256 _minAmountLD // the minimum amount accepted out on destination\n\t) external payable;\n}\n"
    },
    "contracts/interfaces/IScaledBalanceToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface IScaledBalanceToken {\n\t/**\n\t * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n\t * updated stored balance divided by the reserve's liquidity index at the moment of the update\n\t * @param user The user whose balance is calculated\n\t * @return The scaled balance of the user\n\t **/\n\tfunction scaledBalanceOf(address user) external view returns (uint256);\n\n\t/**\n\t * @dev Returns the scaled balance of the user and the scaled total supply.\n\t * @param user The address of the user\n\t * @return The scaled balance of the user\n\t * @return The scaled balance and the scaled total supply\n\t **/\n\tfunction getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n\n\t/**\n\t * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n\t * @return The scaled total supply\n\t **/\n\tfunction scaledTotalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ISequencerAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"./IChainlinkAggregator.sol\";\n\ninterface ISequencerAggregator is IChainlinkAggregator {\n\tfunction aggregator() external view returns (address);\n\n\tfunction updateStatus(bool status, uint64 timestamp) external;\n}\n"
    },
    "contracts/interfaces/IStableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {IInitializableDebtToken} from \"./IInitializableDebtToken.sol\";\nimport {IAaveIncentivesController} from \"./IAaveIncentivesController.sol\";\n\n/**\n * @title IStableDebtToken\n * @notice Defines the interface for the stable debt token\n * @dev It does not inherit from IERC20 to save in code size\n * @author Aave\n **/\n\ninterface IStableDebtToken is IInitializableDebtToken {\n\t/**\n\t * @dev Emitted when new stable debt is minted\n\t * @param user The address of the user who triggered the minting\n\t * @param onBehalfOf The recipient of stable debt tokens\n\t * @param amount The amount minted\n\t * @param currentBalance The current balance of the user\n\t * @param balanceIncrease The increase in balance since the last action of the user\n\t * @param newRate The rate of the debt after the minting\n\t * @param avgStableRate The new average stable rate after the minting\n\t * @param newTotalSupply The new total supply of the stable debt token after the action\n\t **/\n\tevent Mint(\n\t\taddress indexed user,\n\t\taddress indexed onBehalfOf,\n\t\tuint256 amount,\n\t\tuint256 currentBalance,\n\t\tuint256 balanceIncrease,\n\t\tuint256 newRate,\n\t\tuint256 avgStableRate,\n\t\tuint256 newTotalSupply\n\t);\n\n\t/**\n\t * @dev Emitted when new stable debt is burned\n\t * @param user The address of the user\n\t * @param amount The amount being burned\n\t * @param currentBalance The current balance of the user\n\t * @param balanceIncrease The the increase in balance since the last action of the user\n\t * @param avgStableRate The new average stable rate after the burning\n\t * @param newTotalSupply The new total supply of the stable debt token after the action\n\t **/\n\tevent Burn(\n\t\taddress indexed user,\n\t\tuint256 amount,\n\t\tuint256 currentBalance,\n\t\tuint256 balanceIncrease,\n\t\tuint256 avgStableRate,\n\t\tuint256 newTotalSupply\n\t);\n\n\t/**\n\t * @dev Mints debt token to the `onBehalfOf` address.\n\t * - The resulting rate is the weighted average between the rate of the new debt\n\t * and the rate of the previous debt\n\t * @param user The address receiving the borrowed underlying, being the delegatee in case\n\t * of credit delegate, or same as `onBehalfOf` otherwise\n\t * @param onBehalfOf The address receiving the debt tokens\n\t * @param amount The amount of debt tokens to mint\n\t * @param rate The rate of the debt being minted\n\t **/\n\tfunction mint(address user, address onBehalfOf, uint256 amount, uint256 rate) external returns (bool);\n\n\t/**\n\t * @dev Burns debt of `user`\n\t * - The resulting rate is the weighted average between the rate of the new debt\n\t * and the rate of the previous debt\n\t * @param user The address of the user getting his debt burned\n\t * @param amount The amount of debt tokens getting burned\n\t **/\n\tfunction burn(address user, uint256 amount) external;\n\n\t/**\n\t * @dev Returns the average rate of all the stable rate loans.\n\t * @return The average stable rate\n\t **/\n\tfunction getAverageStableRate() external view returns (uint256);\n\n\t/**\n\t * @dev Returns the stable rate of the user debt\n\t * @return The stable rate of the user\n\t **/\n\tfunction getUserStableRate(address user) external view returns (uint256);\n\n\t/**\n\t * @dev Returns the timestamp of the last update of the user\n\t * @return The timestamp\n\t **/\n\tfunction getUserLastUpdated(address user) external view returns (uint40);\n\n\t/**\n\t * @dev Returns the principal, the total supply and the average stable rate\n\t **/\n\tfunction getSupplyData() external view returns (uint256, uint256, uint256, uint40);\n\n\t/**\n\t * @dev Returns the timestamp of the last update of the total supply\n\t * @return The timestamp\n\t **/\n\tfunction getTotalSupplyLastUpdated() external view returns (uint40);\n\n\t/**\n\t * @dev Returns the total supply and the average stable rate\n\t **/\n\tfunction getTotalSupplyAndAvgRate() external view returns (uint256, uint256);\n\n\t/**\n\t * @dev Returns the principal debt balance of the user\n\t * @return The debt balance of the user since the last burn/mint action\n\t **/\n\tfunction principalBalanceOf(address user) external view returns (uint256);\n\n\t/**\n\t * @dev Returns the address of the incentives controller contract\n\t **/\n\tfunction getIncentivesController() external view returns (IAaveIncentivesController);\n}\n"
    },
    "contracts/interfaces/IStargateRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.12;\n\ninterface IStargateRouter {\n\tstruct lzTxObj {\n\t\tuint256 dstGasForCall;\n\t\tuint256 dstNativeAmount;\n\t\tbytes dstNativeAddr;\n\t}\n\n\tfunction addLiquidity(uint256 _poolId, uint256 _amountLD, address _to) external;\n\n\tfunction swap(\n\t\tuint16 _dstChainId,\n\t\tuint256 _srcPoolId,\n\t\tuint256 _dstPoolId,\n\t\taddress payable _refundAddress,\n\t\tuint256 _amountLD,\n\t\tuint256 _minAmountLD,\n\t\tlzTxObj memory _lzTxParams,\n\t\tbytes calldata _to,\n\t\tbytes calldata _payload\n\t) external payable;\n\n\tfunction redeemRemote(\n\t\tuint16 _dstChainId,\n\t\tuint256 _srcPoolId,\n\t\tuint256 _dstPoolId,\n\t\taddress payable _refundAddress,\n\t\tuint256 _amountLP,\n\t\tuint256 _minAmountLD,\n\t\tbytes calldata _to,\n\t\tlzTxObj memory _lzTxParams\n\t) external payable;\n\n\tfunction instantRedeemLocal(uint16 _srcPoolId, uint256 _amountLP, address _to) external returns (uint256);\n\n\tfunction redeemLocal(\n\t\tuint16 _dstChainId,\n\t\tuint256 _srcPoolId,\n\t\tuint256 _dstPoolId,\n\t\taddress payable _refundAddress,\n\t\tuint256 _amountLP,\n\t\tbytes calldata _to,\n\t\tlzTxObj memory _lzTxParams\n\t) external payable;\n\n\tfunction sendCredits(\n\t\tuint16 _dstChainId,\n\t\tuint256 _srcPoolId,\n\t\tuint256 _dstPoolId,\n\t\taddress payable _refundAddress\n\t) external payable;\n\n\tfunction quoteLayerZeroFee(\n\t\tuint16 _dstChainId,\n\t\tuint8 _functionType,\n\t\tbytes calldata _toAddress,\n\t\tbytes calldata _transferAndCallPayload,\n\t\tlzTxObj memory _lzTxParams\n\t) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/interfaces/IUiPoolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPoolAddressesProvider} from \"./ILendingPoolAddressesProvider.sol\";\nimport {IAaveIncentivesController} from \"./IAaveIncentivesController.sol\";\n\ninterface IUiPoolDataProvider {\n\tstruct AggregatedReserveData {\n\t\taddress underlyingAsset;\n\t\tstring name;\n\t\tstring symbol;\n\t\tuint256 decimals;\n\t\tuint256 baseLTVasCollateral;\n\t\tuint256 reserveLiquidationThreshold;\n\t\tuint256 reserveLiquidationBonus;\n\t\tuint256 reserveFactor;\n\t\tbool usageAsCollateralEnabled;\n\t\tbool borrowingEnabled;\n\t\tbool stableBorrowRateEnabled;\n\t\tbool isActive;\n\t\tbool isFrozen;\n\t\t// base data\n\t\tuint128 liquidityIndex;\n\t\tuint128 variableBorrowIndex;\n\t\tuint128 liquidityRate;\n\t\tuint128 variableBorrowRate;\n\t\tuint128 stableBorrowRate;\n\t\tuint40 lastUpdateTimestamp;\n\t\taddress aTokenAddress;\n\t\taddress stableDebtTokenAddress;\n\t\taddress variableDebtTokenAddress;\n\t\taddress interestRateStrategyAddress;\n\t\t//\n\t\tuint256 availableLiquidity;\n\t\tuint256 totalPrincipalStableDebt;\n\t\tuint256 averageStableRate;\n\t\tuint256 stableDebtLastUpdateTimestamp;\n\t\tuint256 totalScaledVariableDebt;\n\t\tuint256 priceInEth;\n\t\tuint256 variableRateSlope1;\n\t\tuint256 variableRateSlope2;\n\t\tuint256 stableRateSlope1;\n\t\tuint256 stableRateSlope2;\n\t\t// incentives\n\t\tuint256 aEmissionPerSecond;\n\t\tuint256 vEmissionPerSecond;\n\t\tuint256 sEmissionPerSecond;\n\t\tuint256 aIncentivesLastUpdateTimestamp;\n\t\tuint256 vIncentivesLastUpdateTimestamp;\n\t\tuint256 sIncentivesLastUpdateTimestamp;\n\t\tuint256 aTokenIncentivesIndex;\n\t\tuint256 vTokenIncentivesIndex;\n\t\tuint256 sTokenIncentivesIndex;\n\t}\n\n\tstruct UserReserveData {\n\t\taddress underlyingAsset;\n\t\tuint256 scaledATokenBalance;\n\t\tbool usageAsCollateralEnabledOnUser;\n\t\tuint256 stableBorrowRate;\n\t\tuint256 scaledVariableDebt;\n\t\tuint256 principalStableDebt;\n\t\tuint256 stableBorrowLastUpdateTimestamp;\n\t\t// incentives\n\t\tuint256 aTokenincentivesUserIndex;\n\t\tuint256 vTokenincentivesUserIndex;\n\t\tuint256 sTokenincentivesUserIndex;\n\t}\n\n\tstruct IncentivesControllerData {\n\t\tuint256 userUnclaimedRewards;\n\t\tuint256 emissionEndTimestamp;\n\t}\n\n\tfunction getReservesData(\n\t\tILendingPoolAddressesProvider provider,\n\t\taddress user\n\t)\n\t\texternal\n\t\tview\n\t\treturns (AggregatedReserveData[] memory, UserReserveData[] memory, uint256, IncentivesControllerData memory);\n}\n"
    },
    "contracts/interfaces/IUiPoolDataProviderV3.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPoolAddressesProvider} from \"./ILendingPoolAddressesProvider.sol\";\n\ninterface IUiPoolDataProviderV3 {\n\tstruct AggregatedReserveData {\n\t\taddress underlyingAsset;\n\t\tstring name;\n\t\tstring symbol;\n\t\tuint256 decimals;\n\t\tuint256 baseLTVasCollateral;\n\t\tuint256 reserveLiquidationThreshold;\n\t\tuint256 reserveLiquidationBonus;\n\t\tuint256 reserveFactor;\n\t\tbool usageAsCollateralEnabled;\n\t\tbool borrowingEnabled;\n\t\tbool stableBorrowRateEnabled;\n\t\tbool isActive;\n\t\tbool isFrozen;\n\t\t// base data\n\t\tuint128 liquidityIndex;\n\t\tuint128 variableBorrowIndex;\n\t\tuint128 liquidityRate;\n\t\tuint128 variableBorrowRate;\n\t\tuint128 stableBorrowRate;\n\t\tuint40 lastUpdateTimestamp;\n\t\taddress aTokenAddress;\n\t\taddress stableDebtTokenAddress;\n\t\taddress variableDebtTokenAddress;\n\t\taddress interestRateStrategyAddress;\n\t\t//\n\t\tuint256 availableLiquidity;\n\t\tuint256 totalPrincipalStableDebt;\n\t\tuint256 averageStableRate;\n\t\tuint256 stableDebtLastUpdateTimestamp;\n\t\tuint256 totalScaledVariableDebt;\n\t\tuint256 priceInMarketReferenceCurrency;\n\t\tuint256 variableRateSlope1;\n\t\tuint256 variableRateSlope2;\n\t\tuint256 stableRateSlope1;\n\t\tuint256 stableRateSlope2;\n\t\t// v3\n\t\tbool isPaused;\n\t\tuint128 accruedToTreasury;\n\t\tuint128 unbacked;\n\t\tuint128 isolationModeTotalDebt;\n\t\t//\n\t\tuint256 debtCeiling;\n\t\tuint256 debtCeilingDecimals;\n\t\tuint8 eModeCategoryId;\n\t\tuint256 borrowCap;\n\t\tuint256 supplyCap;\n\t\t// eMode\n\t\tuint16 eModeLtv;\n\t\tuint16 eModeLiquidationThreshold;\n\t\tuint16 eModeLiquidationBonus;\n\t\taddress eModePriceSource;\n\t\tstring eModeLabel;\n\t\tbool borrowableInIsolation;\n\t}\n\n\tstruct UserReserveData {\n\t\taddress underlyingAsset;\n\t\tuint256 scaledATokenBalance;\n\t\tbool usageAsCollateralEnabledOnUser;\n\t\tuint256 stableBorrowRate;\n\t\tuint256 scaledVariableDebt;\n\t\tuint256 principalStableDebt;\n\t\tuint256 stableBorrowLastUpdateTimestamp;\n\t}\n\n\tstruct BaseCurrencyInfo {\n\t\tuint256 marketReferenceCurrencyUnit;\n\t\tint256 marketReferenceCurrencyPriceInUsd;\n\t\tint256 networkBaseTokenPriceInUsd;\n\t\tuint8 networkBaseTokenPriceDecimals;\n\t}\n\n\tfunction getReservesList(ILendingPoolAddressesProvider provider) external view returns (address[] memory);\n\n\tfunction getReservesData(\n\t\tILendingPoolAddressesProvider provider\n\t) external view returns (AggregatedReserveData[] memory, BaseCurrencyInfo memory);\n\n\tfunction getUserReservesData(\n\t\tILendingPoolAddressesProvider provider,\n\t\taddress user\n\t) external view returns (UserReserveData[] memory, uint8);\n}\n"
    },
    "contracts/interfaces/IUniV2TwapOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ninterface IUniV2TwapOracle {\n\tfunction latestAnswer() external view returns (uint256 price);\n\n\tfunction latestAnswerInEth() external view returns (uint256 price);\n\n\tfunction update() external;\n\n\tfunction canUpdate() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IVariableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {IScaledBalanceToken} from \"./IScaledBalanceToken.sol\";\nimport {IInitializableDebtToken} from \"./IInitializableDebtToken.sol\";\nimport {IAaveIncentivesController} from \"./IAaveIncentivesController.sol\";\n\n/**\n * @title IVariableDebtToken\n * @author Aave\n * @notice Defines the basic interface for a variable debt token.\n **/\ninterface IVariableDebtToken is IScaledBalanceToken, IInitializableDebtToken {\n\t/**\n\t * @dev Emitted after the mint action\n\t * @param from The address performing the mint\n\t * @param onBehalfOf The address of the user on which behalf minting has been performed\n\t * @param value The amount to be minted\n\t * @param index The last index of the reserve\n\t **/\n\tevent Mint(address indexed from, address indexed onBehalfOf, uint256 value, uint256 index);\n\n\t/**\n\t * @dev Mints debt token to the `onBehalfOf` address\n\t * @param user The address receiving the borrowed underlying, being the delegatee in case\n\t * of credit delegate, or same as `onBehalfOf` otherwise\n\t * @param onBehalfOf The address receiving the debt tokens\n\t * @param amount The amount of debt being minted\n\t * @param index The variable debt index of the reserve\n\t * @return `true` if the the previous balance of the user is 0\n\t **/\n\tfunction mint(address user, address onBehalfOf, uint256 amount, uint256 index) external returns (bool);\n\n\t/**\n\t * @dev Emitted when variable debt is burnt\n\t * @param user The user which debt has been burned\n\t * @param amount The amount of debt being burned\n\t * @param index The index of the user\n\t **/\n\tevent Burn(address indexed user, uint256 amount, uint256 index);\n\n\t/**\n\t * @dev Burns user variable debt\n\t * @param user The user which debt is burnt\n\t * @param index The variable debt index of the reserve\n\t **/\n\tfunction burn(address user, uint256 amount, uint256 index) external;\n\n\t/**\n\t * @dev Returns the address of the incentives controller contract\n\t **/\n\tfunction getIncentivesController() external view returns (IAaveIncentivesController);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface IWETH {\n\tfunction balanceOf(address) external returns (uint256);\n\n\tfunction deposit() external payable;\n\n\tfunction withdraw(uint256) external;\n\n\tfunction approve(address guy, uint256 wad) external returns (bool);\n\n\tfunction transferFrom(address src, address dst, uint256 wad) external returns (bool);\n\n\tfunction transfer(address to, uint256 value) external returns (bool);\n\n\tfunction allowance(address owner, address spender) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IWETHGateway.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface IWETHGateway {\n\tfunction depositETH(address lendingPool, address onBehalfOf, uint16 referralCode) external payable;\n\n\tfunction withdrawETH(address lendingPool, uint256 amount, address onBehalfOf) external;\n\n\tfunction repayETH(address lendingPool, uint256 amount, uint256 rateMode, address onBehalfOf) external payable;\n\n\tfunction borrowETH(address lendingPool, uint256 amount, uint256 interesRateMode, uint16 referralCode) external;\n}\n"
    },
    "contracts/interfaces/LockedBalance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nstruct LockedBalance {\n\tuint256 amount;\n\tuint256 unlockTime;\n\tuint256 multiplier;\n\tuint256 duration;\n}\n\nstruct EarnedBalance {\n\tuint256 amount;\n\tuint256 unlockTime;\n\tuint256 penalty;\n}\n\nstruct Reward {\n\tuint256 periodFinish;\n\tuint256 rewardPerSecond;\n\tuint256 lastUpdateTime;\n\tuint256 rewardPerTokenStored;\n\t// tracks already-added balances to handle accrued interest in aToken rewards\n\t// for the stakingToken this value is unused and will always be 0\n\tuint256 balance;\n}\n\nstruct Balances {\n\tuint256 total; // sum of earnings and lockings; no use when LP and PRNT is different\n\tuint256 unlocked; // PRNT token\n\tuint256 locked; // LP token or PRNT token\n\tuint256 lockedWithMultiplier; // Multiplied locked amount\n\tuint256 earned; // PRNT token\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface IUniswapV2Factory {\n\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n\tfunction feeTo() external view returns (address);\n\n\tfunction feeToSetter() external view returns (address);\n\n\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\n\n\tfunction allPairs(uint256) external view returns (address pair);\n\n\tfunction allPairsLength() external view returns (uint256);\n\n\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\n\n\tfunction setFeeTo(address) external;\n\n\tfunction setFeeToSetter(address) external;\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface IUniswapV2Pair {\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\tfunction name() external pure returns (string memory);\n\n\tfunction symbol() external pure returns (string memory);\n\n\tfunction decimals() external pure returns (uint8);\n\n\tfunction totalSupply() external view returns (uint256);\n\n\tfunction balanceOf(address owner) external view returns (uint256);\n\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\n\tfunction approve(address spender, uint256 value) external returns (bool);\n\n\tfunction transfer(address to, uint256 value) external returns (bool);\n\n\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\n\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\n\n\tfunction nonces(address owner) external view returns (uint256);\n\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n\n\tevent Mint(address indexed sender, uint256 amount0, uint256 amount1);\n\tevent Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n\tevent Swap(\n\t\taddress indexed sender,\n\t\tuint256 amount0In,\n\t\tuint256 amount1In,\n\t\tuint256 amount0Out,\n\t\tuint256 amount1Out,\n\t\taddress indexed to\n\t);\n\tevent Sync(uint112 reserve0, uint112 reserve1);\n\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n\tfunction factory() external view returns (address);\n\n\tfunction token0() external view returns (address);\n\n\tfunction token1() external view returns (address);\n\n\tfunction getReserves() external view returns (uint256 reserve0, uint256 reserve1, uint256 blockTimestampLast);\n\n\tfunction price0CumulativeLast() external view returns (uint256);\n\n\tfunction price1CumulativeLast() external view returns (uint256);\n\n\tfunction kLast() external view returns (uint256);\n\n\tfunction mint(address to) external returns (uint256 liquidity);\n\n\tfunction burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n\tfunction swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\n\n\tfunction skim(address to) external;\n\n\tfunction sync() external;\n\n\tfunction initialize(address, address) external;\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface IUniswapV2Router01 {\n\tfunction factory() external view returns (address);\n\n\tfunction WETH() external view returns (address);\n\n\tfunction addLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 amountADesired,\n\t\tuint256 amountBDesired,\n\t\tuint256 amountAMin,\n\t\tuint256 amountBMin,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n\tfunction addLiquidityETH(\n\t\taddress token,\n\t\tuint256 amountTokenDesired,\n\t\tuint256 amountTokenMin,\n\t\tuint256 amountETHMin,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\n\n\tfunction removeLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 liquidity,\n\t\tuint256 amountAMin,\n\t\tuint256 amountBMin,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256 amountA, uint256 amountB);\n\n\tfunction removeLiquidityETH(\n\t\taddress token,\n\t\tuint256 liquidity,\n\t\tuint256 amountTokenMin,\n\t\tuint256 amountETHMin,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256 amountToken, uint256 amountETH);\n\n\tfunction removeLiquidityWithPermit(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 liquidity,\n\t\tuint256 amountAMin,\n\t\tuint256 amountBMin,\n\t\taddress to,\n\t\tuint256 deadline,\n\t\tbool approveMax,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external returns (uint256 amountA, uint256 amountB);\n\n\tfunction removeLiquidityETHWithPermit(\n\t\taddress token,\n\t\tuint256 liquidity,\n\t\tuint256 amountTokenMin,\n\t\tuint256 amountETHMin,\n\t\taddress to,\n\t\tuint256 deadline,\n\t\tbool approveMax,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external returns (uint256 amountToken, uint256 amountETH);\n\n\tfunction swapExactTokensForTokens(\n\t\tuint256 amountIn,\n\t\tuint256 amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256[] memory amounts);\n\n\tfunction swapTokensForExactTokens(\n\t\tuint256 amountOut,\n\t\tuint256 amountInMax,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256[] memory amounts);\n\n\tfunction swapExactETHForTokens(\n\t\tuint256 amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external payable returns (uint256[] memory amounts);\n\n\tfunction swapTokensForExactETH(\n\t\tuint256 amountOut,\n\t\tuint256 amountInMax,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256[] memory amounts);\n\n\tfunction swapExactTokensForETH(\n\t\tuint256 amountIn,\n\t\tuint256 amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256[] memory amounts);\n\n\tfunction swapETHForExactTokens(\n\t\tuint256 amountOut,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external payable returns (uint256[] memory amounts);\n\n\tfunction quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);\n\n\tfunction getAmountOut(\n\t\tuint256 amountIn,\n\t\tuint256 reserveIn,\n\t\tuint256 reserveOut\n\t) external pure returns (uint256 amountOut);\n\n\tfunction getAmountIn(\n\t\tuint256 amountOut,\n\t\tuint256 reserveIn,\n\t\tuint256 reserveOut\n\t) external pure returns (uint256 amountIn);\n\n\tfunction getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n\tfunction getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./IUniswapV2Router01.sol\";\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n\tfunction removeLiquidityETHSupportingFeeOnTransferTokens(\n\t\taddress token,\n\t\tuint256 liquidity,\n\t\tuint256 amountTokenMin,\n\t\tuint256 amountETHMin,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256 amountETH);\n\n\tfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n\t\taddress token,\n\t\tuint256 liquidity,\n\t\tuint256 amountTokenMin,\n\t\tuint256 amountETHMin,\n\t\taddress to,\n\t\tuint256 deadline,\n\t\tbool approveMax,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external returns (uint256 amountETH);\n\n\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\n\t\tuint256 amountIn,\n\t\tuint256 amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external;\n\n\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\n\t\tuint256 amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external payable;\n\n\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\n\t\tuint256 amountIn,\n\t\tuint256 amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external;\n}\n"
    },
    "contracts/interfaces/uniswap/IWETH.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IWETH {\n\tfunction deposit() external payable;\n\n\tfunction transfer(address to, uint256 value) external returns (bool);\n\n\tfunction withdraw(uint256) external;\n\n\tfunction balanceOf(address) external returns (uint256);\n}\n"
    },
    "contracts/lending/AaveOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IPriceOracleGetter} from \"../interfaces/IPriceOracleGetter.sol\";\nimport {IChainlinkAggregator} from \"../interfaces/IChainlinkAggregator.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title AaveOracle\n/// @author Aave\n/// @notice Proxy smart contract to get the price of an asset from a price source, with Chainlink Aggregator\n///         smart contracts as primary option\n/// - If the returned price by a Chainlink aggregator is <= 0, the call is forwarded to a fallbackOracle\n/// - Owned by the Aave governance system, allowed to add sources for assets, replace them\n///   and change the fallbackOracle\ncontract AaveOracle is IPriceOracleGetter, Ownable {\n\tusing SafeERC20 for IERC20;\n\n\tevent BaseCurrencySet(address indexed baseCurrency, uint256 baseCurrencyUnit);\n\tevent AssetSourceUpdated(address indexed asset, address indexed source);\n\tevent FallbackOracleUpdated(address indexed fallbackOracle);\n\n\tmapping(address => IChainlinkAggregator) private assetsSources;\n\tIPriceOracleGetter private _fallbackOracle;\n\taddress public immutable BASE_CURRENCY;\n\tuint256 public immutable BASE_CURRENCY_UNIT;\n\n\t/// @notice Constructor\n\t/// @param assets The addresses of the assets\n\t/// @param sources The address of the source of each asset\n\t/// @param fallbackOracle The address of the fallback oracle to use if the data of an\n\t///        aggregator is not consistent\n\t/// @param baseCurrency the base currency used for the price quotes. If USD is used, base currency is 0x0\n\t/// @param baseCurrencyUnit the unit of the base currency\n\tconstructor(\n\t\taddress[] memory assets,\n\t\taddress[] memory sources,\n\t\taddress fallbackOracle,\n\t\taddress baseCurrency,\n\t\tuint256 baseCurrencyUnit\n\t) {\n\t\t_setFallbackOracle(fallbackOracle);\n\t\t_setAssetsSources(assets, sources);\n\t\tBASE_CURRENCY = baseCurrency;\n\t\tBASE_CURRENCY_UNIT = baseCurrencyUnit;\n\t\temit BaseCurrencySet(baseCurrency, baseCurrencyUnit);\n\t}\n\n\t/// @notice External function called by the Aave governance to set or replace sources of assets\n\t/// @param assets The addresses of the assets\n\t/// @param sources The address of the source of each asset\n\tfunction setAssetSources(address[] calldata assets, address[] calldata sources) external onlyOwner {\n\t\t_setAssetsSources(assets, sources);\n\t}\n\n\t/// @notice Sets the fallbackOracle\n\t/// - Callable only by the Aave governance\n\t/// @param fallbackOracle The address of the fallbackOracle\n\tfunction setFallbackOracle(address fallbackOracle) external onlyOwner {\n\t\t_setFallbackOracle(fallbackOracle);\n\t}\n\n\t/// @notice Internal function to set the sources for each asset\n\t/// @param assets The addresses of the assets\n\t/// @param sources The address of the source of each asset\n\tfunction _setAssetsSources(address[] memory assets, address[] memory sources) internal {\n\t\trequire(assets.length == sources.length, \"INCONSISTENT_PARAMS_LENGTH\");\n\t\tuint256 assetsLength = assets.length;\n\t\tfor (uint256 i = 0; i < assetsLength; ) {\n\t\t\tassetsSources[assets[i]] = IChainlinkAggregator(sources[i]);\n\t\t\temit AssetSourceUpdated(assets[i], sources[i]);\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/// @notice Internal function to set the fallbackOracle\n\t/// @param fallbackOracle The address of the fallbackOracle\n\tfunction _setFallbackOracle(address fallbackOracle) internal {\n\t\t_fallbackOracle = IPriceOracleGetter(fallbackOracle);\n\t\temit FallbackOracleUpdated(fallbackOracle);\n\t}\n\n\t/// @notice Gets an asset price by address\n\t/// @param asset The asset address\n\tfunction getAssetPrice(address asset) public view returns (uint256) {\n\t\tIChainlinkAggregator source = assetsSources[asset];\n\n\t\tif (asset == BASE_CURRENCY) {\n\t\t\treturn BASE_CURRENCY_UNIT;\n\t\t} else if (address(source) == address(0)) {\n\t\t\treturn _fallbackOracle.getAssetPrice(asset);\n\t\t} else {\n\t\t\tint256 price = IChainlinkAggregator(source).latestAnswer();\n\t\t\tif (price > 0) {\n\t\t\t\treturn uint256(price);\n\t\t\t} else {\n\t\t\t\treturn _fallbackOracle.getAssetPrice(asset);\n\t\t\t}\n\t\t}\n\t}\n\n\t/// @notice Gets a list of prices from a list of assets addresses\n\t/// @param assets The list of assets addresses\n\tfunction getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory) {\n\t\tuint256 length = assets.length;\n\t\tuint256[] memory prices = new uint256[](length);\n\t\tfor (uint256 i = 0; i < length; ) {\n\t\t\tprices[i] = getAssetPrice(assets[i]);\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn prices;\n\t}\n\n\t/// @notice Gets the address of the source for an asset address\n\t/// @param asset The address of the asset\n\t/// @return address The address of the source\n\tfunction getSourceOfAsset(address asset) external view returns (address) {\n\t\treturn address(assetsSources[asset]);\n\t}\n\n\t/// @notice Gets the address of the fallback oracle\n\t/// @return address The addres of the fallback oracle\n\tfunction getFallbackOracle() external view returns (address) {\n\t\treturn address(_fallbackOracle);\n\t}\n}\n"
    },
    "contracts/lending/AaveProtocolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ILendingPoolAddressesProvider} from \"../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {ILendingPool} from \"../interfaces/ILendingPool.sol\";\nimport {IStableDebtToken} from \"../interfaces/IStableDebtToken.sol\";\nimport {IVariableDebtToken} from \"../interfaces/IVariableDebtToken.sol\";\nimport {ReserveConfiguration} from \"./libraries/configuration/ReserveConfiguration.sol\";\nimport {UserConfiguration} from \"./libraries/configuration/UserConfiguration.sol\";\nimport {DataTypes} from \"./libraries/types/DataTypes.sol\";\n\ncontract AaveProtocolDataProvider {\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\tusing UserConfiguration for DataTypes.UserConfigurationMap;\n\n\taddress constant MKR = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;\n\taddress constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n\tstruct TokenData {\n\t\tstring symbol;\n\t\taddress tokenAddress;\n\t}\n\n\tILendingPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n\n\tconstructor(ILendingPoolAddressesProvider addressesProvider) {\n\t\tADDRESSES_PROVIDER = addressesProvider;\n\t}\n\n\tfunction getAllReservesTokens() external view returns (TokenData[] memory) {\n\t\tILendingPool pool = ILendingPool(ADDRESSES_PROVIDER.getLendingPool());\n\t\taddress[] memory reserves = pool.getReservesList();\n\t\tTokenData[] memory reservesTokens = new TokenData[](reserves.length);\n\t\tfor (uint256 i = 0; i < reserves.length; ) {\n\t\t\tif (reserves[i] == MKR) {\n\t\t\t\treservesTokens[i] = TokenData({symbol: \"MKR\", tokenAddress: reserves[i]});\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (reserves[i] == ETH) {\n\t\t\t\treservesTokens[i] = TokenData({symbol: \"ETH\", tokenAddress: reserves[i]});\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treservesTokens[i] = TokenData({symbol: IERC20Metadata(reserves[i]).symbol(), tokenAddress: reserves[i]});\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn reservesTokens;\n\t}\n\n\tfunction getAllATokens() external view returns (TokenData[] memory) {\n\t\tILendingPool pool = ILendingPool(ADDRESSES_PROVIDER.getLendingPool());\n\t\taddress[] memory reserves = pool.getReservesList();\n\t\tTokenData[] memory aTokens = new TokenData[](reserves.length);\n\t\tfor (uint256 i = 0; i < reserves.length; ) {\n\t\t\tDataTypes.ReserveData memory reserveData = pool.getReserveData(reserves[i]);\n\t\t\taTokens[i] = TokenData({\n\t\t\t\tsymbol: IERC20Metadata(reserveData.aTokenAddress).symbol(),\n\t\t\t\ttokenAddress: reserveData.aTokenAddress\n\t\t\t});\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn aTokens;\n\t}\n\n\tfunction getReserveConfigurationData(\n\t\taddress asset\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 decimals,\n\t\t\tuint256 ltv,\n\t\t\tuint256 liquidationThreshold,\n\t\t\tuint256 liquidationBonus,\n\t\t\tuint256 reserveFactor,\n\t\t\tbool usageAsCollateralEnabled,\n\t\t\tbool borrowingEnabled,\n\t\t\tbool stableBorrowRateEnabled,\n\t\t\tbool isActive,\n\t\t\tbool isFrozen\n\t\t)\n\t{\n\t\tDataTypes.ReserveConfigurationMap memory configuration = ILendingPool(ADDRESSES_PROVIDER.getLendingPool())\n\t\t\t.getConfiguration(asset);\n\n\t\t(ltv, liquidationThreshold, liquidationBonus, decimals, reserveFactor) = configuration.getParamsMemory();\n\n\t\t(isActive, isFrozen, borrowingEnabled, stableBorrowRateEnabled) = configuration.getFlagsMemory();\n\n\t\tusageAsCollateralEnabled = liquidationThreshold > 0;\n\t}\n\n\tfunction getReserveData(\n\t\taddress asset\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 availableLiquidity,\n\t\t\tuint256 totalStableDebt,\n\t\t\tuint256 totalVariableDebt,\n\t\t\tuint256 liquidityRate,\n\t\t\tuint256 variableBorrowRate,\n\t\t\tuint256 stableBorrowRate,\n\t\t\tuint256 averageStableBorrowRate,\n\t\t\tuint256 liquidityIndex,\n\t\t\tuint256 variableBorrowIndex,\n\t\t\tuint40 lastUpdateTimestamp\n\t\t)\n\t{\n\t\tDataTypes.ReserveData memory reserve = ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getReserveData(asset);\n\n\t\treturn (\n\t\t\tIERC20Metadata(asset).balanceOf(reserve.aTokenAddress),\n\t\t\tIERC20Metadata(reserve.stableDebtTokenAddress).totalSupply(),\n\t\t\tIERC20Metadata(reserve.variableDebtTokenAddress).totalSupply(),\n\t\t\treserve.currentLiquidityRate,\n\t\t\treserve.currentVariableBorrowRate,\n\t\t\treserve.currentStableBorrowRate,\n\t\t\tIStableDebtToken(reserve.stableDebtTokenAddress).getAverageStableRate(),\n\t\t\treserve.liquidityIndex,\n\t\t\treserve.variableBorrowIndex,\n\t\t\treserve.lastUpdateTimestamp\n\t\t);\n\t}\n\n\tfunction getUserReserveData(\n\t\taddress asset,\n\t\taddress user\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 currentATokenBalance,\n\t\t\tuint256 currentStableDebt,\n\t\t\tuint256 currentVariableDebt,\n\t\t\tuint256 principalStableDebt,\n\t\t\tuint256 scaledVariableDebt,\n\t\t\tuint256 stableBorrowRate,\n\t\t\tuint256 liquidityRate,\n\t\t\tuint40 stableRateLastUpdated,\n\t\t\tbool usageAsCollateralEnabled\n\t\t)\n\t{\n\t\tDataTypes.ReserveData memory reserve = ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getReserveData(asset);\n\n\t\tDataTypes.UserConfigurationMap memory userConfig = ILendingPool(ADDRESSES_PROVIDER.getLendingPool())\n\t\t\t.getUserConfiguration(user);\n\n\t\tcurrentATokenBalance = IERC20Metadata(reserve.aTokenAddress).balanceOf(user);\n\t\tcurrentVariableDebt = IERC20Metadata(reserve.variableDebtTokenAddress).balanceOf(user);\n\t\tcurrentStableDebt = IERC20Metadata(reserve.stableDebtTokenAddress).balanceOf(user);\n\t\tprincipalStableDebt = IStableDebtToken(reserve.stableDebtTokenAddress).principalBalanceOf(user);\n\t\tscaledVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress).scaledBalanceOf(user);\n\t\tliquidityRate = reserve.currentLiquidityRate;\n\t\tstableBorrowRate = IStableDebtToken(reserve.stableDebtTokenAddress).getUserStableRate(user);\n\t\tstableRateLastUpdated = IStableDebtToken(reserve.stableDebtTokenAddress).getUserLastUpdated(user);\n\t\tusageAsCollateralEnabled = userConfig.isUsingAsCollateral(reserve.id);\n\t}\n\n\tfunction getReserveTokensAddresses(\n\t\taddress asset\n\t) external view returns (address aTokenAddress, address stableDebtTokenAddress, address variableDebtTokenAddress) {\n\t\tDataTypes.ReserveData memory reserve = ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getReserveData(asset);\n\n\t\treturn (reserve.aTokenAddress, reserve.stableDebtTokenAddress, reserve.variableDebtTokenAddress);\n\t}\n}\n"
    },
    "contracts/lending/ATokensAndRatesHelper.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport {LendingPool} from \"./lendingpool/LendingPool.sol\";\nimport {LendingPoolAddressesProvider} from \"./configuration/LendingPoolAddressesProvider.sol\";\nimport {LendingPoolConfigurator} from \"./lendingpool/LendingPoolConfigurator.sol\";\nimport {AToken} from \"./tokenization/AToken.sol\";\nimport {DefaultReserveInterestRateStrategy} from \"./lendingpool/DefaultReserveInterestRateStrategy.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract ATokensAndRatesHelper is Ownable {\n\taddress payable private pool;\n\taddress private addressesProvider;\n\taddress private poolConfigurator;\n\tevent deployedContracts(address aToken, address strategy);\n\n\tstruct InitDeploymentInput {\n\t\taddress asset;\n\t\tuint256[6] rates;\n\t}\n\n\tstruct ConfigureReserveInput {\n\t\taddress asset;\n\t\tuint256 baseLTV;\n\t\tuint256 liquidationThreshold;\n\t\tuint256 liquidationBonus;\n\t\tuint256 reserveFactor;\n\t\tbool stableBorrowingEnabled;\n\t\tbool borrowingEnabled;\n\t}\n\n\tconstructor(address payable _pool, address _addressesProvider, address _poolConfigurator) {\n\t\tpool = _pool;\n\t\taddressesProvider = _addressesProvider;\n\t\tpoolConfigurator = _poolConfigurator;\n\t}\n\n\tfunction initDeployment(InitDeploymentInput[] calldata inputParams) external onlyOwner {\n\t\tuint256 length = inputParams.length;\n\t\tfor (uint256 i = 0; i < length; ) {\n\t\t\temit deployedContracts(\n\t\t\t\taddress(new AToken()),\n\t\t\t\taddress(\n\t\t\t\t\tnew DefaultReserveInterestRateStrategy(\n\t\t\t\t\t\tLendingPoolAddressesProvider(addressesProvider),\n\t\t\t\t\t\tinputParams[i].rates[0],\n\t\t\t\t\t\tinputParams[i].rates[1],\n\t\t\t\t\t\tinputParams[i].rates[2],\n\t\t\t\t\t\tinputParams[i].rates[3],\n\t\t\t\t\t\tinputParams[i].rates[4],\n\t\t\t\t\t\tinputParams[i].rates[5]\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction configureReserves(ConfigureReserveInput[] calldata inputParams) external onlyOwner {\n\t\tLendingPoolConfigurator configurator = LendingPoolConfigurator(poolConfigurator);\n\t\tuint256 length = inputParams.length;\n\t\tfor (uint256 i = 0; i < length; ) {\n\t\t\tconfigurator.configureReserveAsCollateral(\n\t\t\t\tinputParams[i].asset,\n\t\t\t\tinputParams[i].baseLTV,\n\t\t\t\tinputParams[i].liquidationThreshold,\n\t\t\t\tinputParams[i].liquidationBonus\n\t\t\t);\n\n\t\t\tif (inputParams[i].borrowingEnabled) {\n\t\t\t\tconfigurator.enableBorrowingOnReserve(inputParams[i].asset, inputParams[i].stableBorrowingEnabled);\n\t\t\t}\n\t\t\tconfigurator.setReserveFactor(inputParams[i].asset, inputParams[i].reserveFactor);\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "contracts/lending/configuration/LendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Prettier ignore to prevent buidler flatter bug\n// prettier-ignore\nimport {InitializableImmutableAdminUpgradeabilityProxy} from '../libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol';\n\nimport {ILendingPoolAddressesProvider} from \"../../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ncontract LendingPoolAddressesProvider is Ownable, ILendingPoolAddressesProvider {\n\tstring private _marketId;\n\tmapping(bytes32 => address) private _addresses;\n\taddress private _liquidationFeeTo;\n\n\tbytes32 private constant LENDING_POOL = \"LENDING_POOL\";\n\tbytes32 private constant LENDING_POOL_CONFIGURATOR = \"LENDING_POOL_CONFIGURATOR\";\n\tbytes32 private constant POOL_ADMIN = \"POOL_ADMIN\";\n\tbytes32 private constant EMERGENCY_ADMIN = \"EMERGENCY_ADMIN\";\n\tbytes32 private constant LENDING_POOL_COLLATERAL_MANAGER = \"COLLATERAL_MANAGER\";\n\tbytes32 private constant PRICE_ORACLE = \"PRICE_ORACLE\";\n\tbytes32 private constant LENDING_RATE_ORACLE = \"LENDING_RATE_ORACLE\";\n\n\tconstructor(string memory marketId) {\n\t\t_setMarketId(marketId);\n\t\t_liquidationFeeTo = 0xF90C69D16599A5C657A05Fe76Cd22fD9Cab44598;\n\t}\n\n\t/**\n\t * @dev Returns the id of the Aave market to which this contracts points to\n\t * @return The market id\n\t **/\n\tfunction getMarketId() external view returns (string memory) {\n\t\treturn _marketId;\n\t}\n\n\t/**\n\t * @dev Allows to set the market which this LendingPoolAddressesProvider represents\n\t * @param marketId The market id\n\t */\n\tfunction setMarketId(string memory marketId) external onlyOwner {\n\t\t_setMarketId(marketId);\n\t}\n\n\t/**\n\t * @dev General function to update the implementation of a proxy registered with\n\t * certain `id`. If there is no proxy registered, it will instantiate one and\n\t * set as implementation the `implementationAddress`\n\t * IMPORTANT Use this function carefully, only for ids that don't have an explicit\n\t * setter function, in order to avoid unexpected consequences\n\t * @param id The id\n\t * @param implementationAddress The address of the new implementation\n\t */\n\tfunction setAddressAsProxy(bytes32 id, address implementationAddress) external onlyOwner {\n\t\t_updateImpl(id, implementationAddress);\n\t\temit AddressSet(id, implementationAddress, true);\n\t}\n\n\t/**\n\t * @dev Sets an address for an id replacing the address saved in the addresses map\n\t * IMPORTANT Use this function carefully, as it will do a hard replacement\n\t * @param id The id\n\t * @param newAddress The address to set\n\t */\n\tfunction setAddress(bytes32 id, address newAddress) external onlyOwner {\n\t\t_addresses[id] = newAddress;\n\t\temit AddressSet(id, newAddress, false);\n\t}\n\n\t/**\n\t * @dev Returns an address by id\n\t * @return The address\n\t */\n\tfunction getAddress(bytes32 id) public view returns (address) {\n\t\treturn _addresses[id];\n\t}\n\n\t/**\n\t * @dev Returns the address of the LendingPool proxy\n\t * @return The LendingPool proxy address\n\t **/\n\tfunction getLendingPool() external view returns (address) {\n\t\treturn getAddress(LENDING_POOL);\n\t}\n\n\t/**\n\t * @dev Updates the implementation of the LendingPool, or creates the proxy\n\t * setting the new `pool` implementation on the first time calling it\n\t * @param pool The new LendingPool implementation\n\t **/\n\tfunction setLendingPoolImpl(address pool) external onlyOwner {\n\t\t_updateImpl(LENDING_POOL, pool);\n\t\temit LendingPoolUpdated(pool);\n\t}\n\n\t/**\n\t * @dev Returns the address of the LendingPoolConfigurator proxy\n\t * @return The LendingPoolConfigurator proxy address\n\t **/\n\tfunction getLendingPoolConfigurator() external view returns (address) {\n\t\treturn getAddress(LENDING_POOL_CONFIGURATOR);\n\t}\n\n\t/**\n\t * @dev Updates the implementation of the LendingPoolConfigurator, or creates the proxy\n\t * setting the new `configurator` implementation on the first time calling it\n\t * @param configurator The new LendingPoolConfigurator implementation\n\t **/\n\tfunction setLendingPoolConfiguratorImpl(address configurator) external onlyOwner {\n\t\t_updateImpl(LENDING_POOL_CONFIGURATOR, configurator);\n\t\temit LendingPoolConfiguratorUpdated(configurator);\n\t}\n\n\t/**\n\t * @dev Returns the address of the LendingPoolCollateralManager. Since the manager is used\n\t * through delegateCall within the LendingPool contract, the proxy contract pattern does not work properly hence\n\t * the addresses are changed directly\n\t * @return The address of the LendingPoolCollateralManager\n\t **/\n\n\tfunction getLendingPoolCollateralManager() external view returns (address) {\n\t\treturn getAddress(LENDING_POOL_COLLATERAL_MANAGER);\n\t}\n\n\t/**\n\t * @dev Updates the address of the LendingPoolCollateralManager\n\t * @param manager The new LendingPoolCollateralManager address\n\t **/\n\tfunction setLendingPoolCollateralManager(address manager) external onlyOwner {\n\t\t_addresses[LENDING_POOL_COLLATERAL_MANAGER] = manager;\n\t\temit LendingPoolCollateralManagerUpdated(manager);\n\t}\n\n\t/**\n\t * @dev The functions below are getters/setters of addresses that are outside the context\n\t * of the protocol hence the upgradable proxy pattern is not used\n\t **/\n\n\tfunction getPoolAdmin() external view returns (address) {\n\t\treturn getAddress(POOL_ADMIN);\n\t}\n\n\tfunction setPoolAdmin(address admin) external onlyOwner {\n\t\t_addresses[POOL_ADMIN] = admin;\n\t\temit ConfigurationAdminUpdated(admin);\n\t}\n\n\tfunction getEmergencyAdmin() external view returns (address) {\n\t\treturn getAddress(EMERGENCY_ADMIN);\n\t}\n\n\tfunction setEmergencyAdmin(address emergencyAdmin) external onlyOwner {\n\t\t_addresses[EMERGENCY_ADMIN] = emergencyAdmin;\n\t\temit EmergencyAdminUpdated(emergencyAdmin);\n\t}\n\n\tfunction getPriceOracle() external view returns (address) {\n\t\treturn getAddress(PRICE_ORACLE);\n\t}\n\n\tfunction setPriceOracle(address priceOracle) external onlyOwner {\n\t\t_addresses[PRICE_ORACLE] = priceOracle;\n\t\temit PriceOracleUpdated(priceOracle);\n\t}\n\n\tfunction getLendingRateOracle() external view returns (address) {\n\t\treturn getAddress(LENDING_RATE_ORACLE);\n\t}\n\n\tfunction setLendingRateOracle(address lendingRateOracle) external onlyOwner {\n\t\t_addresses[LENDING_RATE_ORACLE] = lendingRateOracle;\n\t\temit LendingRateOracleUpdated(lendingRateOracle);\n\t}\n\n\tfunction getLiquidationFeeTo() external view returns (address) {\n\t\treturn _liquidationFeeTo;\n\t}\n\n\tfunction setLiquidationFeeTo(address liquidationFeeTo) external onlyOwner {\n\t\t_liquidationFeeTo = liquidationFeeTo;\n\t}\n\n\t/**\n\t * @dev Internal function to update the implementation of a specific proxied component of the protocol\n\t * - If there is no proxy registered in the given `id`, it creates the proxy setting `newAdress`\n\t *   as implementation and calls the initialize() function on the proxy\n\t * - If there is already a proxy registered, it just updates the implementation to `newAddress` and\n\t *   calls the initialize() function via upgradeToAndCall() in the proxy\n\t * @param id The id of the proxy to be updated\n\t * @param newAddress The address of the new implementation\n\t **/\n\tfunction _updateImpl(bytes32 id, address newAddress) internal {\n\t\taddress payable proxyAddress = payable(_addresses[id]);\n\n\t\tInitializableImmutableAdminUpgradeabilityProxy proxy = InitializableImmutableAdminUpgradeabilityProxy(\n\t\t\tproxyAddress\n\t\t);\n\t\tbytes memory params = abi.encodeCall(ILendingPool.initialize, ILendingPoolAddressesProvider(address(this)));\n\n\t\tif (proxyAddress == address(0)) {\n\t\t\tproxy = new InitializableImmutableAdminUpgradeabilityProxy(address(this));\n\t\t\tproxy.initialize(newAddress, params);\n\t\t\t_addresses[id] = address(proxy);\n\t\t\temit ProxyCreated(id, address(proxy));\n\t\t} else {\n\t\t\tproxy.upgradeToAndCall(newAddress, params);\n\t\t}\n\t}\n\n\tfunction _setMarketId(string memory marketId) internal {\n\t\t_marketId = marketId;\n\t\temit MarketIdSet(marketId);\n\t}\n}\n"
    },
    "contracts/lending/configuration/LendingPoolAddressesProviderRegistry.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ILendingPoolAddressesProviderRegistry} from \"../../interfaces/ILendingPoolAddressesProviderRegistry.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\n\n/**\n * @title LendingPoolAddressesProviderRegistry contract\n * @dev Main registry of LendingPoolAddressesProvider of multiple Aave protocol's markets\n * - Used for indexing purposes of Aave protocol's markets\n * - The id assigned to a LendingPoolAddressesProvider refers to the market it is connected with,\n *   for example with `0` for the Aave main market and `1` for the next created\n * @author Aave\n **/\ncontract LendingPoolAddressesProviderRegistry is Ownable, ILendingPoolAddressesProviderRegistry {\n\tmapping(address => uint256) private _addressesProviders;\n\taddress[] private _addressesProvidersList;\n\n\t/**\n\t * @dev Returns the list of registered addresses provider\n\t * @return The list of addresses provider, potentially containing address(0) elements\n\t **/\n\tfunction getAddressesProvidersList() external view returns (address[] memory) {\n\t\taddress[] memory addressesProvidersList = _addressesProvidersList;\n\n\t\tuint256 maxLength = addressesProvidersList.length;\n\n\t\taddress[] memory activeProviders = new address[](maxLength);\n\n\t\tfor (uint256 i = 0; i < maxLength; ) {\n\t\t\tif (_addressesProviders[addressesProvidersList[i]] > 0) {\n\t\t\t\tactiveProviders[i] = addressesProvidersList[i];\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\treturn activeProviders;\n\t}\n\n\t/**\n\t * @dev Registers an addresses provider\n\t * @param provider The address of the new LendingPoolAddressesProvider\n\t * @param id The id for the new LendingPoolAddressesProvider, referring to the market it belongs to\n\t **/\n\tfunction registerAddressesProvider(address provider, uint256 id) external onlyOwner {\n\t\trequire(id != 0, Errors.LPAPR_INVALID_ADDRESSES_PROVIDER_ID);\n\n\t\t_addressesProviders[provider] = id;\n\t\t_addToAddressesProvidersList(provider);\n\t\temit AddressesProviderRegistered(provider);\n\t}\n\n\t/**\n\t * @dev Removes a LendingPoolAddressesProvider from the list of registered addresses provider\n\t * @param provider The LendingPoolAddressesProvider address\n\t **/\n\tfunction unregisterAddressesProvider(address provider) external onlyOwner {\n\t\trequire(_addressesProviders[provider] > 0, Errors.LPAPR_PROVIDER_NOT_REGISTERED);\n\t\t_addressesProviders[provider] = 0;\n\t\temit AddressesProviderUnregistered(provider);\n\t}\n\n\t/**\n\t * @dev Returns the id on a registered LendingPoolAddressesProvider\n\t * @return The id or 0 if the LendingPoolAddressesProvider is not registered\n\t */\n\tfunction getAddressesProviderIdByAddress(address addressesProvider) external view returns (uint256) {\n\t\treturn _addressesProviders[addressesProvider];\n\t}\n\n\tfunction _addToAddressesProvidersList(address provider) internal {\n\t\tuint256 providersCount = _addressesProvidersList.length;\n\n\t\tfor (uint256 i = 0; i < providersCount; ) {\n\t\t\tif (_addressesProvidersList[i] == provider) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t_addressesProvidersList.push(provider);\n\t}\n}\n"
    },
    "contracts/lending/flashloan/base/FlashLoanReceiverBase.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IFlashLoanReceiver} from \"../interfaces/IFlashLoanReceiver.sol\";\nimport {ILendingPoolAddressesProvider} from \"../../../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {ILendingPool} from \"../../../interfaces/ILendingPool.sol\";\n\nabstract contract FlashLoanReceiverBase is IFlashLoanReceiver {\n\tusing SafeERC20 for IERC20;\n\tusing SafeMath for uint256;\n\n\tILendingPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n\tILendingPool public immutable LENDING_POOL;\n\n\tconstructor(ILendingPoolAddressesProvider provider) {\n\t\tADDRESSES_PROVIDER = provider;\n\t\tLENDING_POOL = ILendingPool(provider.getLendingPool());\n\t}\n}\n"
    },
    "contracts/lending/flashloan/interfaces/IFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {ILendingPoolAddressesProvider} from \"../../../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {ILendingPool} from \"../../../interfaces/ILendingPool.sol\";\n\n/**\n * @title IFlashLoanReceiver interface\n * @notice Interface for the Aave fee IFlashLoanReceiver.\n * @author Aave\n * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\n **/\ninterface IFlashLoanReceiver {\n\tfunction executeOperation(\n\t\taddress[] calldata assets,\n\t\tuint256[] calldata amounts,\n\t\tuint256[] calldata premiums,\n\t\taddress initiator,\n\t\tbytes calldata params\n\t) external returns (bool);\n\n\tfunction ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider);\n\n\tfunction LENDING_POOL() external view returns (ILendingPool);\n}\n"
    },
    "contracts/lending/lendingpool/DefaultReserveInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IReserveInterestRateStrategy} from \"../../interfaces/IReserveInterestRateStrategy.sol\";\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\nimport {ILendingPoolAddressesProvider} from \"../../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {ILendingRateOracle} from \"../../interfaces/ILendingRateOracle.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title DefaultReserveInterestRateStrategy contract\n * @notice Implements the calculation of the interest rates depending on the reserve state\n * @dev The model of interest rate is based on 2 slopes, one before the `OPTIMAL_UTILIZATION_RATE`\n * point of utilization and another from that one to 100%\n * - An instance of this same contract, can't be used across different Aave markets, due to the caching\n *   of the LendingPoolAddressesProvider\n * @author Aave\n **/\ncontract DefaultReserveInterestRateStrategy is IReserveInterestRateStrategy {\n\tusing WadRayMath for uint256;\n\tusing SafeMath for uint256;\n\tusing PercentageMath for uint256;\n\n\t/**\n\t * @dev this constant represents the utilization rate at which the pool aims to obtain most competitive borrow rates.\n\t * Expressed in ray\n\t **/\n\tuint256 public immutable OPTIMAL_UTILIZATION_RATE;\n\n\t/**\n\t * @dev This constant represents the excess utilization rate above the optimal. It's always equal to\n\t * 1-optimal utilization rate. Added as a constant here for gas optimizations.\n\t * Expressed in ray\n\t **/\n\n\tuint256 public immutable EXCESS_UTILIZATION_RATE;\n\n\tILendingPoolAddressesProvider public immutable addressesProvider;\n\n\t// Base variable borrow rate when Utilization rate = 0. Expressed in ray\n\tuint256 internal immutable _baseVariableBorrowRate;\n\n\t// Slope of the variable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Expressed in ray\n\tuint256 internal immutable _variableRateSlope1;\n\n\t// Slope of the variable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed in ray\n\tuint256 internal immutable _variableRateSlope2;\n\n\t// Slope of the stable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Expressed in ray\n\tuint256 internal immutable _stableRateSlope1;\n\n\t// Slope of the stable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed in ray\n\tuint256 internal immutable _stableRateSlope2;\n\n\tconstructor(\n\t\tILendingPoolAddressesProvider provider,\n\t\tuint256 optimalUtilizationRate_,\n\t\tuint256 baseVariableBorrowRate_,\n\t\tuint256 variableRateSlope1_,\n\t\tuint256 variableRateSlope2_,\n\t\tuint256 stableRateSlope1_,\n\t\tuint256 stableRateSlope2_\n\t) {\n\t\tOPTIMAL_UTILIZATION_RATE = optimalUtilizationRate_;\n\t\tEXCESS_UTILIZATION_RATE = WadRayMath.ray().sub(optimalUtilizationRate_);\n\t\taddressesProvider = provider;\n\t\t_baseVariableBorrowRate = baseVariableBorrowRate_;\n\t\t_variableRateSlope1 = variableRateSlope1_;\n\t\t_variableRateSlope2 = variableRateSlope2_;\n\t\t_stableRateSlope1 = stableRateSlope1_;\n\t\t_stableRateSlope2 = stableRateSlope2_;\n\t}\n\n\tfunction variableRateSlope1() external view returns (uint256) {\n\t\treturn _variableRateSlope1;\n\t}\n\n\tfunction variableRateSlope2() external view returns (uint256) {\n\t\treturn _variableRateSlope2;\n\t}\n\n\tfunction stableRateSlope1() external view returns (uint256) {\n\t\treturn _stableRateSlope1;\n\t}\n\n\tfunction stableRateSlope2() external view returns (uint256) {\n\t\treturn _stableRateSlope2;\n\t}\n\n\tfunction baseVariableBorrowRate() external view returns (uint256) {\n\t\treturn _baseVariableBorrowRate;\n\t}\n\n\tfunction getMaxVariableBorrowRate() external view returns (uint256) {\n\t\treturn _baseVariableBorrowRate.add(_variableRateSlope1).add(_variableRateSlope2);\n\t}\n\n\t/**\n\t * @dev Calculates the interest rates depending on the reserve's state and configurations\n\t * @param reserve The address of the reserve\n\t * @param liquidityAdded The liquidity added during the operation\n\t * @param liquidityTaken The liquidity taken during the operation\n\t * @param totalStableDebt The total borrowed from the reserve a stable rate\n\t * @param totalVariableDebt The total borrowed from the reserve at a variable rate\n\t * @param averageStableBorrowRate The weighted average of all the stable rate loans\n\t * @param reserveFactor The reserve portion of the interest that goes to the treasury of the market\n\t * @return The liquidity rate, the stable borrow rate and the variable borrow rate\n\t **/\n\tfunction calculateInterestRates(\n\t\taddress reserve,\n\t\taddress aToken,\n\t\tuint256 liquidityAdded,\n\t\tuint256 liquidityTaken,\n\t\tuint256 totalStableDebt,\n\t\tuint256 totalVariableDebt,\n\t\tuint256 averageStableBorrowRate,\n\t\tuint256 reserveFactor\n\t) external view returns (uint256, uint256, uint256) {\n\t\tuint256 availableLiquidity = IERC20(reserve).balanceOf(aToken);\n\t\t//avoid stack too deep\n\t\tavailableLiquidity = availableLiquidity.add(liquidityAdded).sub(liquidityTaken);\n\n\t\treturn\n\t\t\tcalculateInterestRates(\n\t\t\t\treserve,\n\t\t\t\tavailableLiquidity,\n\t\t\t\ttotalStableDebt,\n\t\t\t\ttotalVariableDebt,\n\t\t\t\taverageStableBorrowRate,\n\t\t\t\treserveFactor\n\t\t\t);\n\t}\n\n\tstruct CalcInterestRatesLocalVars {\n\t\tuint256 totalDebt;\n\t\tuint256 currentVariableBorrowRate;\n\t\tuint256 currentStableBorrowRate;\n\t\tuint256 currentLiquidityRate;\n\t\tuint256 utilizationRate;\n\t}\n\n\t/**\n\t * @dev Calculates the interest rates depending on the reserve's state and configurations.\n\t * NOTE This function is kept for compatibility with the previous DefaultInterestRateStrategy interface.\n\t * New protocol implementation uses the new calculateInterestRates() interface\n\t * @param reserve The address of the reserve\n\t * @param availableLiquidity The liquidity available in the corresponding aToken\n\t * @param totalStableDebt The total borrowed from the reserve a stable rate\n\t * @param totalVariableDebt The total borrowed from the reserve at a variable rate\n\t * @param averageStableBorrowRate The weighted average of all the stable rate loans\n\t * @param reserveFactor The reserve portion of the interest that goes to the treasury of the market\n\t * @return The liquidity rate, the stable borrow rate and the variable borrow rate\n\t **/\n\tfunction calculateInterestRates(\n\t\taddress reserve,\n\t\tuint256 availableLiquidity,\n\t\tuint256 totalStableDebt,\n\t\tuint256 totalVariableDebt,\n\t\tuint256 averageStableBorrowRate,\n\t\tuint256 reserveFactor\n\t) public view returns (uint256, uint256, uint256) {\n\t\tCalcInterestRatesLocalVars memory vars;\n\n\t\tvars.totalDebt = totalStableDebt.add(totalVariableDebt);\n\t\tvars.currentVariableBorrowRate = 0;\n\t\tvars.currentStableBorrowRate = 0;\n\t\tvars.currentLiquidityRate = 0;\n\n\t\tvars.utilizationRate = vars.totalDebt == 0 ? 0 : vars.totalDebt.rayDiv(availableLiquidity.add(vars.totalDebt));\n\n\t\tvars.currentStableBorrowRate = ILendingRateOracle(addressesProvider.getLendingRateOracle()).getMarketBorrowRate(\n\t\t\treserve\n\t\t);\n\n\t\tif (vars.utilizationRate > OPTIMAL_UTILIZATION_RATE) {\n\t\t\tuint256 excessUtilizationRateRatio = vars.utilizationRate.sub(OPTIMAL_UTILIZATION_RATE).rayDiv(\n\t\t\t\tEXCESS_UTILIZATION_RATE\n\t\t\t);\n\n\t\t\tvars.currentStableBorrowRate = vars.currentStableBorrowRate.add(_stableRateSlope1).add(\n\t\t\t\t_stableRateSlope2.rayMul(excessUtilizationRateRatio)\n\t\t\t);\n\n\t\t\tvars.currentVariableBorrowRate = _baseVariableBorrowRate.add(_variableRateSlope1).add(\n\t\t\t\t_variableRateSlope2.rayMul(excessUtilizationRateRatio)\n\t\t\t);\n\t\t} else {\n\t\t\tvars.currentStableBorrowRate = vars.currentStableBorrowRate.add(\n\t\t\t\t_stableRateSlope1.rayMul(vars.utilizationRate.rayDiv(OPTIMAL_UTILIZATION_RATE))\n\t\t\t);\n\t\t\tvars.currentVariableBorrowRate = _baseVariableBorrowRate.add(\n\t\t\t\tvars.utilizationRate.rayMul(_variableRateSlope1).rayDiv(OPTIMAL_UTILIZATION_RATE)\n\t\t\t);\n\t\t}\n\n\t\tvars.currentLiquidityRate = _getOverallBorrowRate(\n\t\t\ttotalStableDebt,\n\t\t\ttotalVariableDebt,\n\t\t\tvars.currentVariableBorrowRate,\n\t\t\taverageStableBorrowRate\n\t\t).rayMul(vars.utilizationRate).percentMul(PercentageMath.PERCENTAGE_FACTOR.sub(reserveFactor));\n\n\t\treturn (vars.currentLiquidityRate, vars.currentStableBorrowRate, vars.currentVariableBorrowRate);\n\t}\n\n\t/**\n\t * @dev Calculates the overall borrow rate as the weighted average between the total variable debt and total stable debt\n\t * @param totalStableDebt The total borrowed from the reserve a stable rate\n\t * @param totalVariableDebt The total borrowed from the reserve at a variable rate\n\t * @param currentVariableBorrowRate The current variable borrow rate of the reserve\n\t * @param currentAverageStableBorrowRate The current weighted average of all the stable rate loans\n\t * @return The weighted averaged borrow rate\n\t **/\n\tfunction _getOverallBorrowRate(\n\t\tuint256 totalStableDebt,\n\t\tuint256 totalVariableDebt,\n\t\tuint256 currentVariableBorrowRate,\n\t\tuint256 currentAverageStableBorrowRate\n\t) internal pure returns (uint256) {\n\t\tuint256 totalDebt = totalStableDebt.add(totalVariableDebt);\n\n\t\tif (totalDebt == 0) return 0;\n\n\t\tuint256 weightedVariableRate = totalVariableDebt.wadToRay().rayMul(currentVariableBorrowRate);\n\n\t\tuint256 weightedStableRate = totalStableDebt.wadToRay().rayMul(currentAverageStableBorrowRate);\n\n\t\tuint256 overallBorrowRate = weightedVariableRate.add(weightedStableRate).rayDiv(totalDebt.wadToRay());\n\n\t\treturn overallBorrowRate;\n\t}\n}\n"
    },
    "contracts/lending/lendingpool/LendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ILendingPoolAddressesProvider} from \"../../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {ILendingPoolCollateralManager} from \"../../interfaces/ILendingPoolCollateralManager.sol\";\nimport {IAToken} from \"../../interfaces/IAToken.sol\";\nimport {IVariableDebtToken} from \"../../interfaces/IVariableDebtToken.sol\";\nimport {IFlashLoanReceiver} from \"../flashloan/interfaces/IFlashLoanReceiver.sol\";\nimport {IPriceOracleGetter} from \"../../interfaces/IPriceOracleGetter.sol\";\nimport {IStableDebtToken} from \"../../interfaces/IStableDebtToken.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\nimport {ILeverager} from \"../../interfaces/ILeverager.sol\";\nimport {VersionedInitializable} from \"../libraries/aave-upgradeability/VersionedInitializable.sol\";\nimport {Helpers} from \"../libraries/helpers/Helpers.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {UserConfiguration} from \"../libraries/configuration/UserConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendingPoolStorage} from \"./LendingPoolStorage.sol\";\n\n/**\n * @title LendingPool contract\n * @dev Main point of interaction with an Aave protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Swap their loans between variable and stable rate\n *   # Enable/disable their deposits as collateral rebalance stable rate borrow positions\n *   # Liquidate positions\n *   # Execute Flash Loans\n * - To be covered by a proxy contract, owned by the LendingPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendingPoolConfigurator contract defined also in the\n *   LendingPoolAddressesProvider\n * @author Aave\n **/\ncontract LendingPool is VersionedInitializable, ILendingPool, LendingPoolStorage {\n\tusing SafeMath for uint256;\n\tusing WadRayMath for uint256;\n\tusing PercentageMath for uint256;\n\tusing SafeERC20 for IERC20;\n\tusing ReserveLogic for DataTypes.ReserveData;\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\tusing UserConfiguration for DataTypes.UserConfigurationMap;\n\n\tuint256 public constant LENDINGPOOL_REVISION = 0x2;\n\n\tILeverager public leverager;\n\n\taddress public owner;\n\n\tmodifier whenNotPaused() {\n\t\t_whenNotPaused();\n\t\t_;\n\t}\n\n\tmodifier onlyLendingPoolConfigurator() {\n\t\t_onlyLendingPoolConfigurator();\n\t\t_;\n\t}\n\n\tfunction _whenNotPaused() internal view {\n\t\trequire(!_paused, Errors.LP_IS_PAUSED);\n\t}\n\n\tfunction _onlyLendingPoolConfigurator() internal view {\n\t\trequire(\n\t\t\t_addressesProvider.getLendingPoolConfigurator() == msg.sender,\n\t\t\tErrors.LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR\n\t\t);\n\t}\n\n\tfunction getRevision() internal pure override returns (uint256) {\n\t\treturn LENDINGPOOL_REVISION;\n\t}\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @dev Function is invoked by the proxy contract when the LendingPool contract is added to the\n\t * LendingPoolAddressesProvider of the market.\n\t * - Caching the address of the LendingPoolAddressesProvider in order to reduce gas consumption\n\t *   on subsequent operations\n\t * @param provider The address of the LendingPoolAddressesProvider\n\t **/\n\tfunction initialize(ILendingPoolAddressesProvider provider) public override initializer {\n\t\t_addressesProvider = provider;\n\t\t_maxStableRateBorrowSizePercent = 2500;\n\t\t_flashLoanPremiumTotal = 9;\n\t\t_maxNumberOfReserves = 128;\n\t\towner = tx.origin;\n\t}\n\n\t/**\n\t * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n\t * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n\t * @param asset The address of the underlying asset to deposit\n\t * @param amount The amount to be deposited\n\t * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n\t *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n\t *   is a different wallet\n\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n\t *   0 if the action is executed directly by the user, without any middle-man\n\t **/\n\tfunction deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) public whenNotPaused {\n\t\tDataTypes.ReserveData storage reserve = _reserves[asset];\n\n\t\tValidationLogic.validateDeposit(reserve, amount);\n\n\t\taddress aToken = reserve.aTokenAddress;\n\n\t\treserve.updateState();\n\t\treserve.updateInterestRates(asset, aToken, amount, 0);\n\n\t\tIERC20(asset).safeTransferFrom(msg.sender, aToken, amount);\n\n\t\tif (IAToken(aToken).balanceOf(onBehalfOf) == 0) {\n\t\t\t_usersConfig[onBehalfOf].setUsingAsCollateral(reserve.id, true);\n\t\t\temit ReserveUsedAsCollateralEnabled(asset, onBehalfOf);\n\t\t}\n\n\t\tIAToken(aToken).mint(onBehalfOf, amount, reserve.liquidityIndex);\n\n\t\temit Deposit(asset, msg.sender, onBehalfOf, amount, referralCode);\n\t}\n\n\tfunction depositWithAutoDLP(\n\t\taddress asset,\n\t\tuint256 amount,\n\t\taddress onBehalfOf,\n\t\tuint16 referralCode\n\t) external whenNotPaused {\n\t\trequire(tx.origin == onBehalfOf);\n\t\tdeposit(asset, amount, onBehalfOf, referralCode);\n\t\tleverager.zapWETHWithBorrow(leverager.wethToZap(onBehalfOf), onBehalfOf);\n\t}\n\n\t/**\n\t * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n\t * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n\t * @param asset The address of the underlying asset to withdraw\n\t * @param amount The underlying amount to be withdrawn\n\t *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n\t * @param to Address that will receive the underlying, same as msg.sender if the user\n\t *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n\t *   different wallet\n\t * @return The final amount withdrawn\n\t **/\n\tfunction withdraw(address asset, uint256 amount, address to) external whenNotPaused returns (uint256) {\n\t\tDataTypes.ReserveData storage reserve = _reserves[asset];\n\n\t\taddress aToken = reserve.aTokenAddress;\n\n\t\tuint256 userBalance = IAToken(aToken).balanceOf(msg.sender);\n\n\t\tuint256 amountToWithdraw = amount;\n\n\t\tif (amount == type(uint256).max) {\n\t\t\tamountToWithdraw = userBalance;\n\t\t}\n\n\t\tValidationLogic.validateWithdraw(\n\t\t\tasset,\n\t\t\tamountToWithdraw,\n\t\t\tuserBalance,\n\t\t\t_reserves,\n\t\t\t_usersConfig[msg.sender],\n\t\t\t_reservesList,\n\t\t\t_reservesCount,\n\t\t\t_addressesProvider.getPriceOracle()\n\t\t);\n\n\t\treserve.updateState();\n\n\t\treserve.updateInterestRates(asset, aToken, 0, amountToWithdraw);\n\n\t\tif (amountToWithdraw == userBalance) {\n\t\t\t_usersConfig[msg.sender].setUsingAsCollateral(reserve.id, false);\n\t\t\temit ReserveUsedAsCollateralDisabled(asset, msg.sender);\n\t\t}\n\n\t\tIAToken(aToken).burn(msg.sender, to, amountToWithdraw, reserve.liquidityIndex);\n\n\t\temit Withdraw(asset, msg.sender, to, amountToWithdraw);\n\n\t\treturn amountToWithdraw;\n\t}\n\n\t/**\n\t * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n\t * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n\t * corresponding debt token (StableDebtToken or VariableDebtToken)\n\t * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n\t *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n\t * @param asset The address of the underlying asset to borrow\n\t * @param amount The amount to be borrowed\n\t * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n\t *   0 if the action is executed directly by the user, without any middle-man\n\t * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n\t * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n\t * if he has been given credit delegation allowance\n\t **/\n\tfunction borrow(\n\t\taddress asset,\n\t\tuint256 amount,\n\t\tuint256 interestRateMode,\n\t\tuint16 referralCode,\n\t\taddress onBehalfOf\n\t) external whenNotPaused {\n\t\tDataTypes.ReserveData storage reserve = _reserves[asset];\n\n\t\t_executeBorrow(\n\t\t\tExecuteBorrowParams(\n\t\t\t\tasset,\n\t\t\t\tmsg.sender,\n\t\t\t\tonBehalfOf,\n\t\t\t\tamount,\n\t\t\t\tinterestRateMode,\n\t\t\t\treserve.aTokenAddress,\n\t\t\t\treferralCode,\n\t\t\t\ttrue\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n\t * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n\t * @param asset The address of the borrowed underlying asset previously borrowed\n\t * @param amount The amount to repay\n\t * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n\t * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n\t * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n\t * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n\t * other borrower whose debt should be removed\n\t * @return The final amount repaid\n\t **/\n\tfunction repay(\n\t\taddress asset,\n\t\tuint256 amount,\n\t\tuint256 rateMode,\n\t\taddress onBehalfOf\n\t) external whenNotPaused returns (uint256) {\n\t\tDataTypes.ReserveData storage reserve = _reserves[asset];\n\n\t\t(uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(onBehalfOf, reserve);\n\n\t\tDataTypes.InterestRateMode interestRateMode = DataTypes.InterestRateMode(rateMode);\n\n\t\tValidationLogic.validateRepay(reserve, amount, interestRateMode, onBehalfOf, stableDebt, variableDebt);\n\n\t\tuint256 paybackAmount = interestRateMode == DataTypes.InterestRateMode.STABLE ? stableDebt : variableDebt;\n\n\t\tif (amount < paybackAmount) {\n\t\t\tpaybackAmount = amount;\n\t\t}\n\n\t\treserve.updateState();\n\n\t\tif (interestRateMode == DataTypes.InterestRateMode.STABLE) {\n\t\t\tIStableDebtToken(reserve.stableDebtTokenAddress).burn(onBehalfOf, paybackAmount);\n\t\t} else {\n\t\t\tIVariableDebtToken(reserve.variableDebtTokenAddress).burn(\n\t\t\t\tonBehalfOf,\n\t\t\t\tpaybackAmount,\n\t\t\t\treserve.variableBorrowIndex\n\t\t\t);\n\t\t}\n\n\t\taddress aToken = reserve.aTokenAddress;\n\t\treserve.updateInterestRates(asset, aToken, paybackAmount, 0);\n\n\t\tif (stableDebt.add(variableDebt).sub(paybackAmount) == 0) {\n\t\t\t_usersConfig[onBehalfOf].setBorrowing(reserve.id, false);\n\t\t}\n\n\t\tIERC20(asset).safeTransferFrom(msg.sender, aToken, paybackAmount);\n\n\t\tIAToken(aToken).handleRepayment(msg.sender, paybackAmount);\n\n\t\temit Repay(asset, onBehalfOf, msg.sender, paybackAmount);\n\n\t\treturn paybackAmount;\n\t}\n\n\t/**\n\t * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n\t * @param asset The address of the underlying asset borrowed\n\t * @param rateMode The rate mode that the user wants to swap to\n\t **/\n\tfunction swapBorrowRateMode(address asset, uint256 rateMode) external whenNotPaused {\n\t\tDataTypes.ReserveData storage reserve = _reserves[asset];\n\n\t\t(uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(msg.sender, reserve);\n\n\t\tDataTypes.InterestRateMode interestRateMode = DataTypes.InterestRateMode(rateMode);\n\n\t\tValidationLogic.validateSwapRateMode(\n\t\t\treserve,\n\t\t\t_usersConfig[msg.sender],\n\t\t\tstableDebt,\n\t\t\tvariableDebt,\n\t\t\tinterestRateMode\n\t\t);\n\n\t\treserve.updateState();\n\n\t\tif (interestRateMode == DataTypes.InterestRateMode.STABLE) {\n\t\t\tIStableDebtToken(reserve.stableDebtTokenAddress).burn(msg.sender, stableDebt);\n\t\t\tIVariableDebtToken(reserve.variableDebtTokenAddress).mint(\n\t\t\t\tmsg.sender,\n\t\t\t\tmsg.sender,\n\t\t\t\tstableDebt,\n\t\t\t\treserve.variableBorrowIndex\n\t\t\t);\n\t\t} else {\n\t\t\tIVariableDebtToken(reserve.variableDebtTokenAddress).burn(\n\t\t\t\tmsg.sender,\n\t\t\t\tvariableDebt,\n\t\t\t\treserve.variableBorrowIndex\n\t\t\t);\n\t\t\tIStableDebtToken(reserve.stableDebtTokenAddress).mint(\n\t\t\t\tmsg.sender,\n\t\t\t\tmsg.sender,\n\t\t\t\tvariableDebt,\n\t\t\t\treserve.currentStableBorrowRate\n\t\t\t);\n\t\t}\n\n\t\treserve.updateInterestRates(asset, reserve.aTokenAddress, 0, 0);\n\n\t\temit Swap(asset, msg.sender, rateMode);\n\t}\n\n\t/**\n\t * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n\t * - Users can be rebalanced if the following conditions are satisfied:\n\t *     1. Usage ratio is above 95%\n\t *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n\t *        borrowed at a stable rate and depositors are not earning enough\n\t * @param asset The address of the underlying asset borrowed\n\t * @param user The address of the user to be rebalanced\n\t **/\n\tfunction rebalanceStableBorrowRate(address asset, address user) external whenNotPaused {\n\t\tDataTypes.ReserveData storage reserve = _reserves[asset];\n\n\t\tIERC20 stableDebtToken = IERC20(reserve.stableDebtTokenAddress);\n\t\tIERC20 variableDebtToken = IERC20(reserve.variableDebtTokenAddress);\n\t\taddress aTokenAddress = reserve.aTokenAddress;\n\n\t\tuint256 stableDebt = IERC20(stableDebtToken).balanceOf(user);\n\n\t\tValidationLogic.validateRebalanceStableBorrowRate(\n\t\t\treserve,\n\t\t\tasset,\n\t\t\tstableDebtToken,\n\t\t\tvariableDebtToken,\n\t\t\taTokenAddress\n\t\t);\n\n\t\treserve.updateState();\n\n\t\tIStableDebtToken(address(stableDebtToken)).burn(user, stableDebt);\n\t\tIStableDebtToken(address(stableDebtToken)).mint(user, user, stableDebt, reserve.currentStableBorrowRate);\n\n\t\treserve.updateInterestRates(asset, aTokenAddress, 0, 0);\n\n\t\temit RebalanceStableBorrowRate(asset, user);\n\t}\n\n\t/**\n\t * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n\t * @param asset The address of the underlying asset deposited\n\t * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n\t **/\n\tfunction setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external whenNotPaused {\n\t\tDataTypes.ReserveData storage reserve = _reserves[asset];\n\n\t\tValidationLogic.validateSetUseReserveAsCollateral(\n\t\t\treserve,\n\t\t\tasset,\n\t\t\tuseAsCollateral,\n\t\t\t_reserves,\n\t\t\t_usersConfig[msg.sender],\n\t\t\t_reservesList,\n\t\t\t_reservesCount,\n\t\t\t_addressesProvider.getPriceOracle()\n\t\t);\n\n\t\t_usersConfig[msg.sender].setUsingAsCollateral(reserve.id, useAsCollateral);\n\n\t\tif (useAsCollateral) {\n\t\t\temit ReserveUsedAsCollateralEnabled(asset, msg.sender);\n\t\t} else {\n\t\t\temit ReserveUsedAsCollateralDisabled(asset, msg.sender);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n\t * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n\t *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n\t * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n\t * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n\t * @param user The address of the borrower getting liquidated\n\t * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n\t * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n\t * to receive the underlying collateral asset directly\n\t **/\n\tfunction liquidationCall(\n\t\taddress collateralAsset,\n\t\taddress debtAsset,\n\t\taddress user,\n\t\tuint256 debtToCover,\n\t\tbool receiveAToken\n\t) external whenNotPaused {\n\t\taddress collateralManager = _addressesProvider.getLendingPoolCollateralManager();\n\t\taddress liquidationFeeTo = _addressesProvider.getLiquidationFeeTo();\n\t\tif (liquidationFeeTo == address(0)) {\n\t\t\tliquidationFeeTo = msg.sender;\n\t\t}\n\n\t\t//solium-disable-next-line\n\t\t(bool success, bytes memory result) = collateralManager.delegatecall(\n\t\t\tabi.encodeCall(\n\t\t\t\tILendingPoolCollateralManager.liquidationCall,\n\t\t\t\t(collateralAsset, debtAsset, user, debtToCover, receiveAToken, liquidationFeeTo)\n\t\t\t)\n\t\t);\n\n\t\trequire(success, Errors.LP_LIQUIDATION_CALL_FAILED);\n\n\t\t(uint256 returnCode, string memory returnMessage) = abi.decode(result, (uint256, string));\n\n\t\trequire(returnCode == 0, string(abi.encodePacked(returnMessage)));\n\t}\n\n\tstruct FlashLoanLocalVars {\n\t\tIFlashLoanReceiver receiver;\n\t\taddress oracle;\n\t\tuint256 i;\n\t\taddress currentAsset;\n\t\taddress currentATokenAddress;\n\t\tuint256 currentAmount;\n\t\tuint256 currentPremium;\n\t\tuint256 currentAmountPlusPremium;\n\t\taddress debtToken;\n\t}\n\n\t/**\n\t * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n\t * as long as the amount taken plus a fee is returned.\n\t * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n\t * For further details please visit https://developers.aave.com\n\t * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n\t * @param assets The addresses of the assets being flash-borrowed\n\t * @param amounts The amounts amounts being flash-borrowed\n\t * @param modes Types of the debt to open if the flash loan is not returned:\n\t *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n\t *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n\t *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n\t * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n\t * @param params Variadic packed params to pass to the receiver as extra information\n\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n\t *   0 if the action is executed directly by the user, without any middle-man\n\t **/\n\tfunction flashLoan(\n\t\taddress receiverAddress,\n\t\taddress[] calldata assets,\n\t\tuint256[] calldata amounts,\n\t\tuint256[] calldata modes,\n\t\taddress onBehalfOf,\n\t\tbytes calldata params,\n\t\tuint16 referralCode\n\t) external whenNotPaused {\n\t\tFlashLoanLocalVars memory vars;\n\n\t\tValidationLogic.validateFlashloan(assets, amounts);\n\n\t\taddress[] memory aTokenAddresses = new address[](assets.length);\n\t\tuint256[] memory premiums = new uint256[](assets.length);\n\n\t\tvars.receiver = IFlashLoanReceiver(receiverAddress);\n\n\t\tfor (vars.i = 0; vars.i < assets.length; ) {\n\t\t\taTokenAddresses[vars.i] = _reserves[assets[vars.i]].aTokenAddress;\n\n\t\t\tpremiums[vars.i] = amounts[vars.i].mul(_flashLoanPremiumTotal).div(10000);\n\n\t\t\tIAToken(aTokenAddresses[vars.i]).transferUnderlyingTo(receiverAddress, amounts[vars.i]);\n\t\t\tunchecked {\n\t\t\t\tvars.i++;\n\t\t\t}\n\t\t}\n\n\t\trequire(\n\t\t\tvars.receiver.executeOperation(assets, amounts, premiums, msg.sender, params),\n\t\t\tErrors.LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN\n\t\t);\n\n\t\tfor (vars.i = 0; vars.i < assets.length; ) {\n\t\t\tvars.currentAsset = assets[vars.i];\n\t\t\tvars.currentAmount = amounts[vars.i];\n\t\t\tvars.currentPremium = premiums[vars.i];\n\t\t\tvars.currentATokenAddress = aTokenAddresses[vars.i];\n\t\t\tvars.currentAmountPlusPremium = vars.currentAmount.add(vars.currentPremium);\n\n\t\t\tif (DataTypes.InterestRateMode(modes[vars.i]) == DataTypes.InterestRateMode.NONE) {\n\t\t\t\t_reserves[vars.currentAsset].updateState();\n\t\t\t\t_reserves[vars.currentAsset].cumulateToLiquidityIndex(\n\t\t\t\t\tIERC20(vars.currentATokenAddress).totalSupply(),\n\t\t\t\t\tvars.currentPremium\n\t\t\t\t);\n\t\t\t\t_reserves[vars.currentAsset].updateInterestRates(\n\t\t\t\t\tvars.currentAsset,\n\t\t\t\t\tvars.currentATokenAddress,\n\t\t\t\t\tvars.currentAmountPlusPremium,\n\t\t\t\t\t0\n\t\t\t\t);\n\n\t\t\t\tIERC20(vars.currentAsset).safeTransferFrom(\n\t\t\t\t\treceiverAddress,\n\t\t\t\t\tvars.currentATokenAddress,\n\t\t\t\t\tvars.currentAmountPlusPremium\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// If the user chose to not return the funds, the system checks if there is enough collateral and\n\t\t\t\t// eventually opens a debt position\n\t\t\t\t_executeBorrow(\n\t\t\t\t\tExecuteBorrowParams(\n\t\t\t\t\t\tvars.currentAsset,\n\t\t\t\t\t\tmsg.sender,\n\t\t\t\t\t\tonBehalfOf,\n\t\t\t\t\t\tvars.currentAmount,\n\t\t\t\t\t\tmodes[vars.i],\n\t\t\t\t\t\tvars.currentATokenAddress,\n\t\t\t\t\t\treferralCode,\n\t\t\t\t\t\tfalse\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\temit FlashLoan(\n\t\t\t\treceiverAddress,\n\t\t\t\tmsg.sender,\n\t\t\t\tvars.currentAsset,\n\t\t\t\tvars.currentAmount,\n\t\t\t\tvars.currentPremium,\n\t\t\t\treferralCode\n\t\t\t);\n\t\t\tunchecked {\n\t\t\t\tvars.i++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the state and configuration of the reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The state of the reserve\n\t **/\n\tfunction getReserveData(address asset) external view returns (DataTypes.ReserveData memory) {\n\t\treturn _reserves[asset];\n\t}\n\n\t/**\n\t * @dev Returns the user account data across all the reserves\n\t * @param user The address of the user\n\t * @return totalCollateralETH the total collateral in ETH of the user\n\t * @return totalDebtETH the total debt in ETH of the user\n\t * @return availableBorrowsETH the borrowing power left of the user\n\t * @return currentLiquidationThreshold the liquidation threshold of the user\n\t * @return ltv the loan to value of the user\n\t * @return healthFactor the current health factor of the user\n\t **/\n\tfunction getUserAccountData(\n\t\taddress user\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 totalCollateralETH,\n\t\t\tuint256 totalDebtETH,\n\t\t\tuint256 availableBorrowsETH,\n\t\t\tuint256 currentLiquidationThreshold,\n\t\t\tuint256 ltv,\n\t\t\tuint256 healthFactor\n\t\t)\n\t{\n\t\t(totalCollateralETH, totalDebtETH, ltv, currentLiquidationThreshold, healthFactor) = GenericLogic\n\t\t\t.calculateUserAccountData(\n\t\t\t\tuser,\n\t\t\t\t_reserves,\n\t\t\t\t_usersConfig[user],\n\t\t\t\t_reservesList,\n\t\t\t\t_reservesCount,\n\t\t\t\t_addressesProvider.getPriceOracle()\n\t\t\t);\n\n\t\tavailableBorrowsETH = GenericLogic.calculateAvailableBorrowsETH(totalCollateralETH, totalDebtETH, ltv);\n\t}\n\n\t/**\n\t * @dev Returns the configuration of the reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The configuration of the reserve\n\t **/\n\tfunction getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory) {\n\t\treturn _reserves[asset].configuration;\n\t}\n\n\t/**\n\t * @dev Returns the configuration of the user across all the reserves\n\t * @param user The user address\n\t * @return The configuration of the user\n\t **/\n\tfunction getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory) {\n\t\treturn _usersConfig[user];\n\t}\n\n\t/**\n\t * @dev Returns the normalized income per unit of asset\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The reserve's normalized income\n\t */\n\tfunction getReserveNormalizedIncome(address asset) external view virtual returns (uint256) {\n\t\treturn _reserves[asset].getNormalizedIncome();\n\t}\n\n\t/**\n\t * @dev Returns the normalized variable debt per unit of asset\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The reserve normalized variable debt\n\t */\n\tfunction getReserveNormalizedVariableDebt(address asset) external view returns (uint256) {\n\t\treturn _reserves[asset].getNormalizedDebt();\n\t}\n\n\t/**\n\t * @dev Returns if the LendingPool is paused\n\t */\n\tfunction paused() external view returns (bool) {\n\t\treturn _paused;\n\t}\n\n\t/**\n\t * @dev Returns the list of the initialized reserves\n\t **/\n\tfunction getReservesList() external view returns (address[] memory) {\n\t\taddress[] memory _activeReserves = new address[](_reservesCount);\n\n\t\tfor (uint256 i = 0; i < _reservesCount; ) {\n\t\t\t_activeReserves[i] = _reservesList[i];\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn _activeReserves;\n\t}\n\n\t/**\n\t * @dev Returns the cached LendingPoolAddressesProvider connected to this contract\n\t **/\n\tfunction getAddressesProvider() external view returns (ILendingPoolAddressesProvider) {\n\t\treturn _addressesProvider;\n\t}\n\n\t/**\n\t * @dev Returns the percentage of available liquidity that can be borrowed at once at stable rate\n\t */\n\tfunction MAX_STABLE_RATE_BORROW_SIZE_PERCENT() public view returns (uint256) {\n\t\treturn _maxStableRateBorrowSizePercent;\n\t}\n\n\t/**\n\t * @dev Returns the fee on flash loans\n\t */\n\tfunction FLASHLOAN_PREMIUM_TOTAL() public view returns (uint256) {\n\t\treturn _flashLoanPremiumTotal;\n\t}\n\n\t/**\n\t * @dev Returns the maximum number of reserves supported to be listed in this LendingPool\n\t */\n\tfunction MAX_NUMBER_RESERVES() public view returns (uint256) {\n\t\treturn _maxNumberOfReserves;\n\t}\n\n\t/**\n\t * @dev Validates and finalizes an aToken transfer\n\t * - Only callable by the overlying aToken of the `asset`\n\t * @param asset The address of the underlying asset of the aToken\n\t * @param from The user from which the aTokens are transferred\n\t * @param to The user receiving the aTokens\n\t * @param amount The amount being transferred/withdrawn\n\t * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n\t * @param balanceToBefore The aToken balance of the `to` user before the transfer\n\t */\n\tfunction finalizeTransfer(\n\t\taddress asset,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount,\n\t\tuint256 balanceFromBefore,\n\t\tuint256 balanceToBefore\n\t) external whenNotPaused {\n\t\trequire(msg.sender == _reserves[asset].aTokenAddress, Errors.LP_CALLER_MUST_BE_AN_ATOKEN);\n\n\t\tValidationLogic.validateTransfer(\n\t\t\tfrom,\n\t\t\t_reserves,\n\t\t\t_usersConfig[from],\n\t\t\t_reservesList,\n\t\t\t_reservesCount,\n\t\t\t_addressesProvider.getPriceOracle()\n\t\t);\n\n\t\tuint256 reserveId = _reserves[asset].id;\n\n\t\tif (from != to) {\n\t\t\tif (balanceFromBefore.sub(amount) == 0) {\n\t\t\t\tDataTypes.UserConfigurationMap storage fromConfig = _usersConfig[from];\n\t\t\t\tfromConfig.setUsingAsCollateral(reserveId, false);\n\t\t\t\temit ReserveUsedAsCollateralDisabled(asset, from);\n\t\t\t}\n\n\t\t\tif (balanceToBefore == 0 && amount != 0) {\n\t\t\t\tDataTypes.UserConfigurationMap storage toConfig = _usersConfig[to];\n\t\t\t\ttoConfig.setUsingAsCollateral(reserveId, true);\n\t\t\t\temit ReserveUsedAsCollateralEnabled(asset, to);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @dev Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n\t * interest rate strategy\n\t * - Only callable by the LendingPoolConfigurator contract\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n\t * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n\t * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n\t * @param interestRateStrategyAddress The address of the interest rate strategy contract\n\t **/\n\tfunction initReserve(\n\t\taddress asset,\n\t\taddress aTokenAddress,\n\t\taddress stableDebtAddress,\n\t\taddress variableDebtAddress,\n\t\taddress interestRateStrategyAddress\n\t) external onlyLendingPoolConfigurator {\n\t\trequire(Address.isContract(asset), Errors.LP_NOT_CONTRACT);\n\t\t_reserves[asset].init(aTokenAddress, stableDebtAddress, variableDebtAddress, interestRateStrategyAddress);\n\t\t_addReserveToList(asset);\n\t}\n\n\t/**\n\t * @dev Updates the address of the interest rate strategy contract\n\t * - Only callable by the LendingPoolConfigurator contract\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param rateStrategyAddress The address of the interest rate strategy contract\n\t **/\n\tfunction setReserveInterestRateStrategyAddress(\n\t\taddress asset,\n\t\taddress rateStrategyAddress\n\t) external onlyLendingPoolConfigurator {\n\t\t_reserves[asset].interestRateStrategyAddress = rateStrategyAddress;\n\t}\n\n\t/**\n\t * @dev Sets the configuration bitmap of the reserve as a whole\n\t * - Only callable by the LendingPoolConfigurator contract\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param configuration The new configuration bitmap\n\t **/\n\tfunction setConfiguration(address asset, uint256 configuration) external onlyLendingPoolConfigurator {\n\t\t_reserves[asset].configuration.data = configuration;\n\t}\n\n\t/**\n\t * @dev Set the _pause state of a reserve\n\t * - Only callable by the LendingPoolConfigurator contract\n\t * @param val `true` to pause the reserve, `false` to un-pause it\n\t */\n\tfunction setPause(bool val) external onlyLendingPoolConfigurator {\n\t\t_paused = val;\n\t\tif (_paused) {\n\t\t\temit Paused();\n\t\t} else {\n\t\t\temit Unpaused();\n\t\t}\n\t}\n\n\tstruct ExecuteBorrowParams {\n\t\taddress asset;\n\t\taddress user;\n\t\taddress onBehalfOf;\n\t\tuint256 amount;\n\t\tuint256 interestRateMode;\n\t\taddress aTokenAddress;\n\t\tuint16 referralCode;\n\t\tbool releaseUnderlying;\n\t}\n\n\tfunction _executeBorrow(ExecuteBorrowParams memory vars) internal {\n\t\tDataTypes.ReserveData storage reserve = _reserves[vars.asset];\n\t\tDataTypes.UserConfigurationMap storage userConfig = _usersConfig[vars.onBehalfOf];\n\n\t\taddress oracle = _addressesProvider.getPriceOracle();\n\n\t\tuint256 amountInETH = IPriceOracleGetter(oracle).getAssetPrice(vars.asset).mul(vars.amount).div(\n\t\t\t10 ** reserve.configuration.getDecimals()\n\t\t);\n\n\t\tValidationLogic.validateBorrow(\n\t\t\tvars.asset,\n\t\t\treserve,\n\t\t\tvars.onBehalfOf,\n\t\t\tvars.amount,\n\t\t\tamountInETH,\n\t\t\tvars.interestRateMode,\n\t\t\t_maxStableRateBorrowSizePercent,\n\t\t\t_reserves,\n\t\t\tuserConfig,\n\t\t\t_reservesList,\n\t\t\t_reservesCount,\n\t\t\toracle\n\t\t);\n\n\t\treserve.updateState();\n\n\t\tuint256 currentStableRate = 0;\n\n\t\tbool isFirstBorrowing = false;\n\t\tif (DataTypes.InterestRateMode(vars.interestRateMode) == DataTypes.InterestRateMode.STABLE) {\n\t\t\tcurrentStableRate = reserve.currentStableBorrowRate;\n\n\t\t\tisFirstBorrowing = IStableDebtToken(reserve.stableDebtTokenAddress).mint(\n\t\t\t\tvars.user,\n\t\t\t\tvars.onBehalfOf,\n\t\t\t\tvars.amount,\n\t\t\t\tcurrentStableRate\n\t\t\t);\n\t\t} else {\n\t\t\tisFirstBorrowing = IVariableDebtToken(reserve.variableDebtTokenAddress).mint(\n\t\t\t\tvars.user,\n\t\t\t\tvars.onBehalfOf,\n\t\t\t\tvars.amount,\n\t\t\t\treserve.variableBorrowIndex\n\t\t\t);\n\t\t}\n\n\t\tif (isFirstBorrowing) {\n\t\t\tuserConfig.setBorrowing(reserve.id, true);\n\t\t}\n\n\t\treserve.updateInterestRates(vars.asset, vars.aTokenAddress, 0, vars.releaseUnderlying ? vars.amount : 0);\n\n\t\tif (vars.releaseUnderlying) {\n\t\t\tIAToken(vars.aTokenAddress).transferUnderlyingTo(vars.user, vars.amount);\n\t\t}\n\n\t\temit Borrow(\n\t\t\tvars.asset,\n\t\t\tvars.user,\n\t\t\tvars.onBehalfOf,\n\t\t\tvars.amount,\n\t\t\tvars.interestRateMode,\n\t\t\tDataTypes.InterestRateMode(vars.interestRateMode) == DataTypes.InterestRateMode.STABLE\n\t\t\t\t? currentStableRate\n\t\t\t\t: reserve.currentVariableBorrowRate,\n\t\t\tvars.referralCode\n\t\t);\n\t}\n\n\tfunction _addReserveToList(address asset) internal {\n\t\tuint256 reservesCount = _reservesCount;\n\n\t\trequire(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n\t\tbool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n\t\tif (!reserveAlreadyAdded) {\n\t\t\t_reserves[asset].id = uint8(reservesCount);\n\t\t\t_reservesList[reservesCount] = asset;\n\n\t\t\t_reservesCount = reservesCount + 1;\n\t\t}\n\t}\n\n\tfunction setLeverager(ILeverager _leverager) external {\n\t\trequire(msg.sender == owner, \"!owner\");\n\t\trequire(address(leverager) == address(0), \"Leverager Already Set\");\n\t\tleverager = _leverager;\n\t}\n\n\tfunction setNewOwner(address _newOwner) external {\n\t\trequire(msg.sender == owner, \"!owner\");\n\t\towner = _newOwner;\n\t}\n}\n"
    },
    "contracts/lending/lendingpool/LendingPoolCollateralManager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IAToken} from \"../../interfaces/IAToken.sol\";\nimport {IStableDebtToken} from \"../../interfaces/IStableDebtToken.sol\";\nimport {IVariableDebtToken} from \"../../interfaces/IVariableDebtToken.sol\";\nimport {IPriceOracleGetter} from \"../../interfaces/IPriceOracleGetter.sol\";\nimport {ILendingPoolCollateralManager} from \"../../interfaces/ILendingPoolCollateralManager.sol\";\nimport {VersionedInitializable} from \"../libraries/aave-upgradeability/VersionedInitializable.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {Helpers} from \"../libraries/helpers/Helpers.sol\";\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendingPoolStorage} from \"./LendingPoolStorage.sol\";\nimport {UserConfiguration} from \"../libraries/configuration/UserConfiguration.sol\";\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\n\n/**\n * @title LendingPoolCollateralManager contract\n * @author Aave\n * @dev Implements actions involving management of collateral in the protocol, the main one being the liquidations\n * IMPORTANT This contract will run always via DELEGATECALL, through the LendingPool, so the chain of inheritance\n * is the same as the LendingPool, to have compatible storage layouts\n **/\ncontract LendingPoolCollateralManager is ILendingPoolCollateralManager, VersionedInitializable, LendingPoolStorage {\n\tusing SafeERC20 for IERC20;\n\tusing SafeMath for uint256;\n\tusing WadRayMath for uint256;\n\tusing PercentageMath for uint256;\n\tusing ReserveLogic for DataTypes.ReserveData;\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\tusing UserConfiguration for DataTypes.UserConfigurationMap;\n\n\tuint256 internal constant LIQUIDATION_CLOSE_FACTOR_PERCENT = 5000;\n\n\tstruct LiquidationCallLocalVars {\n\t\tuint256 userCollateralBalance;\n\t\tuint256 userStableDebt;\n\t\tuint256 userVariableDebt;\n\t\tuint256 maxLiquidatableDebt;\n\t\tuint256 actualDebtToLiquidate;\n\t\tuint256 liquidationRatio;\n\t\tuint256 maxAmountCollateralToLiquidate;\n\t\tuint256 userStableRate;\n\t\tuint256 maxCollateralToLiquidate;\n\t\tuint256 liquidationFee;\n\t\tuint256 debtAmountNeeded;\n\t\tuint256 healthFactor;\n\t\tuint256 liquidatorPreviousATokenBalance;\n\t\tIAToken collateralAtoken;\n\t\tbool isCollateralEnabled;\n\t\tDataTypes.InterestRateMode borrowRateMode;\n\t\tuint256 errorCode;\n\t\tstring errorMsg;\n\t}\n\n\t/**\n\t * @dev As thIS contract extends the VersionedInitializable contract to match the state\n\t * of the LendingPool contract, the getRevision() function is needed, but the value is not\n\t * important, as the initialize() function will never be called here\n\t */\n\tfunction getRevision() internal pure override returns (uint256) {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * @dev Function to liquidate a position if its Health Factor drops below 1\n\t * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n\t *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n\t * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n\t * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n\t * @param user The address of the borrower getting liquidated\n\t * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n\t * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n\t * to receive the underlying collateral asset directly\n\t **/\n\tfunction liquidationCall(\n\t\taddress collateralAsset,\n\t\taddress debtAsset,\n\t\taddress user,\n\t\tuint256 debtToCover,\n\t\tbool receiveAToken,\n\t\taddress liquidationFeeTo\n\t) external override returns (uint256, string memory) {\n\t\tDataTypes.ReserveData storage collateralReserve = _reserves[collateralAsset];\n\t\tDataTypes.ReserveData storage debtReserve = _reserves[debtAsset];\n\t\tDataTypes.UserConfigurationMap storage userConfig = _usersConfig[user];\n\n\t\tLiquidationCallLocalVars memory vars;\n\n\t\t(, , , , vars.healthFactor) = GenericLogic.calculateUserAccountData(\n\t\t\tuser,\n\t\t\t_reserves,\n\t\t\tuserConfig,\n\t\t\t_reservesList,\n\t\t\t_reservesCount,\n\t\t\t_addressesProvider.getPriceOracle()\n\t\t);\n\n\t\t(vars.userStableDebt, vars.userVariableDebt) = Helpers.getUserCurrentDebt(user, debtReserve);\n\n\t\t(vars.errorCode, vars.errorMsg) = ValidationLogic.validateLiquidationCall(\n\t\t\tcollateralReserve,\n\t\t\tdebtReserve,\n\t\t\tuserConfig,\n\t\t\tvars.healthFactor,\n\t\t\tvars.userStableDebt,\n\t\t\tvars.userVariableDebt\n\t\t);\n\n\t\tif (Errors.CollateralManagerErrors(vars.errorCode) != Errors.CollateralManagerErrors.NO_ERROR) {\n\t\t\treturn (vars.errorCode, vars.errorMsg);\n\t\t}\n\n\t\tvars.collateralAtoken = IAToken(collateralReserve.aTokenAddress);\n\n\t\tvars.userCollateralBalance = vars.collateralAtoken.balanceOf(user);\n\n\t\tvars.maxLiquidatableDebt = vars.userStableDebt.add(vars.userVariableDebt).percentMul(\n\t\t\tLIQUIDATION_CLOSE_FACTOR_PERCENT\n\t\t);\n\n\t\tvars.actualDebtToLiquidate = debtToCover > vars.maxLiquidatableDebt ? vars.maxLiquidatableDebt : debtToCover;\n\n\t\t(\n\t\t\tvars.maxCollateralToLiquidate,\n\t\t\tvars.liquidationFee,\n\t\t\tvars.debtAmountNeeded\n\t\t) = _calculateAvailableCollateralToLiquidate(\n\t\t\tcollateralReserve,\n\t\t\tdebtReserve,\n\t\t\tcollateralAsset,\n\t\t\tdebtAsset,\n\t\t\tvars.actualDebtToLiquidate,\n\t\t\tvars.userCollateralBalance\n\t\t);\n\n\t\t// If debtAmountNeeded < actualDebtToLiquidate, there isn't enough\n\t\t// collateral to cover the actual amount that is being liquidated, hence we liquidate\n\t\t// a smaller amount\n\n\t\tif (vars.debtAmountNeeded < vars.actualDebtToLiquidate) {\n\t\t\tvars.actualDebtToLiquidate = vars.debtAmountNeeded;\n\t\t}\n\n\t\t// If the liquidator reclaims the underlying asset, we make sure there is enough available liquidity in the\n\t\t// collateral reserve\n\t\tif (!receiveAToken) {\n\t\t\tuint256 currentAvailableCollateral = IERC20(collateralAsset).balanceOf(address(vars.collateralAtoken));\n\t\t\tif (currentAvailableCollateral < vars.maxCollateralToLiquidate) {\n\t\t\t\treturn (\n\t\t\t\t\tuint256(Errors.CollateralManagerErrors.NOT_ENOUGH_LIQUIDITY),\n\t\t\t\t\tErrors.LPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tdebtReserve.updateState();\n\n\t\tif (vars.userVariableDebt >= vars.actualDebtToLiquidate) {\n\t\t\tIVariableDebtToken(debtReserve.variableDebtTokenAddress).burn(\n\t\t\t\tuser,\n\t\t\t\tvars.actualDebtToLiquidate,\n\t\t\t\tdebtReserve.variableBorrowIndex\n\t\t\t);\n\t\t} else {\n\t\t\t// If the user doesn't have variable debt, no need to try to burn variable debt tokens\n\t\t\tif (vars.userVariableDebt > 0) {\n\t\t\t\tIVariableDebtToken(debtReserve.variableDebtTokenAddress).burn(\n\t\t\t\t\tuser,\n\t\t\t\t\tvars.userVariableDebt,\n\t\t\t\t\tdebtReserve.variableBorrowIndex\n\t\t\t\t);\n\t\t\t}\n\t\t\tIStableDebtToken(debtReserve.stableDebtTokenAddress).burn(\n\t\t\t\tuser,\n\t\t\t\tvars.actualDebtToLiquidate.sub(vars.userVariableDebt)\n\t\t\t);\n\t\t}\n\n\t\tdebtReserve.updateInterestRates(debtAsset, debtReserve.aTokenAddress, vars.actualDebtToLiquidate, 0);\n\n\t\tif (receiveAToken) {\n\t\t\tvars.liquidatorPreviousATokenBalance = IERC20(vars.collateralAtoken).balanceOf(msg.sender);\n\t\t\tvars.collateralAtoken.transferOnLiquidation(\n\t\t\t\tuser,\n\t\t\t\tmsg.sender,\n\t\t\t\tvars.maxCollateralToLiquidate.sub(vars.liquidationFee)\n\t\t\t);\n\t\t\tvars.collateralAtoken.transferOnLiquidation(user, liquidationFeeTo, vars.liquidationFee);\n\n\t\t\tif (vars.liquidatorPreviousATokenBalance == 0) {\n\t\t\t\tDataTypes.UserConfigurationMap storage liquidatorConfig = _usersConfig[msg.sender];\n\t\t\t\tliquidatorConfig.setUsingAsCollateral(collateralReserve.id, true);\n\t\t\t\temit ReserveUsedAsCollateralEnabled(collateralAsset, msg.sender);\n\t\t\t}\n\t\t} else {\n\t\t\tcollateralReserve.updateState();\n\t\t\tcollateralReserve.updateInterestRates(\n\t\t\t\tcollateralAsset,\n\t\t\t\taddress(vars.collateralAtoken),\n\t\t\t\t0,\n\t\t\t\tvars.maxCollateralToLiquidate\n\t\t\t);\n\n\t\t\t// Burn the equivalent amount of aToken, sending the underlying to the liquidator\n\t\t\tvars.collateralAtoken.burn(\n\t\t\t\tuser,\n\t\t\t\tmsg.sender,\n\t\t\t\tvars.maxCollateralToLiquidate.sub(vars.liquidationFee),\n\t\t\t\tcollateralReserve.liquidityIndex\n\t\t\t);\n\t\t\tvars.collateralAtoken.burn(user, liquidationFeeTo, vars.liquidationFee, collateralReserve.liquidityIndex);\n\t\t}\n\n\t\t// If the collateral being liquidated is equal to the user balance,\n\t\t// we set the currency as not being used as collateral anymore\n\t\tif (vars.maxCollateralToLiquidate == vars.userCollateralBalance) {\n\t\t\tuserConfig.setUsingAsCollateral(collateralReserve.id, false);\n\t\t\temit ReserveUsedAsCollateralDisabled(collateralAsset, user);\n\t\t}\n\n\t\t// Transfers the debt asset being repaid to the aToken, where the liquidity is kept\n\t\tIERC20(debtAsset).safeTransferFrom(msg.sender, debtReserve.aTokenAddress, vars.actualDebtToLiquidate);\n\n\t\temit LiquidationCall(\n\t\t\tcollateralAsset,\n\t\t\tdebtAsset,\n\t\t\tuser,\n\t\t\tvars.actualDebtToLiquidate,\n\t\t\tvars.maxCollateralToLiquidate,\n\t\t\tmsg.sender,\n\t\t\treceiveAToken,\n\t\t\tliquidationFeeTo\n\t\t);\n\n\t\treturn (uint256(Errors.CollateralManagerErrors.NO_ERROR), Errors.LPCM_NO_ERRORS);\n\t}\n\n\tstruct AvailableCollateralToLiquidateLocalVars {\n\t\tuint256 userCompoundedBorrowBalance;\n\t\tuint256 liquidationBonus;\n\t\tuint256 collateralPrice;\n\t\tuint256 debtAssetPrice;\n\t\tuint256 maxAmountCollateralToLiquidate;\n\t\tuint256 debtAssetDecimals;\n\t\tuint256 collateralDecimals;\n\t}\n\n\t/**\n\t * @dev Calculates how much of a specific collateral can be liquidated, given\n\t * a certain amount of debt asset.\n\t * - This function needs to be called after all the checks to validate the liquidation have been performed,\n\t *   otherwise it might fail.\n\t * @param collateralReserve The data of the collateral reserve\n\t * @param debtReserve The data of the debt reserve\n\t * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n\t * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n\t * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n\t * @param userCollateralBalance The collateral balance for the specific `collateralAsset` of the user being liquidated\n\t * @return collateralAmount: The maximum amount that is possible to liquidate given all the liquidation constraints\n\t *                           (user balance, close factor)\n\t *         debtAmountNeeded: The amount to repay with the liquidation\n\t **/\n\tfunction _calculateAvailableCollateralToLiquidate(\n\t\tDataTypes.ReserveData storage collateralReserve,\n\t\tDataTypes.ReserveData storage debtReserve,\n\t\taddress collateralAsset,\n\t\taddress debtAsset,\n\t\tuint256 debtToCover,\n\t\tuint256 userCollateralBalance\n\t) internal view returns (uint256, uint256, uint256) {\n\t\tuint256 collateralAmount = 0;\n\t\tuint256 debtAmountNeeded = 0;\n\t\tIPriceOracleGetter oracle = IPriceOracleGetter(_addressesProvider.getPriceOracle());\n\n\t\tAvailableCollateralToLiquidateLocalVars memory vars;\n\n\t\tvars.collateralPrice = oracle.getAssetPrice(collateralAsset);\n\t\tvars.debtAssetPrice = oracle.getAssetPrice(debtAsset);\n\n\t\t(, , vars.liquidationBonus, vars.collateralDecimals, ) = collateralReserve.configuration.getParams();\n\t\tvars.debtAssetDecimals = debtReserve.configuration.getDecimals();\n\n\t\t// This is the maximum possible amount of the selected collateral that can be liquidated, given the\n\t\t// max amount of liquidatable debt\n\t\tvars.maxAmountCollateralToLiquidate = vars\n\t\t\t.debtAssetPrice\n\t\t\t.mul(debtToCover)\n\t\t\t.mul(10 ** vars.collateralDecimals)\n\t\t\t.percentMul(vars.liquidationBonus)\n\t\t\t.div(vars.collateralPrice.mul(10 ** vars.debtAssetDecimals));\n\n\t\tif (vars.maxAmountCollateralToLiquidate > userCollateralBalance) {\n\t\t\tcollateralAmount = userCollateralBalance;\n\t\t\tdebtAmountNeeded = vars\n\t\t\t\t.collateralPrice\n\t\t\t\t.mul(collateralAmount)\n\t\t\t\t.mul(10 ** vars.debtAssetDecimals)\n\t\t\t\t.div(vars.debtAssetPrice.mul(10 ** vars.collateralDecimals))\n\t\t\t\t.percentDiv(vars.liquidationBonus);\n\t\t} else {\n\t\t\tcollateralAmount = vars.maxAmountCollateralToLiquidate;\n\t\t\tdebtAmountNeeded = debtToCover;\n\t\t}\n\t\tuint256 bonusCollateral = collateralAmount.sub(\n\t\t\tvars.debtAssetPrice.mul(debtAmountNeeded).mul(10 ** vars.collateralDecimals).div(\n\t\t\t\tvars.collateralPrice.mul(10 ** vars.debtAssetDecimals)\n\t\t\t)\n\t\t);\n\t\treturn (collateralAmount, bonusCollateral.div(2), debtAmountNeeded);\n\t}\n}\n"
    },
    "contracts/lending/lendingpool/LendingPoolConfigurator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {VersionedInitializable} from \"../libraries/aave-upgradeability/VersionedInitializable.sol\";\nimport {InitializableImmutableAdminUpgradeabilityProxy} from \"../libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol\";\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {ILendingPoolAddressesProvider} from \"../../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {IInitializableDebtToken} from \"../../interfaces/IInitializableDebtToken.sol\";\nimport {IInitializableAToken} from \"../../interfaces/IInitializableAToken.sol\";\nimport {IChefIncentivesController} from \"../../interfaces/IChefIncentivesController.sol\";\nimport {IAaveIncentivesController} from \"../../interfaces/IAaveIncentivesController.sol\";\nimport {ILendingPoolConfigurator} from \"../../interfaces/ILendingPoolConfigurator.sol\";\nimport {IMultiFeeDistribution} from \"../../interfaces/IMultiFeeDistribution.sol\";\n\n/**\n * @title LendingPoolConfigurator contract\n * @author Aave\n * @dev Implements the configuration methods for the Aave protocol\n **/\n\ncontract LendingPoolConfigurator is VersionedInitializable, ILendingPoolConfigurator {\n\tusing SafeMath for uint256;\n\tusing PercentageMath for uint256;\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n\tILendingPoolAddressesProvider internal addressesProvider;\n\tILendingPool internal pool;\n\n\tmodifier onlyPoolAdmin() {\n\t\trequire(addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n\t\t_;\n\t}\n\n\tmodifier onlyEmergencyAdmin() {\n\t\trequire(addressesProvider.getEmergencyAdmin() == msg.sender, Errors.LPC_CALLER_NOT_EMERGENCY_ADMIN);\n\t\t_;\n\t}\n\n\tuint256 internal constant CONFIGURATOR_REVISION = 0x1;\n\n\tfunction getRevision() internal pure override returns (uint256) {\n\t\treturn CONFIGURATOR_REVISION;\n\t}\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\tfunction initialize(ILendingPoolAddressesProvider provider) public initializer {\n\t\taddressesProvider = provider;\n\t\tpool = ILendingPool(addressesProvider.getLendingPool());\n\t}\n\n\t/**\n\t * @dev Initializes reserves in batch\n\t **/\n\tfunction batchInitReserve(InitReserveInput[] calldata input) external onlyPoolAdmin {\n\t\tILendingPool cachedPool = pool;\n\t\tuint256 length = input.length;\n\t\tfor (uint256 i = 0; i < length; ) {\n\t\t\t_initReserve(cachedPool, input[i]);\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction _initReserve(ILendingPool _pool, InitReserveInput calldata input) internal {\n\t\tIChefIncentivesController incentivesController = IChefIncentivesController(input.incentivesController);\n\t\taddress aTokenProxyAddress = _initTokenWithProxy(\n\t\t\tinput.aTokenImpl,\n\t\t\tabi.encodeCall(\n\t\t\t\tIInitializableAToken.initialize,\n\t\t\t\t(\n\t\t\t\t\t_pool,\n\t\t\t\t\tinput.treasury,\n\t\t\t\t\tinput.underlyingAsset,\n\t\t\t\t\tIAaveIncentivesController(input.incentivesController),\n\t\t\t\t\tinput.underlyingAssetDecimals,\n\t\t\t\t\tinput.aTokenName,\n\t\t\t\t\tinput.aTokenSymbol,\n\t\t\t\t\tinput.params\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t\tincentivesController.addPool(aTokenProxyAddress, input.allocPoint);\n\t\tIMultiFeeDistribution(input.treasury).addReward(aTokenProxyAddress);\n\n\t\taddress stableDebtTokenProxyAddress = _initTokenWithProxy(\n\t\t\tinput.stableDebtTokenImpl,\n\t\t\tabi.encodeCall(\n\t\t\t\tIInitializableDebtToken.initialize,\n\t\t\t\t(\n\t\t\t\t\t_pool,\n\t\t\t\t\tinput.underlyingAsset,\n\t\t\t\t\tIAaveIncentivesController(input.incentivesController),\n\t\t\t\t\tinput.underlyingAssetDecimals,\n\t\t\t\t\tinput.stableDebtTokenName,\n\t\t\t\t\tinput.stableDebtTokenSymbol,\n\t\t\t\t\tinput.params\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t\t// stableDebt is not added to incentives controller\n\t\t// GEIST does not support stable lending\n\n\t\taddress variableDebtTokenProxyAddress = _initTokenWithProxy(\n\t\t\tinput.variableDebtTokenImpl,\n\t\t\tabi.encodeCall(\n\t\t\t\tIInitializableDebtToken.initialize,\n\t\t\t\t(\n\t\t\t\t\t_pool,\n\t\t\t\t\tinput.underlyingAsset,\n\t\t\t\t\tIAaveIncentivesController(input.incentivesController),\n\t\t\t\t\tinput.underlyingAssetDecimals,\n\t\t\t\t\tinput.variableDebtTokenName,\n\t\t\t\t\tinput.variableDebtTokenSymbol,\n\t\t\t\t\tinput.params\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t\tincentivesController.addPool(variableDebtTokenProxyAddress, input.allocPoint);\n\n\t\t_pool.initReserve(\n\t\t\tinput.underlyingAsset,\n\t\t\taTokenProxyAddress,\n\t\t\tstableDebtTokenProxyAddress,\n\t\t\tvariableDebtTokenProxyAddress,\n\t\t\tinput.interestRateStrategyAddress\n\t\t);\n\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(input.underlyingAsset);\n\n\t\tcurrentConfig.setDecimals(input.underlyingAssetDecimals);\n\n\t\tcurrentConfig.setActive(true);\n\t\tcurrentConfig.setFrozen(false);\n\n\t\tpool.setConfiguration(input.underlyingAsset, currentConfig.data);\n\n\t\temit ReserveInitialized(\n\t\t\tinput.underlyingAsset,\n\t\t\taTokenProxyAddress,\n\t\t\tstableDebtTokenProxyAddress,\n\t\t\tvariableDebtTokenProxyAddress,\n\t\t\tinput.interestRateStrategyAddress\n\t\t);\n\t}\n\n\t/**\n\t * @dev Updates the aToken implementation for the reserve\n\t **/\n\tfunction updateAToken(UpdateATokenInput calldata input) external onlyPoolAdmin {\n\t\tILendingPool cachedPool = pool;\n\n\t\tDataTypes.ReserveData memory reserveData = cachedPool.getReserveData(input.asset);\n\n\t\t(, , , uint256 decimals, ) = cachedPool.getConfiguration(input.asset).getParamsMemory();\n\n\t\tbytes memory encodedCall = abi.encodeCall(\n\t\t\tIInitializableAToken.initialize,\n\t\t\t(\n\t\t\t\tcachedPool,\n\t\t\t\tinput.treasury,\n\t\t\t\tinput.asset,\n\t\t\t\tIAaveIncentivesController(input.incentivesController),\n\t\t\t\tuint8(decimals),\n\t\t\t\tinput.name,\n\t\t\t\tinput.symbol,\n\t\t\t\tinput.params\n\t\t\t)\n\t\t);\n\n\t\t_upgradeTokenImplementation(reserveData.aTokenAddress, input.implementation, encodedCall);\n\n\t\temit ATokenUpgraded(input.asset, reserveData.aTokenAddress, input.implementation);\n\t}\n\n\t/**\n\t * @dev Updates the stable debt token implementation for the reserve\n\t **/\n\tfunction updateStableDebtToken(UpdateDebtTokenInput calldata input) external onlyPoolAdmin {\n\t\tILendingPool cachedPool = pool;\n\n\t\tDataTypes.ReserveData memory reserveData = cachedPool.getReserveData(input.asset);\n\n\t\t(, , , uint256 decimals, ) = cachedPool.getConfiguration(input.asset).getParamsMemory();\n\n\t\tbytes memory encodedCall = abi.encodeCall(\n\t\t\tIInitializableDebtToken.initialize,\n\t\t\t(\n\t\t\t\tcachedPool,\n\t\t\t\tinput.asset,\n\t\t\t\tIAaveIncentivesController(input.incentivesController),\n\t\t\t\tuint8(decimals),\n\t\t\t\tinput.name,\n\t\t\t\tinput.symbol,\n\t\t\t\tinput.params\n\t\t\t)\n\t\t);\n\n\t\t_upgradeTokenImplementation(reserveData.stableDebtTokenAddress, input.implementation, encodedCall);\n\n\t\temit StableDebtTokenUpgraded(input.asset, reserveData.stableDebtTokenAddress, input.implementation);\n\t}\n\n\t/**\n\t * @dev Updates the variable debt token implementation for the asset\n\t **/\n\tfunction updateVariableDebtToken(UpdateDebtTokenInput calldata input) external onlyPoolAdmin {\n\t\tILendingPool cachedPool = pool;\n\n\t\tDataTypes.ReserveData memory reserveData = cachedPool.getReserveData(input.asset);\n\n\t\t(, , , uint256 decimals, ) = cachedPool.getConfiguration(input.asset).getParamsMemory();\n\n\t\tbytes memory encodedCall = abi.encodeCall(\n\t\t\tIInitializableDebtToken.initialize,\n\t\t\t(\n\t\t\t\tcachedPool,\n\t\t\t\tinput.asset,\n\t\t\t\tIAaveIncentivesController(input.incentivesController),\n\t\t\t\tuint8(decimals),\n\t\t\t\tinput.name,\n\t\t\t\tinput.symbol,\n\t\t\t\tinput.params\n\t\t\t)\n\t\t);\n\n\t\t_upgradeTokenImplementation(reserveData.variableDebtTokenAddress, input.implementation, encodedCall);\n\n\t\temit VariableDebtTokenUpgraded(input.asset, reserveData.variableDebtTokenAddress, input.implementation);\n\t}\n\n\t/**\n\t * @dev Enables borrowing on a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param stableBorrowRateEnabled True if stable borrow rate needs to be enabled by default on this reserve\n\t **/\n\tfunction enableBorrowingOnReserve(address asset, bool stableBorrowRateEnabled) external onlyPoolAdmin {\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n\t\tcurrentConfig.setBorrowingEnabled(true);\n\t\tcurrentConfig.setStableRateBorrowingEnabled(stableBorrowRateEnabled);\n\n\t\tpool.setConfiguration(asset, currentConfig.data);\n\n\t\temit BorrowingEnabledOnReserve(asset, stableBorrowRateEnabled);\n\t}\n\n\t/**\n\t * @dev Disables borrowing on a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tfunction disableBorrowingOnReserve(address asset) external onlyPoolAdmin {\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n\t\tcurrentConfig.setBorrowingEnabled(false);\n\n\t\tpool.setConfiguration(asset, currentConfig.data);\n\t\temit BorrowingDisabledOnReserve(asset);\n\t}\n\n\t/**\n\t * @dev Configures the reserve collateralization parameters\n\t * all the values are expressed in percentages with two decimals of precision. A valid value is 10000, which means 100.00%\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param ltv The loan to value of the asset when used as collateral\n\t * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\n\t * @param liquidationBonus The bonus liquidators receive to liquidate this asset. The values is always above 100%. A value of 105%\n\t * means the liquidator will receive a 5% bonus\n\t **/\n\tfunction configureReserveAsCollateral(\n\t\taddress asset,\n\t\tuint256 ltv,\n\t\tuint256 liquidationThreshold,\n\t\tuint256 liquidationBonus\n\t) external onlyPoolAdmin {\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n\t\t//validation of the parameters: the LTV can\n\t\t//only be lower or equal than the liquidation threshold\n\t\t//(otherwise a loan against the asset would cause instantaneous liquidation)\n\t\trequire(ltv <= liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION);\n\n\t\tif (liquidationThreshold != 0) {\n\t\t\t//liquidation bonus must be bigger than 100.00%, otherwise the liquidator would receive less\n\t\t\t//collateral than needed to cover the debt\n\t\t\trequire(liquidationBonus > PercentageMath.PERCENTAGE_FACTOR, Errors.LPC_INVALID_CONFIGURATION);\n\n\t\t\t//if threshold * bonus is less than PERCENTAGE_FACTOR, it's guaranteed that at the moment\n\t\t\t//a loan is taken there is enough collateral available to cover the liquidation bonus\n\t\t\trequire(\n\t\t\t\tliquidationThreshold.percentMul(liquidationBonus) <= PercentageMath.PERCENTAGE_FACTOR,\n\t\t\t\tErrors.LPC_INVALID_CONFIGURATION\n\t\t\t);\n\t\t} else {\n\t\t\trequire(liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION);\n\t\t\t//if the liquidation threshold is being set to 0,\n\t\t\t// the reserve is being disabled as collateral. To do so,\n\t\t\t//we need to ensure no liquidity is deposited\n\t\t\t_checkNoLiquidity(asset);\n\t\t}\n\n\t\tcurrentConfig.setLtv(ltv);\n\t\tcurrentConfig.setLiquidationThreshold(liquidationThreshold);\n\t\tcurrentConfig.setLiquidationBonus(liquidationBonus);\n\n\t\tpool.setConfiguration(asset, currentConfig.data);\n\n\t\temit CollateralConfigurationChanged(asset, ltv, liquidationThreshold, liquidationBonus);\n\t}\n\n\t/**\n\t * @dev Enable stable rate borrowing on a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tfunction enableReserveStableRate(address asset) external onlyPoolAdmin {\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n\t\tcurrentConfig.setStableRateBorrowingEnabled(true);\n\n\t\tpool.setConfiguration(asset, currentConfig.data);\n\n\t\temit StableRateEnabledOnReserve(asset);\n\t}\n\n\t/**\n\t * @dev Disable stable rate borrowing on a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tfunction disableReserveStableRate(address asset) external onlyPoolAdmin {\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n\t\tcurrentConfig.setStableRateBorrowingEnabled(false);\n\n\t\tpool.setConfiguration(asset, currentConfig.data);\n\n\t\temit StableRateDisabledOnReserve(asset);\n\t}\n\n\t/**\n\t * @dev Activates a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tfunction activateReserve(address asset) external onlyPoolAdmin {\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n\t\tcurrentConfig.setActive(true);\n\n\t\tpool.setConfiguration(asset, currentConfig.data);\n\n\t\temit ReserveActivated(asset);\n\t}\n\n\t/**\n\t * @dev Deactivates a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tfunction deactivateReserve(address asset) external onlyPoolAdmin {\n\t\t_checkNoLiquidity(asset);\n\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n\t\tcurrentConfig.setActive(false);\n\n\t\tpool.setConfiguration(asset, currentConfig.data);\n\n\t\temit ReserveDeactivated(asset);\n\t}\n\n\t/**\n\t * @dev Freezes a reserve. A frozen reserve doesn't allow any new deposit, borrow or rate swap\n\t *  but allows repayments, liquidations, rate rebalances and withdrawals\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tfunction freezeReserve(address asset) external onlyPoolAdmin {\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n\t\tcurrentConfig.setFrozen(true);\n\n\t\tpool.setConfiguration(asset, currentConfig.data);\n\n\t\temit ReserveFrozen(asset);\n\t}\n\n\t/**\n\t * @dev Unfreezes a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tfunction unfreezeReserve(address asset) external onlyPoolAdmin {\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n\t\tcurrentConfig.setFrozen(false);\n\n\t\tpool.setConfiguration(asset, currentConfig.data);\n\n\t\temit ReserveUnfrozen(asset);\n\t}\n\n\t/**\n\t * @dev Updates the reserve factor of a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param reserveFactor The new reserve factor of the reserve\n\t **/\n\tfunction setReserveFactor(address asset, uint256 reserveFactor) external onlyPoolAdmin {\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n\t\tcurrentConfig.setReserveFactor(reserveFactor);\n\n\t\tpool.setConfiguration(asset, currentConfig.data);\n\n\t\temit ReserveFactorChanged(asset, reserveFactor);\n\t}\n\n\t/**\n\t * @dev Sets the interest rate strategy of a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param rateStrategyAddress The new address of the interest strategy contract\n\t **/\n\tfunction setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress) external onlyPoolAdmin {\n\t\tpool.setReserveInterestRateStrategyAddress(asset, rateStrategyAddress);\n\t\temit ReserveInterestRateStrategyChanged(asset, rateStrategyAddress);\n\t}\n\n\t/**\n\t * @dev pauses or unpauses all the actions of the protocol, including aToken transfers\n\t * @param val true if protocol needs to be paused, false otherwise\n\t **/\n\tfunction setPoolPause(bool val) external onlyEmergencyAdmin {\n\t\tpool.setPause(val);\n\t}\n\n\tfunction _initTokenWithProxy(address implementation, bytes memory initParams) internal returns (address) {\n\t\tInitializableImmutableAdminUpgradeabilityProxy proxy = new InitializableImmutableAdminUpgradeabilityProxy(\n\t\t\taddress(this)\n\t\t);\n\n\t\tproxy.initialize(implementation, initParams);\n\n\t\treturn address(proxy);\n\t}\n\n\tfunction _upgradeTokenImplementation(\n\t\taddress proxyAddress,\n\t\taddress implementation,\n\t\tbytes memory initParams\n\t) internal {\n\t\tInitializableImmutableAdminUpgradeabilityProxy proxy = InitializableImmutableAdminUpgradeabilityProxy(\n\t\t\tpayable(proxyAddress)\n\t\t);\n\n\t\tproxy.upgradeToAndCall(implementation, initParams);\n\t}\n\n\tfunction _checkNoLiquidity(address asset) internal view {\n\t\tDataTypes.ReserveData memory reserveData = pool.getReserveData(asset);\n\n\t\tuint256 availableLiquidity = IERC20Metadata(asset).balanceOf(reserveData.aTokenAddress);\n\n\t\trequire(availableLiquidity == 0 && reserveData.currentLiquidityRate == 0, Errors.LPC_RESERVE_LIQUIDITY_NOT_0);\n\t}\n}\n"
    },
    "contracts/lending/lendingpool/LendingPoolStorage.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {UserConfiguration} from \"../libraries/configuration/UserConfiguration.sol\";\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {ILendingPoolAddressesProvider} from \"../../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\n\ncontract LendingPoolStorage {\n\tusing ReserveLogic for DataTypes.ReserveData;\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\tusing UserConfiguration for DataTypes.UserConfigurationMap;\n\n\tILendingPoolAddressesProvider internal _addressesProvider;\n\n\tmapping(address => DataTypes.ReserveData) internal _reserves;\n\tmapping(address => DataTypes.UserConfigurationMap) internal _usersConfig;\n\n\t// the list of the available reserves, structured as a mapping for gas savings reasons\n\tmapping(uint256 => address) internal _reservesList;\n\n\tuint256 internal _reservesCount;\n\n\tbool internal _paused;\n\n\tuint256 internal _maxStableRateBorrowSizePercent;\n\n\tuint256 internal _flashLoanPremiumTotal;\n\n\tuint256 internal _maxNumberOfReserves;\n}\n"
    },
    "contracts/lending/libraries/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"../../../dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol\";\n\n/**\n * @title BaseImmutableAdminUpgradeabilityProxy\n * @author Aave, inspired by the OpenZeppelin upgradeability proxy pattern\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks. The admin role is stored in an immutable, which\n * helps saving transactions costs\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n\taddress immutable ADMIN;\n\n\tconstructor(address _admin) {\n\t\tADMIN = _admin;\n\t}\n\n\tmodifier ifAdmin() {\n\t\tif (msg.sender == ADMIN) {\n\t\t\t_;\n\t\t} else {\n\t\t\t_fallback();\n\t\t}\n\t}\n\n\t/**\n\t * @return _address The address of the proxy admin.\n\t */\n\tfunction admin() external ifAdmin returns (address _address) {\n\t\treturn ADMIN;\n\t}\n\n\t/**\n\t * @return _address The address of the implementation.\n\t */\n\tfunction implementation() external ifAdmin returns (address _address) {\n\t\treturn _implementation();\n\t}\n\n\t/**\n\t * @dev Upgrade the backing implementation of the proxy.\n\t * Only the admin can call this function.\n\t * @param newImplementation Address of the new implementation.\n\t */\n\tfunction upgradeTo(address newImplementation) external ifAdmin {\n\t\t_upgradeTo(newImplementation);\n\t}\n\n\t/**\n\t * @dev Upgrade the backing implementation of the proxy and call a function\n\t * on the new implementation.\n\t * This is useful to initialize the proxied contract.\n\t * @param newImplementation Address of the new implementation.\n\t * @param data Data to send as msg.data in the low level call.\n\t * It should include the signature and the parameters of the function to be called, as described in\n\t * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n\t */\n\tfunction upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n\t\t_upgradeTo(newImplementation);\n\t\t(bool success, ) = newImplementation.delegatecall(data);\n\t\trequire(success);\n\t}\n\n\t/**\n\t * @dev Only fall back when the sender is not the admin.\n\t */\n\tfunction _willFallback() internal virtual override {\n\t\trequire(msg.sender != ADMIN, \"Cannot call fallback function from the proxy admin\");\n\t\tsuper._willFallback();\n\t}\n}\n"
    },
    "contracts/lending/libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./BaseImmutableAdminUpgradeabilityProxy.sol\";\nimport \"../../../dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol\";\n\n/**\n * @title InitializableAdminUpgradeabilityProxy\n * @dev Extends BaseAdminUpgradeabilityProxy with an initializer function\n */\ncontract InitializableImmutableAdminUpgradeabilityProxy is\n\tBaseImmutableAdminUpgradeabilityProxy,\n\tInitializableUpgradeabilityProxy\n{\n\tconstructor(address admin) BaseImmutableAdminUpgradeabilityProxy(admin) {}\n\n\t/**\n\t * @dev Only fall back when the sender is not the admin.\n\t */\n\tfunction _willFallback() internal override(BaseImmutableAdminUpgradeabilityProxy, Proxy) {\n\t\tBaseImmutableAdminUpgradeabilityProxy._willFallback();\n\t}\n}\n"
    },
    "contracts/lending/libraries/aave-upgradeability/VersionedInitializable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title VersionedInitializable\n *\n * @dev Helper contract to implement initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n *\n * @author Aave, inspired by the OpenZeppelin Initializable contract\n */\nabstract contract VersionedInitializable {\n\n\t/**\n\t * @dev Indicates that the contract has been initialized.\n\t */\n\tuint256 private lastInitializedRevision = 0;\n\n\t/**\n\t * @dev Indicates that the contract is in the process of being initialized.\n\t */\n\tbool private initializing;\n\n\t/**\n\t * @dev Indicates that the contract has been initialized.\n\t */\n\tbool private initialized;\n\n\t/**\n\t * @dev Modifier to use in the initializer function of a contract.\n\t */\n\tmodifier initializer() {\n\t\tuint256 revision = getRevision();\n\t\tbool isTopLevelCall = !initializing;\n\n\t\trequire(\n\t\t\tisTopLevelCall && (revision > lastInitializedRevision || !initialized),\n\t\t\t\"Contract instance has already been initialized\"\n\t\t);\n\n\t\tif (isTopLevelCall) {\n\t\t\tinitializing = true;\n\t\t\tinitialized = true;\n\t\t\tlastInitializedRevision = revision;\n\t\t}\n\n\t\t_;\n\n\t\tif (isTopLevelCall) {\n\t\t\tinitializing = false;\n\t\t}\n\t}\n\n\t/**\n\t * @dev returns the revision number of the contract\n\t * Needs to be defined in the inherited class as a constant.\n\t **/\n\tfunction getRevision() internal pure virtual returns (uint256);\n\n\tfunction _disableInitializers() internal virtual {\n\t\trequire(!initializing, \"Initializable: contract is initializing\");\n\t\tif (!initialized) {\n\t\t\tinitialized = true;\n\t\t}\n\t}\n\n\t// Reserved storage space to allow for layout changes in the future.\n\tuint256[50] private ______gap;\n}\n"
    },
    "contracts/lending/libraries/configuration/ReserveConfiguration.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\n/**\n * @title ReserveConfiguration library\n * @author Aave\n * @notice Implements the bitmap logic to handle the reserve configuration\n */\nlibrary ReserveConfiguration {\n\tuint256 constant LTV_MASK =                   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\n\tuint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\n\tuint256 constant LIQUIDATION_BONUS_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\n\tuint256 constant DECIMALS_MASK =              0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\n\tuint256 constant ACTIVE_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\n\tuint256 constant FROZEN_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\n\tuint256 constant BORROWING_MASK =             0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\n\tuint256 constant STABLE_BORROWING_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\n\tuint256 constant RESERVE_FACTOR_MASK =        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\n\n\t/// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\n\tuint256 constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\n\tuint256 constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\n\tuint256 constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\n\tuint256 constant IS_ACTIVE_START_BIT_POSITION = 56;\n\tuint256 constant IS_FROZEN_START_BIT_POSITION = 57;\n\tuint256 constant BORROWING_ENABLED_START_BIT_POSITION = 58;\n\tuint256 constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\n\tuint256 constant RESERVE_FACTOR_START_BIT_POSITION = 64;\n\n\tuint256 constant MAX_VALID_LTV = 65535;\n\tuint256 constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\n\tuint256 constant MAX_VALID_LIQUIDATION_BONUS = 65535;\n\tuint256 constant MAX_VALID_DECIMALS = 255;\n\tuint256 constant MAX_VALID_RESERVE_FACTOR = 65535;\n\n\t/**\n\t * @dev Sets the Loan to Value of the reserve\n\t * @param self The reserve configuration\n\t * @param ltv the new ltv\n\t **/\n\tfunction setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {\n\t\trequire(ltv <= MAX_VALID_LTV, Errors.RC_INVALID_LTV);\n\n\t\tself.data = (self.data & LTV_MASK) | ltv;\n\t}\n\n\t/**\n\t * @dev Gets the Loan to Value of the reserve\n\t * @param self The reserve configuration\n\t * @return The loan to value\n\t **/\n\tfunction getLtv(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\n\t\treturn self.data & ~LTV_MASK;\n\t}\n\n\t/**\n\t * @dev Sets the liquidation threshold of the reserve\n\t * @param self The reserve configuration\n\t * @param threshold The new liquidation threshold\n\t **/\n\tfunction setLiquidationThreshold(DataTypes.ReserveConfigurationMap memory self, uint256 threshold) internal pure {\n\t\trequire(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.RC_INVALID_LIQ_THRESHOLD);\n\n\t\tself.data = (self.data & LIQUIDATION_THRESHOLD_MASK) | (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\n\t}\n\n\t/**\n\t * @dev Gets the liquidation threshold of the reserve\n\t * @param self The reserve configuration\n\t * @return The liquidation threshold\n\t **/\n\tfunction getLiquidationThreshold(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\n\t\treturn (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;\n\t}\n\n\t/**\n\t * @dev Sets the liquidation bonus of the reserve\n\t * @param self The reserve configuration\n\t * @param bonus The new liquidation bonus\n\t **/\n\tfunction setLiquidationBonus(DataTypes.ReserveConfigurationMap memory self, uint256 bonus) internal pure {\n\t\trequire(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.RC_INVALID_LIQ_BONUS);\n\n\t\tself.data = (self.data & LIQUIDATION_BONUS_MASK) | (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\n\t}\n\n\t/**\n\t * @dev Gets the liquidation bonus of the reserve\n\t * @param self The reserve configuration\n\t * @return The liquidation bonus\n\t **/\n\tfunction getLiquidationBonus(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\n\t\treturn (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;\n\t}\n\n\t/**\n\t * @dev Sets the decimals of the underlying asset of the reserve\n\t * @param self The reserve configuration\n\t * @param decimals The decimals\n\t **/\n\tfunction setDecimals(DataTypes.ReserveConfigurationMap memory self, uint256 decimals) internal pure {\n\t\trequire(decimals <= MAX_VALID_DECIMALS, Errors.RC_INVALID_DECIMALS);\n\n\t\tself.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION);\n\t}\n\n\t/**\n\t * @dev Gets the decimals of the underlying asset of the reserve\n\t * @param self The reserve configuration\n\t * @return The decimals of the asset\n\t **/\n\tfunction getDecimals(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\n\t\treturn (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;\n\t}\n\n\t/**\n\t * @dev Sets the active state of the reserve\n\t * @param self The reserve configuration\n\t * @param active The active state\n\t **/\n\tfunction setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {\n\t\tself.data = (self.data & ACTIVE_MASK) | (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\n\t}\n\n\t/**\n\t * @dev Gets the active state of the reserve\n\t * @param self The reserve configuration\n\t * @return The active state\n\t **/\n\tfunction getActive(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\n\t\treturn (self.data & ~ACTIVE_MASK) != 0;\n\t}\n\n\t/**\n\t * @dev Sets the frozen state of the reserve\n\t * @param self The reserve configuration\n\t * @param frozen The frozen state\n\t **/\n\tfunction setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {\n\t\tself.data = (self.data & FROZEN_MASK) | (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\n\t}\n\n\t/**\n\t * @dev Gets the frozen state of the reserve\n\t * @param self The reserve configuration\n\t * @return The frozen state\n\t **/\n\tfunction getFrozen(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\n\t\treturn (self.data & ~FROZEN_MASK) != 0;\n\t}\n\n\t/**\n\t * @dev Enables or disables borrowing on the reserve\n\t * @param self The reserve configuration\n\t * @param enabled True if the borrowing needs to be enabled, false otherwise\n\t **/\n\tfunction setBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled) internal pure {\n\t\tself.data = (self.data & BORROWING_MASK) | (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);\n\t}\n\n\t/**\n\t * @dev Gets the borrowing state of the reserve\n\t * @param self The reserve configuration\n\t * @return The borrowing state\n\t **/\n\tfunction getBorrowingEnabled(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\n\t\treturn (self.data & ~BORROWING_MASK) != 0;\n\t}\n\n\t/**\n\t * @dev Enables or disables stable rate borrowing on the reserve\n\t * @param self The reserve configuration\n\t * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise\n\t **/\n\tfunction setStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled) internal pure {\n\t\tself.data =\n\t\t\t(self.data & STABLE_BORROWING_MASK) |\n\t\t\t(uint256(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);\n\t}\n\n\t/**\n\t * @dev Gets the stable rate borrowing state of the reserve\n\t * @param self The reserve configuration\n\t * @return The stable rate borrowing state\n\t **/\n\tfunction getStableRateBorrowingEnabled(\n\t\tDataTypes.ReserveConfigurationMap storage self\n\t) internal view returns (bool) {\n\t\treturn (self.data & ~STABLE_BORROWING_MASK) != 0;\n\t}\n\n\t/**\n\t * @dev Sets the reserve factor of the reserve\n\t * @param self The reserve configuration\n\t * @param reserveFactor The reserve factor\n\t **/\n\tfunction setReserveFactor(DataTypes.ReserveConfigurationMap memory self, uint256 reserveFactor) internal pure {\n\t\trequire(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.RC_INVALID_RESERVE_FACTOR);\n\n\t\tself.data = (self.data & RESERVE_FACTOR_MASK) | (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);\n\t}\n\n\t/**\n\t * @dev Gets the reserve factor of the reserve\n\t * @param self The reserve configuration\n\t * @return The reserve factor\n\t **/\n\tfunction getReserveFactor(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\n\t\treturn (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;\n\t}\n\n\t/**\n\t * @dev Gets the configuration flags of the reserve\n\t * @param self The reserve configuration\n\t * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled\n\t **/\n\tfunction getFlags(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool, bool, bool, bool) {\n\t\tuint256 dataLocal = self.data;\n\n\t\treturn (\n\t\t\t(dataLocal & ~ACTIVE_MASK) != 0,\n\t\t\t(dataLocal & ~FROZEN_MASK) != 0,\n\t\t\t(dataLocal & ~BORROWING_MASK) != 0,\n\t\t\t(dataLocal & ~STABLE_BORROWING_MASK) != 0\n\t\t);\n\t}\n\n\t/**\n\t * @dev Gets the configuration paramters of the reserve\n\t * @param self The reserve configuration\n\t * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\n\t **/\n\tfunction getParams(\n\t\tDataTypes.ReserveConfigurationMap storage self\n\t) internal view returns (uint256, uint256, uint256, uint256, uint256) {\n\t\tuint256 dataLocal = self.data;\n\n\t\treturn (\n\t\t\tdataLocal & ~LTV_MASK,\n\t\t\t(dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\n\t\t\t(dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\n\t\t\t(dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\n\t\t\t(dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\n\t\t);\n\t}\n\n\t/**\n\t * @dev Gets the configuration paramters of the reserve from a memory object\n\t * @param self The reserve configuration\n\t * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\n\t **/\n\tfunction getParamsMemory(\n\t\tDataTypes.ReserveConfigurationMap memory self\n\t) internal pure returns (uint256, uint256, uint256, uint256, uint256) {\n\t\treturn (\n\t\t\tself.data & ~LTV_MASK,\n\t\t\t(self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\n\t\t\t(self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\n\t\t\t(self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\n\t\t\t(self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\n\t\t);\n\t}\n\n\t/**\n\t * @dev Gets the configuration flags of the reserve from a memory object\n\t * @param self The reserve configuration\n\t * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled\n\t **/\n\tfunction getFlagsMemory(\n\t\tDataTypes.ReserveConfigurationMap memory self\n\t) internal pure returns (bool, bool, bool, bool) {\n\t\treturn (\n\t\t\t(self.data & ~ACTIVE_MASK) != 0,\n\t\t\t(self.data & ~FROZEN_MASK) != 0,\n\t\t\t(self.data & ~BORROWING_MASK) != 0,\n\t\t\t(self.data & ~STABLE_BORROWING_MASK) != 0\n\t\t);\n\t}\n}\n"
    },
    "contracts/lending/libraries/configuration/UserConfiguration.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\n/**\n * @title UserConfiguration library\n * @author Aave\n * @notice Implements the bitmap logic to handle the user configuration\n */\nlibrary UserConfiguration {\n\tuint256 internal constant BORROWING_MASK = 0x5555555555555555555555555555555555555555555555555555555555555555;\n\n\t/**\n\t * @dev Sets if the user is borrowing the reserve identified by reserveIndex\n\t * @param self The configuration object\n\t * @param reserveIndex The index of the reserve in the bitmap\n\t * @param borrowing True if the user is borrowing the reserve, false otherwise\n\t **/\n\tfunction setBorrowing(DataTypes.UserConfigurationMap storage self, uint256 reserveIndex, bool borrowing) internal {\n\t\trequire(reserveIndex < 128, Errors.UL_INVALID_INDEX);\n\t\tself.data = (self.data & ~(1 << (reserveIndex * 2))) | (uint256(borrowing ? 1 : 0) << (reserveIndex * 2));\n\t}\n\n\t/**\n\t * @dev Sets if the user is using as collateral the reserve identified by reserveIndex\n\t * @param self The configuration object\n\t * @param reserveIndex The index of the reserve in the bitmap\n\t * @param usingAsCollateral True if the user is usin the reserve as collateral, false otherwise\n\t **/\n\tfunction setUsingAsCollateral(\n\t\tDataTypes.UserConfigurationMap storage self,\n\t\tuint256 reserveIndex,\n\t\tbool usingAsCollateral\n\t) internal {\n\t\trequire(reserveIndex < 128, Errors.UL_INVALID_INDEX);\n\t\tself.data =\n\t\t\t(self.data & ~(1 << (reserveIndex * 2 + 1))) |\n\t\t\t(uint256(usingAsCollateral ? 1 : 0) << (reserveIndex * 2 + 1));\n\t}\n\n\t/**\n\t * @dev Used to validate if a user has been using the reserve for borrowing or as collateral\n\t * @param self The configuration object\n\t * @param reserveIndex The index of the reserve in the bitmap\n\t * @return True if the user has been using a reserve for borrowing or as collateral, false otherwise\n\t **/\n\tfunction isUsingAsCollateralOrBorrowing(\n\t\tDataTypes.UserConfigurationMap memory self,\n\t\tuint256 reserveIndex\n\t) internal pure returns (bool) {\n\t\trequire(reserveIndex < 128, Errors.UL_INVALID_INDEX);\n\t\treturn (self.data >> (reserveIndex * 2)) & 3 != 0;\n\t}\n\n\t/**\n\t * @dev Used to validate if a user has been using the reserve for borrowing\n\t * @param self The configuration object\n\t * @param reserveIndex The index of the reserve in the bitmap\n\t * @return True if the user has been using a reserve for borrowing, false otherwise\n\t **/\n\tfunction isBorrowing(\n\t\tDataTypes.UserConfigurationMap memory self,\n\t\tuint256 reserveIndex\n\t) internal pure returns (bool) {\n\t\trequire(reserveIndex < 128, Errors.UL_INVALID_INDEX);\n\t\treturn (self.data >> (reserveIndex * 2)) & 1 != 0;\n\t}\n\n\t/**\n\t * @dev Used to validate if a user has been using the reserve as collateral\n\t * @param self The configuration object\n\t * @param reserveIndex The index of the reserve in the bitmap\n\t * @return True if the user has been using a reserve as collateral, false otherwise\n\t **/\n\tfunction isUsingAsCollateral(\n\t\tDataTypes.UserConfigurationMap memory self,\n\t\tuint256 reserveIndex\n\t) internal pure returns (bool) {\n\t\trequire(reserveIndex < 128, Errors.UL_INVALID_INDEX);\n\t\treturn (self.data >> (reserveIndex * 2 + 1)) & 1 != 0;\n\t}\n\n\t/**\n\t * @dev Used to validate if a user has been borrowing from any reserve\n\t * @param self The configuration object\n\t * @return True if the user has been borrowing any reserve, false otherwise\n\t **/\n\tfunction isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\n\t\treturn self.data & BORROWING_MASK != 0;\n\t}\n\n\t/**\n\t * @dev Used to validate if a user has not been using any reserve\n\t * @param self The configuration object\n\t * @return True if the user has been borrowing any reserve, false otherwise\n\t **/\n\tfunction isEmpty(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\n\t\treturn self.data == 0;\n\t}\n}\n"
    },
    "contracts/lending/libraries/helpers/Errors.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title Errors library\n * @author Aave\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\n * @dev Error messages prefix glossary:\n *  - VL = ValidationLogic\n *  - MATH = Math libraries\n *  - CT = Common errors between tokens (AToken, VariableDebtToken and StableDebtToken)\n *  - AT = AToken\n *  - SDT = StableDebtToken\n *  - VDT = VariableDebtToken\n *  - LP = LendingPool\n *  - LPAPR = LendingPoolAddressesProviderRegistry\n *  - LPC = LendingPoolConfiguration\n *  - RL = ReserveLogic\n *  - LPCM = LendingPoolCollateralManager\n *  - P = Pausable\n */\nlibrary Errors {\n\t//common errors\n\tstring public constant CALLER_NOT_POOL_ADMIN = \"33\"; // 'The caller must be the pool admin'\n\tstring public constant BORROW_ALLOWANCE_NOT_ENOUGH = \"59\"; // User borrows on behalf, but allowance are too small\n\n\t//contract specific errors\n\tstring public constant VL_INVALID_AMOUNT = \"1\"; // 'Amount must be greater than 0'\n\tstring public constant VL_NO_ACTIVE_RESERVE = \"2\"; // 'Action requires an active reserve'\n\tstring public constant VL_RESERVE_FROZEN = \"3\"; // 'Action cannot be performed because the reserve is frozen'\n\tstring public constant VL_CURRENT_AVAILABLE_LIQUIDITY_NOT_ENOUGH = \"4\"; // 'The current liquidity is not enough'\n\tstring public constant VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE = \"5\"; // 'User cannot withdraw more than the available balance'\n\tstring public constant VL_TRANSFER_NOT_ALLOWED = \"6\"; // 'Transfer cannot be allowed.'\n\tstring public constant VL_BORROWING_NOT_ENABLED = \"7\"; // 'Borrowing is not enabled'\n\tstring public constant VL_INVALID_INTEREST_RATE_MODE_SELECTED = \"8\"; // 'Invalid interest rate mode selected'\n\tstring public constant VL_COLLATERAL_BALANCE_IS_0 = \"9\"; // 'The collateral balance is 0'\n\tstring public constant VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = \"10\"; // 'Health factor is lesser than the liquidation threshold'\n\tstring public constant VL_COLLATERAL_CANNOT_COVER_NEW_BORROW = \"11\"; // 'There is not enough collateral to cover a new borrow'\n\tstring public constant VL_STABLE_BORROWING_NOT_ENABLED = \"12\"; // stable borrowing not enabled\n\tstring public constant VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY = \"13\"; // collateral is (mostly) the same currency that is being borrowed\n\tstring public constant VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = \"14\"; // 'The requested amount is greater than the max loan size in stable rate mode\n\tstring public constant VL_NO_DEBT_OF_SELECTED_TYPE = \"15\"; // 'for repayment of stable debt, the user needs to have stable debt, otherwise, he needs to have variable debt'\n\tstring public constant VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = \"16\"; // 'To repay on behalf of an user an explicit amount to repay is needed'\n\tstring public constant VL_NO_STABLE_RATE_LOAN_IN_RESERVE = \"17\"; // 'User does not have a stable rate loan in progress on this reserve'\n\tstring public constant VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE = \"18\"; // 'User does not have a variable rate loan in progress on this reserve'\n\tstring public constant VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0 = \"19\"; // 'The underlying balance needs to be greater than 0'\n\tstring public constant VL_DEPOSIT_ALREADY_IN_USE = \"20\"; // 'User deposit is already being used as collateral'\n\tstring public constant LP_NOT_ENOUGH_STABLE_BORROW_BALANCE = \"21\"; // 'User does not have any stable rate loan for this reserve'\n\tstring public constant LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = \"22\"; // 'Interest rate rebalance conditions were not met'\n\tstring public constant LP_LIQUIDATION_CALL_FAILED = \"23\"; // 'Liquidation call failed'\n\tstring public constant LP_NOT_ENOUGH_LIQUIDITY_TO_BORROW = \"24\"; // 'There is not enough liquidity available to borrow'\n\tstring public constant LP_REQUESTED_AMOUNT_TOO_SMALL = \"25\"; // 'The requested amount is too small for a FlashLoan.'\n\tstring public constant LP_INCONSISTENT_PROTOCOL_ACTUAL_BALANCE = \"26\"; // 'The actual balance of the protocol is inconsistent'\n\tstring public constant LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR = \"27\"; // 'The caller of the function is not the lending pool configurator'\n\tstring public constant LP_INCONSISTENT_FLASHLOAN_PARAMS = \"28\";\n\tstring public constant CT_CALLER_MUST_BE_LENDING_POOL = \"29\"; // 'The caller of this function must be a lending pool'\n\tstring public constant CT_CANNOT_GIVE_ALLOWANCE_TO_HIMSELF = \"30\"; // 'User cannot give allowance to himself'\n\tstring public constant CT_TRANSFER_AMOUNT_NOT_GT_0 = \"31\"; // 'Transferred amount needs to be greater than zero'\n\tstring public constant RL_RESERVE_ALREADY_INITIALIZED = \"32\"; // 'Reserve has already been initialized'\n\tstring public constant LPC_RESERVE_LIQUIDITY_NOT_0 = \"34\"; // 'The liquidity of the reserve needs to be 0'\n\tstring public constant LPC_INVALID_ATOKEN_POOL_ADDRESS = \"35\"; // 'The liquidity of the reserve needs to be 0'\n\tstring public constant LPC_INVALID_STABLE_DEBT_TOKEN_POOL_ADDRESS = \"36\"; // 'The liquidity of the reserve needs to be 0'\n\tstring public constant LPC_INVALID_VARIABLE_DEBT_TOKEN_POOL_ADDRESS = \"37\"; // 'The liquidity of the reserve needs to be 0'\n\tstring public constant LPC_INVALID_STABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = \"38\"; // 'The liquidity of the reserve needs to be 0'\n\tstring public constant LPC_INVALID_VARIABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = \"39\"; // 'The liquidity of the reserve needs to be 0'\n\tstring public constant LPC_INVALID_ADDRESSES_PROVIDER_ID = \"40\"; // 'The liquidity of the reserve needs to be 0'\n\tstring public constant LPC_INVALID_CONFIGURATION = \"75\"; // 'Invalid risk parameters for the reserve'\n\tstring public constant LPC_CALLER_NOT_EMERGENCY_ADMIN = \"76\"; // 'The caller must be the emergency admin'\n\tstring public constant LPAPR_PROVIDER_NOT_REGISTERED = \"41\"; // 'Provider is not registered'\n\tstring public constant LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD = \"42\"; // 'Health factor is not below the threshold'\n\tstring public constant LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED = \"43\"; // 'The collateral chosen cannot be liquidated'\n\tstring public constant LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = \"44\"; // 'User did not borrow the specified currency'\n\tstring public constant LPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE = \"45\"; // \"There isn't enough liquidity available to liquidate\"\n\tstring public constant LPCM_NO_ERRORS = \"46\"; // 'No errors'\n\tstring public constant LP_INVALID_FLASHLOAN_MODE = \"47\"; //Invalid flashloan mode selected\n\tstring public constant MATH_MULTIPLICATION_OVERFLOW = \"48\";\n\tstring public constant MATH_ADDITION_OVERFLOW = \"49\";\n\tstring public constant MATH_DIVISION_BY_ZERO = \"50\";\n\tstring public constant RL_LIQUIDITY_INDEX_OVERFLOW = \"51\"; //  Liquidity index overflows uint128\n\tstring public constant RL_VARIABLE_BORROW_INDEX_OVERFLOW = \"52\"; //  Variable borrow index overflows uint128\n\tstring public constant RL_LIQUIDITY_RATE_OVERFLOW = \"53\"; //  Liquidity rate overflows uint128\n\tstring public constant RL_VARIABLE_BORROW_RATE_OVERFLOW = \"54\"; //  Variable borrow rate overflows uint128\n\tstring public constant RL_STABLE_BORROW_RATE_OVERFLOW = \"55\"; //  Stable borrow rate overflows uint128\n\tstring public constant CT_INVALID_MINT_AMOUNT = \"56\"; //invalid amount to mint\n\tstring public constant LP_FAILED_REPAY_WITH_COLLATERAL = \"57\";\n\tstring public constant CT_INVALID_BURN_AMOUNT = \"58\"; //invalid amount to burn\n\tstring public constant LP_FAILED_COLLATERAL_SWAP = \"60\";\n\tstring public constant LP_INVALID_EQUAL_ASSETS_TO_SWAP = \"61\";\n\tstring public constant LP_REENTRANCY_NOT_ALLOWED = \"62\";\n\tstring public constant LP_CALLER_MUST_BE_AN_ATOKEN = \"63\";\n\tstring public constant LP_IS_PAUSED = \"64\"; // 'Pool is paused'\n\tstring public constant LP_NO_MORE_RESERVES_ALLOWED = \"65\";\n\tstring public constant LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN = \"66\";\n\tstring public constant RC_INVALID_LTV = \"67\";\n\tstring public constant RC_INVALID_LIQ_THRESHOLD = \"68\";\n\tstring public constant RC_INVALID_LIQ_BONUS = \"69\";\n\tstring public constant RC_INVALID_DECIMALS = \"70\";\n\tstring public constant RC_INVALID_RESERVE_FACTOR = \"71\";\n\tstring public constant LPAPR_INVALID_ADDRESSES_PROVIDER_ID = \"72\";\n\tstring public constant VL_INCONSISTENT_FLASHLOAN_PARAMS = \"73\";\n\tstring public constant LP_INCONSISTENT_PARAMS_LENGTH = \"74\";\n\tstring public constant UL_INVALID_INDEX = \"77\";\n\tstring public constant LP_NOT_CONTRACT = \"78\";\n\tstring public constant SDT_STABLE_DEBT_OVERFLOW = \"79\";\n\tstring public constant SDT_BURN_EXCEEDS_BALANCE = \"80\";\n\n\tenum CollateralManagerErrors {\n\t\tNO_ERROR,\n\t\tNO_COLLATERAL_AVAILABLE,\n\t\tCOLLATERAL_CANNOT_BE_LIQUIDATED,\n\t\tCURRRENCY_NOT_BORROWED,\n\t\tHEALTH_FACTOR_ABOVE_THRESHOLD,\n\t\tNOT_ENOUGH_LIQUIDITY,\n\t\tNO_ACTIVE_RESERVE,\n\t\tHEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD,\n\t\tINVALID_EQUAL_ASSETS_TO_SWAP,\n\t\tFROZEN_RESERVE\n\t}\n}\n"
    },
    "contracts/lending/libraries/helpers/Helpers.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\n/**\n * @title Helpers library\n * @author Aave\n */\nlibrary Helpers {\n\t/**\n\t * @dev Fetches the user current stable and variable debt balances\n\t * @param user The user address\n\t * @param reserve The reserve data object\n\t * @return The stable and variable debt balance\n\t **/\n\tfunction getUserCurrentDebt(\n\t\taddress user,\n\t\tDataTypes.ReserveData storage reserve\n\t) internal view returns (uint256, uint256) {\n\t\treturn (\n\t\t\tIERC20(reserve.stableDebtTokenAddress).balanceOf(user),\n\t\t\tIERC20(reserve.variableDebtTokenAddress).balanceOf(user)\n\t\t);\n\t}\n\n\tfunction getUserCurrentDebtMemory(\n\t\taddress user,\n\t\tDataTypes.ReserveData memory reserve\n\t) internal view returns (uint256, uint256) {\n\t\treturn (\n\t\t\tIERC20(reserve.stableDebtTokenAddress).balanceOf(user),\n\t\t\tIERC20(reserve.variableDebtTokenAddress).balanceOf(user)\n\t\t);\n\t}\n}\n"
    },
    "contracts/lending/libraries/logic/GenericLogic.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {UserConfiguration} from \"../configuration/UserConfiguration.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {IPriceOracleGetter} from \"../../../interfaces/IPriceOracleGetter.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\n/**\n * @title GenericLogic library\n * @author Aave\n * @title Implements protocol-level logic to calculate and validate the state of a user\n */\nlibrary GenericLogic {\n\tusing ReserveLogic for DataTypes.ReserveData;\n\tusing SafeMath for uint256;\n\tusing WadRayMath for uint256;\n\tusing PercentageMath for uint256;\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\tusing UserConfiguration for DataTypes.UserConfigurationMap;\n\n\tuint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1 ether;\n\n\tstruct balanceDecreaseAllowedLocalVars {\n\t\tuint256 decimals;\n\t\tuint256 liquidationThreshold;\n\t\tuint256 totalCollateralInETH;\n\t\tuint256 totalDebtInETH;\n\t\tuint256 avgLiquidationThreshold;\n\t\tuint256 amountToDecreaseInETH;\n\t\tuint256 collateralBalanceAfterDecrease;\n\t\tuint256 liquidationThresholdAfterDecrease;\n\t\tuint256 healthFactorAfterDecrease;\n\t\tbool reserveUsageAsCollateralEnabled;\n\t}\n\n\t/**\n\t * @dev Checks if a specific balance decrease is allowed\n\t * (i.e. doesn't bring the user borrow position health factor under HEALTH_FACTOR_LIQUIDATION_THRESHOLD)\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param user The address of the user\n\t * @param amount The amount to decrease\n\t * @param reservesData The data of all the reserves\n\t * @param userConfig The user configuration\n\t * @param reserves The list of all the active reserves\n\t * @param oracle The address of the oracle contract\n\t * @return true if the decrease of the balance is allowed\n\t **/\n\tfunction balanceDecreaseAllowed(\n\t\taddress asset,\n\t\taddress user,\n\t\tuint256 amount,\n\t\tmapping(address => DataTypes.ReserveData) storage reservesData,\n\t\tDataTypes.UserConfigurationMap calldata userConfig,\n\t\tmapping(uint256 => address) storage reserves,\n\t\tuint256 reservesCount,\n\t\taddress oracle\n\t) external view returns (bool) {\n\t\tif (!userConfig.isBorrowingAny() || !userConfig.isUsingAsCollateral(reservesData[asset].id)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tbalanceDecreaseAllowedLocalVars memory vars;\n\n\t\t(, vars.liquidationThreshold, , vars.decimals, ) = reservesData[asset].configuration.getParams();\n\n\t\tif (vars.liquidationThreshold == 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\t(vars.totalCollateralInETH, vars.totalDebtInETH, , vars.avgLiquidationThreshold, ) = calculateUserAccountData(\n\t\t\tuser,\n\t\t\treservesData,\n\t\t\tuserConfig,\n\t\t\treserves,\n\t\t\treservesCount,\n\t\t\toracle\n\t\t);\n\n\t\tif (vars.totalDebtInETH == 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tvars.amountToDecreaseInETH = IPriceOracleGetter(oracle).getAssetPrice(asset).mul(amount).div(\n\t\t\t10 ** vars.decimals\n\t\t);\n\n\t\tvars.collateralBalanceAfterDecrease = vars.totalCollateralInETH.sub(vars.amountToDecreaseInETH);\n\n\t\t//if there is a borrow, there can't be 0 collateral\n\t\tif (vars.collateralBalanceAfterDecrease == 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvars.liquidationThresholdAfterDecrease = vars\n\t\t\t.totalCollateralInETH\n\t\t\t.mul(vars.avgLiquidationThreshold)\n\t\t\t.sub(vars.amountToDecreaseInETH.mul(vars.liquidationThreshold))\n\t\t\t.div(vars.collateralBalanceAfterDecrease);\n\n\t\tuint256 healthFactorAfterDecrease = calculateHealthFactorFromBalances(\n\t\t\tvars.collateralBalanceAfterDecrease,\n\t\t\tvars.totalDebtInETH,\n\t\t\tvars.liquidationThresholdAfterDecrease\n\t\t);\n\n\t\treturn healthFactorAfterDecrease >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\n\t}\n\n\tstruct CalculateUserAccountDataVars {\n\t\tuint256 reserveUnitPrice;\n\t\tuint256 tokenUnit;\n\t\tuint256 compoundedLiquidityBalance;\n\t\tuint256 compoundedBorrowBalance;\n\t\tuint256 decimals;\n\t\tuint256 ltv;\n\t\tuint256 liquidationThreshold;\n\t\tuint256 i;\n\t\tuint256 healthFactor;\n\t\tuint256 totalCollateralInETH;\n\t\tuint256 totalDebtInETH;\n\t\tuint256 avgLtv;\n\t\tuint256 avgLiquidationThreshold;\n\t\tuint256 reservesLength;\n\t\tbool healthFactorBelowThreshold;\n\t\taddress currentReserveAddress;\n\t\tbool usageAsCollateralEnabled;\n\t\tbool userUsesReserveAsCollateral;\n\t}\n\n\t/**\n\t * @dev Calculates the user data across the reserves.\n\t * this includes the total liquidity/collateral/borrow balances in ETH,\n\t * the average Loan To Value, the average Liquidation Ratio, and the Health factor.\n\t * @param user The address of the user\n\t * @param reservesData Data of all the reserves\n\t * @param userConfig The configuration of the user\n\t * @param reserves The list of the available reserves\n\t * @param oracle The price oracle address\n\t * @return The total collateral and total debt of the user in ETH, the avg ltv, liquidation threshold and the HF\n\t **/\n\tfunction calculateUserAccountData(\n\t\taddress user,\n\t\tmapping(address => DataTypes.ReserveData) storage reservesData,\n\t\tDataTypes.UserConfigurationMap memory userConfig,\n\t\tmapping(uint256 => address) storage reserves,\n\t\tuint256 reservesCount,\n\t\taddress oracle\n\t) internal view returns (uint256, uint256, uint256, uint256, uint256) {\n\t\tCalculateUserAccountDataVars memory vars;\n\n\t\tif (userConfig.isEmpty()) {\n\t\t\treturn (0, 0, 0, 0, type(uint256).max);\n\t\t}\n\t\tfor (vars.i = 0; vars.i < reservesCount; vars.i++) {\n\t\t\tif (!userConfig.isUsingAsCollateralOrBorrowing(vars.i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvars.currentReserveAddress = reserves[vars.i];\n\t\t\tDataTypes.ReserveData storage currentReserve = reservesData[vars.currentReserveAddress];\n\n\t\t\t(vars.ltv, vars.liquidationThreshold, , vars.decimals, ) = currentReserve.configuration.getParams();\n\n\t\t\tvars.tokenUnit = 10 ** vars.decimals;\n\t\t\tvars.reserveUnitPrice = IPriceOracleGetter(oracle).getAssetPrice(vars.currentReserveAddress);\n\n\t\t\tif (vars.liquidationThreshold != 0 && userConfig.isUsingAsCollateral(vars.i)) {\n\t\t\t\tvars.compoundedLiquidityBalance = IERC20(currentReserve.aTokenAddress).balanceOf(user);\n\n\t\t\t\tuint256 liquidityBalanceETH = vars.reserveUnitPrice.mul(vars.compoundedLiquidityBalance).div(\n\t\t\t\t\tvars.tokenUnit\n\t\t\t\t);\n\n\t\t\t\tvars.totalCollateralInETH = vars.totalCollateralInETH.add(liquidityBalanceETH);\n\n\t\t\t\tvars.avgLtv = vars.avgLtv.add(liquidityBalanceETH.mul(vars.ltv));\n\t\t\t\tvars.avgLiquidationThreshold = vars.avgLiquidationThreshold.add(\n\t\t\t\t\tliquidityBalanceETH.mul(vars.liquidationThreshold)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (userConfig.isBorrowing(vars.i)) {\n\t\t\t\tvars.compoundedBorrowBalance = IERC20(currentReserve.stableDebtTokenAddress).balanceOf(user);\n\t\t\t\tvars.compoundedBorrowBalance = vars.compoundedBorrowBalance.add(\n\t\t\t\t\tIERC20(currentReserve.variableDebtTokenAddress).balanceOf(user)\n\t\t\t\t);\n\n\t\t\t\tvars.totalDebtInETH = vars.totalDebtInETH.add(\n\t\t\t\t\tvars.reserveUnitPrice.mul(vars.compoundedBorrowBalance).div(vars.tokenUnit)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tvars.avgLtv = vars.totalCollateralInETH > 0 ? vars.avgLtv.div(vars.totalCollateralInETH) : 0;\n\t\tvars.avgLiquidationThreshold = vars.totalCollateralInETH > 0\n\t\t\t? vars.avgLiquidationThreshold.div(vars.totalCollateralInETH)\n\t\t\t: 0;\n\n\t\tvars.healthFactor = calculateHealthFactorFromBalances(\n\t\t\tvars.totalCollateralInETH,\n\t\t\tvars.totalDebtInETH,\n\t\t\tvars.avgLiquidationThreshold\n\t\t);\n\t\treturn (\n\t\t\tvars.totalCollateralInETH,\n\t\t\tvars.totalDebtInETH,\n\t\t\tvars.avgLtv,\n\t\t\tvars.avgLiquidationThreshold,\n\t\t\tvars.healthFactor\n\t\t);\n\t}\n\n\t/**\n\t * @dev Calculates the health factor from the corresponding balances\n\t * @param totalCollateralInETH The total collateral in ETH\n\t * @param totalDebtInETH The total debt in ETH\n\t * @param liquidationThreshold The avg liquidation threshold\n\t * @return The health factor calculated from the balances provided\n\t **/\n\tfunction calculateHealthFactorFromBalances(\n\t\tuint256 totalCollateralInETH,\n\t\tuint256 totalDebtInETH,\n\t\tuint256 liquidationThreshold\n\t) internal pure returns (uint256) {\n\t\tif (totalDebtInETH == 0) return type(uint256).max;\n\n\t\treturn (totalCollateralInETH.percentMul(liquidationThreshold)).wadDiv(totalDebtInETH);\n\t}\n\n\t/**\n\t * @dev Calculates the equivalent amount in ETH that an user can borrow, depending on the available collateral and the\n\t * average Loan To Value\n\t * @param totalCollateralInETH The total collateral in ETH\n\t * @param totalDebtInETH The total borrow balance\n\t * @param ltv The average loan to value\n\t * @return the amount available to borrow in ETH for the user\n\t **/\n\n\tfunction calculateAvailableBorrowsETH(\n\t\tuint256 totalCollateralInETH,\n\t\tuint256 totalDebtInETH,\n\t\tuint256 ltv\n\t) internal pure returns (uint256) {\n\t\tuint256 availableBorrowsETH = totalCollateralInETH.percentMul(ltv);\n\n\t\tif (availableBorrowsETH < totalDebtInETH) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tavailableBorrowsETH = availableBorrowsETH.sub(totalDebtInETH);\n\t\treturn availableBorrowsETH;\n\t}\n}\n"
    },
    "contracts/lending/libraries/logic/ReserveLogic.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IAToken} from \"../../../interfaces/IAToken.sol\";\nimport {IStableDebtToken} from \"../../../interfaces/IStableDebtToken.sol\";\nimport {IVariableDebtToken} from \"../../../interfaces/IVariableDebtToken.sol\";\nimport {IReserveInterestRateStrategy} from \"../../../interfaces/IReserveInterestRateStrategy.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {MathUtils} from \"../math/MathUtils.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\n/**\n * @title ReserveLogic library\n * @author Aave\n * @notice Implements the logic to update the reserves state\n */\nlibrary ReserveLogic {\n\tusing SafeMath for uint256;\n\tusing WadRayMath for uint256;\n\tusing PercentageMath for uint256;\n\tusing SafeERC20 for IERC20;\n\n\t/**\n\t * @dev Emitted when the state of a reserve is updated\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param liquidityRate The new liquidity rate\n\t * @param stableBorrowRate The new stable borrow rate\n\t * @param variableBorrowRate The new variable borrow rate\n\t * @param liquidityIndex The new liquidity index\n\t * @param variableBorrowIndex The new variable borrow index\n\t **/\n\tevent ReserveDataUpdated(\n\t\taddress indexed asset,\n\t\tuint256 liquidityRate,\n\t\tuint256 stableBorrowRate,\n\t\tuint256 variableBorrowRate,\n\t\tuint256 liquidityIndex,\n\t\tuint256 variableBorrowIndex\n\t);\n\n\tusing ReserveLogic for DataTypes.ReserveData;\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n\t/**\n\t * @dev Returns the ongoing normalized income for the reserve\n\t * A value of 1e27 means there is no income. As time passes, the income is accrued\n\t * A value of 2*1e27 means for each unit of asset one unit of income has been accrued\n\t * @param reserve The reserve object\n\t * @return the normalized income. expressed in ray\n\t **/\n\tfunction getNormalizedIncome(DataTypes.ReserveData storage reserve) internal view returns (uint256) {\n\t\tuint40 timestamp = reserve.lastUpdateTimestamp;\n\n\t\t//solium-disable-next-line\n\t\tif (timestamp == uint40(block.timestamp)) {\n\t\t\t//if the index was updated in the same block, no need to perform any calculation\n\t\t\treturn reserve.liquidityIndex;\n\t\t}\n\n\t\tuint256 cumulated = MathUtils.calculateLinearInterest(reserve.currentLiquidityRate, timestamp).rayMul(\n\t\t\treserve.liquidityIndex\n\t\t);\n\n\t\treturn cumulated;\n\t}\n\n\t/**\n\t * @dev Returns the ongoing normalized variable debt for the reserve\n\t * A value of 1e27 means there is no debt. As time passes, the income is accrued\n\t * A value of 2*1e27 means that for each unit of debt, one unit worth of interest has been accumulated\n\t * @param reserve The reserve object\n\t * @return The normalized variable debt. expressed in ray\n\t **/\n\tfunction getNormalizedDebt(DataTypes.ReserveData storage reserve) internal view returns (uint256) {\n\t\tuint40 timestamp = reserve.lastUpdateTimestamp;\n\n\t\t//solium-disable-next-line\n\t\tif (timestamp == uint40(block.timestamp)) {\n\t\t\t//if the index was updated in the same block, no need to perform any calculation\n\t\t\treturn reserve.variableBorrowIndex;\n\t\t}\n\n\t\tuint256 cumulated = MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp).rayMul(\n\t\t\treserve.variableBorrowIndex\n\t\t);\n\n\t\treturn cumulated;\n\t}\n\n\t/**\n\t * @dev Updates the liquidity cumulative index and the variable borrow index.\n\t * @param reserve the reserve object\n\t **/\n\tfunction updateState(DataTypes.ReserveData storage reserve) internal {\n\t\tuint256 scaledVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress).scaledTotalSupply();\n\t\tuint256 previousVariableBorrowIndex = reserve.variableBorrowIndex;\n\t\tuint256 previousLiquidityIndex = reserve.liquidityIndex;\n\t\tuint40 lastUpdatedTimestamp = reserve.lastUpdateTimestamp;\n\n\t\t(uint256 newLiquidityIndex, uint256 newVariableBorrowIndex) = _updateIndexes(\n\t\t\treserve,\n\t\t\tscaledVariableDebt,\n\t\t\tpreviousLiquidityIndex,\n\t\t\tpreviousVariableBorrowIndex,\n\t\t\tlastUpdatedTimestamp\n\t\t);\n\n\t\t_mintToTreasury(\n\t\t\treserve,\n\t\t\tscaledVariableDebt,\n\t\t\tpreviousVariableBorrowIndex,\n\t\t\tnewLiquidityIndex,\n\t\t\tnewVariableBorrowIndex,\n\t\t\tlastUpdatedTimestamp\n\t\t);\n\t}\n\n\t/**\n\t * @dev Accumulates a predefined amount of asset to the reserve as a fixed, instantaneous income. Used for example to accumulate\n\t * the flashloan fee to the reserve, and spread it between all the depositors\n\t * @param reserve The reserve object\n\t * @param totalLiquidity The total liquidity available in the reserve\n\t * @param amount The amount to accomulate\n\t **/\n\tfunction cumulateToLiquidityIndex(\n\t\tDataTypes.ReserveData storage reserve,\n\t\tuint256 totalLiquidity,\n\t\tuint256 amount\n\t) internal {\n\t\tuint256 amountToLiquidityRatio = amount.wadToRay().rayDiv(totalLiquidity.wadToRay());\n\n\t\tuint256 result = amountToLiquidityRatio.add(WadRayMath.ray());\n\n\t\tresult = result.rayMul(reserve.liquidityIndex);\n\t\trequire(result <= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW);\n\n\t\treserve.liquidityIndex = uint128(result);\n\t}\n\n\t/**\n\t * @dev Initializes a reserve\n\t * @param reserve The reserve object\n\t * @param aTokenAddress The address of the overlying atoken contract\n\t * @param interestRateStrategyAddress The address of the interest rate strategy contract\n\t **/\n\tfunction init(\n\t\tDataTypes.ReserveData storage reserve,\n\t\taddress aTokenAddress,\n\t\taddress stableDebtTokenAddress,\n\t\taddress variableDebtTokenAddress,\n\t\taddress interestRateStrategyAddress\n\t) external {\n\t\trequire(reserve.aTokenAddress == address(0), Errors.RL_RESERVE_ALREADY_INITIALIZED);\n\n\t\treserve.liquidityIndex = uint128(WadRayMath.ray());\n\t\treserve.variableBorrowIndex = uint128(WadRayMath.ray());\n\t\treserve.aTokenAddress = aTokenAddress;\n\t\treserve.stableDebtTokenAddress = stableDebtTokenAddress;\n\t\treserve.variableDebtTokenAddress = variableDebtTokenAddress;\n\t\treserve.interestRateStrategyAddress = interestRateStrategyAddress;\n\t}\n\n\tstruct UpdateInterestRatesLocalVars {\n\t\taddress stableDebtTokenAddress;\n\t\tuint256 availableLiquidity;\n\t\tuint256 totalStableDebt;\n\t\tuint256 newLiquidityRate;\n\t\tuint256 newStableRate;\n\t\tuint256 newVariableRate;\n\t\tuint256 avgStableRate;\n\t\tuint256 totalVariableDebt;\n\t}\n\n\t/**\n\t * @dev Updates the reserve current stable borrow rate, the current variable borrow rate and the current liquidity rate\n\t * @param reserve The address of the reserve to be updated\n\t * @param liquidityAdded The amount of liquidity added to the protocol (deposit or repay) in the previous action\n\t * @param liquidityTaken The amount of liquidity taken from the protocol (redeem or borrow)\n\t **/\n\tfunction updateInterestRates(\n\t\tDataTypes.ReserveData storage reserve,\n\t\taddress reserveAddress,\n\t\taddress aTokenAddress,\n\t\tuint256 liquidityAdded,\n\t\tuint256 liquidityTaken\n\t) internal {\n\t\tUpdateInterestRatesLocalVars memory vars;\n\n\t\tvars.stableDebtTokenAddress = reserve.stableDebtTokenAddress;\n\n\t\t(vars.totalStableDebt, vars.avgStableRate) = IStableDebtToken(vars.stableDebtTokenAddress)\n\t\t\t.getTotalSupplyAndAvgRate();\n\n\t\t//calculates the total variable debt locally using the scaled total supply instead\n\t\t//of totalSupply(), as it's noticeably cheaper. Also, the index has been\n\t\t//updated by the previous updateState() call\n\t\tvars.totalVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress).scaledTotalSupply().rayMul(\n\t\t\treserve.variableBorrowIndex\n\t\t);\n\n\t\t(vars.newLiquidityRate, vars.newStableRate, vars.newVariableRate) = IReserveInterestRateStrategy(\n\t\t\treserve.interestRateStrategyAddress\n\t\t).calculateInterestRates(\n\t\t\t\treserveAddress,\n\t\t\t\taTokenAddress,\n\t\t\t\tliquidityAdded,\n\t\t\t\tliquidityTaken,\n\t\t\t\tvars.totalStableDebt,\n\t\t\t\tvars.totalVariableDebt,\n\t\t\t\tvars.avgStableRate,\n\t\t\t\treserve.configuration.getReserveFactor()\n\t\t\t);\n\t\trequire(vars.newLiquidityRate <= type(uint128).max, Errors.RL_LIQUIDITY_RATE_OVERFLOW);\n\t\trequire(vars.newStableRate <= type(uint128).max, Errors.RL_STABLE_BORROW_RATE_OVERFLOW);\n\t\trequire(vars.newVariableRate <= type(uint128).max, Errors.RL_VARIABLE_BORROW_RATE_OVERFLOW);\n\n\t\treserve.currentLiquidityRate = uint128(vars.newLiquidityRate);\n\t\treserve.currentStableBorrowRate = uint128(vars.newStableRate);\n\t\treserve.currentVariableBorrowRate = uint128(vars.newVariableRate);\n\n\t\temit ReserveDataUpdated(\n\t\t\treserveAddress,\n\t\t\tvars.newLiquidityRate,\n\t\t\tvars.newStableRate,\n\t\t\tvars.newVariableRate,\n\t\t\treserve.liquidityIndex,\n\t\t\treserve.variableBorrowIndex\n\t\t);\n\t}\n\n\tstruct MintToTreasuryLocalVars {\n\t\tuint256 currentStableDebt;\n\t\tuint256 principalStableDebt;\n\t\tuint256 previousStableDebt;\n\t\tuint256 currentVariableDebt;\n\t\tuint256 previousVariableDebt;\n\t\tuint256 avgStableRate;\n\t\tuint256 cumulatedStableInterest;\n\t\tuint256 totalDebtAccrued;\n\t\tuint256 amountToMint;\n\t\tuint256 reserveFactor;\n\t\tuint40 stableSupplyUpdatedTimestamp;\n\t}\n\n\t/**\n\t * @dev Mints part of the repaid interest to the reserve treasury as a function of the reserveFactor for the\n\t * specific asset.\n\t * @param reserve The reserve reserve to be updated\n\t * @param scaledVariableDebt The current scaled total variable debt\n\t * @param previousVariableBorrowIndex The variable borrow index before the last accumulation of the interest\n\t * @param newLiquidityIndex The new liquidity index\n\t * @param newVariableBorrowIndex The variable borrow index after the last accumulation of the interest\n\t **/\n\tfunction _mintToTreasury(\n\t\tDataTypes.ReserveData storage reserve,\n\t\tuint256 scaledVariableDebt,\n\t\tuint256 previousVariableBorrowIndex,\n\t\tuint256 newLiquidityIndex,\n\t\tuint256 newVariableBorrowIndex,\n\t\tuint40 timestamp\n\t) internal {\n\t\tMintToTreasuryLocalVars memory vars;\n\n\t\tvars.reserveFactor = reserve.configuration.getReserveFactor();\n\n\t\tif (vars.reserveFactor == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t//fetching the principal, total stable debt and the avg stable rate\n\t\t(\n\t\t\tvars.principalStableDebt,\n\t\t\tvars.currentStableDebt,\n\t\t\tvars.avgStableRate,\n\t\t\tvars.stableSupplyUpdatedTimestamp\n\t\t) = IStableDebtToken(reserve.stableDebtTokenAddress).getSupplyData();\n\n\t\t//calculate the last principal variable debt\n\t\tvars.previousVariableDebt = scaledVariableDebt.rayMul(previousVariableBorrowIndex);\n\n\t\t//calculate the new total supply after accumulation of the index\n\t\tvars.currentVariableDebt = scaledVariableDebt.rayMul(newVariableBorrowIndex);\n\n\t\t//calculate the stable debt until the last timestamp update\n\t\tvars.cumulatedStableInterest = MathUtils.calculateCompoundedInterest(\n\t\t\tvars.avgStableRate,\n\t\t\tvars.stableSupplyUpdatedTimestamp,\n\t\t\ttimestamp\n\t\t);\n\n\t\tvars.previousStableDebt = vars.principalStableDebt.rayMul(vars.cumulatedStableInterest);\n\n\t\t//debt accrued is the sum of the current debt minus the sum of the debt at the last update\n\t\tvars.totalDebtAccrued = vars.currentVariableDebt.add(vars.currentStableDebt).sub(vars.previousVariableDebt).sub(\n\t\t\tvars.previousStableDebt\n\t\t);\n\n\t\tvars.amountToMint = vars.totalDebtAccrued.percentMul(vars.reserveFactor);\n\n\t\tif (vars.amountToMint != 0) {\n\t\t\tIAToken(reserve.aTokenAddress).mintToTreasury(vars.amountToMint, newLiquidityIndex);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Updates the reserve indexes and the timestamp of the update\n\t * @param reserve The reserve reserve to be updated\n\t * @param scaledVariableDebt The scaled variable debt\n\t * @param liquidityIndex The last stored liquidity index\n\t * @param variableBorrowIndex The last stored variable borrow index\n\t **/\n\tfunction _updateIndexes(\n\t\tDataTypes.ReserveData storage reserve,\n\t\tuint256 scaledVariableDebt,\n\t\tuint256 liquidityIndex,\n\t\tuint256 variableBorrowIndex,\n\t\tuint40 timestamp\n\t) internal returns (uint256, uint256) {\n\t\tuint256 currentLiquidityRate = reserve.currentLiquidityRate;\n\n\t\tuint256 newLiquidityIndex = liquidityIndex;\n\t\tuint256 newVariableBorrowIndex = variableBorrowIndex;\n\n\t\t//only cumulating if there is any income being produced\n\t\tif (currentLiquidityRate > 0) {\n\t\t\tuint256 cumulatedLiquidityInterest = MathUtils.calculateLinearInterest(currentLiquidityRate, timestamp);\n\t\t\tnewLiquidityIndex = cumulatedLiquidityInterest.rayMul(liquidityIndex);\n\t\t\trequire(newLiquidityIndex <= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW);\n\n\t\t\treserve.liquidityIndex = uint128(newLiquidityIndex);\n\n\t\t\t//as the liquidity rate might come only from stable rate loans, we need to ensure\n\t\t\t//that there is actual variable debt before accumulating\n\t\t\tif (scaledVariableDebt != 0) {\n\t\t\t\tuint256 cumulatedVariableBorrowInterest = MathUtils.calculateCompoundedInterest(\n\t\t\t\t\treserve.currentVariableBorrowRate,\n\t\t\t\t\ttimestamp\n\t\t\t\t);\n\t\t\t\tnewVariableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(variableBorrowIndex);\n\t\t\t\trequire(newVariableBorrowIndex <= type(uint128).max, Errors.RL_VARIABLE_BORROW_INDEX_OVERFLOW);\n\t\t\t\treserve.variableBorrowIndex = uint128(newVariableBorrowIndex);\n\t\t\t}\n\t\t}\n\n\t\t//solium-disable-next-line\n\t\treserve.lastUpdateTimestamp = uint40(block.timestamp);\n\t\treturn (newLiquidityIndex, newVariableBorrowIndex);\n\t}\n}\n"
    },
    "contracts/lending/libraries/logic/ValidationLogic.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {UserConfiguration} from \"../configuration/UserConfiguration.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {Helpers} from \"../helpers/Helpers.sol\";\nimport {IReserveInterestRateStrategy} from \"../../../interfaces/IReserveInterestRateStrategy.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\n/**\n * @title ReserveLogic library\n * @author Aave\n * @notice Implements functions to validate the different actions of the protocol\n */\nlibrary ValidationLogic {\n\tusing ReserveLogic for DataTypes.ReserveData;\n\tusing SafeMath for uint256;\n\tusing WadRayMath for uint256;\n\tusing PercentageMath for uint256;\n\tusing SafeERC20 for IERC20;\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\tusing UserConfiguration for DataTypes.UserConfigurationMap;\n\n\tuint256 public constant REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD = 4000;\n\tuint256 public constant REBALANCE_UP_USAGE_RATIO_THRESHOLD = 0.95 * 1e27; //usage ratio of 95%\n\n\t/**\n\t * @dev Validates a deposit action\n\t * @param reserve The reserve object on which the user is depositing\n\t * @param amount The amount to be deposited\n\t */\n\tfunction validateDeposit(DataTypes.ReserveData storage reserve, uint256 amount) external view {\n\t\t(bool isActive, bool isFrozen, , ) = reserve.configuration.getFlags();\n\n\t\trequire(amount != 0, Errors.VL_INVALID_AMOUNT);\n\t\trequire(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\t\trequire(!isFrozen, Errors.VL_RESERVE_FROZEN);\n\t}\n\n\t/**\n\t * @dev Validates a withdraw action\n\t * @param reserveAddress The address of the reserve\n\t * @param amount The amount to be withdrawn\n\t * @param userBalance The balance of the user\n\t * @param reservesData The reserves state\n\t * @param userConfig The user configuration\n\t * @param reserves The addresses of the reserves\n\t * @param reservesCount The number of reserves\n\t * @param oracle The price oracle\n\t */\n\tfunction validateWithdraw(\n\t\taddress reserveAddress,\n\t\tuint256 amount,\n\t\tuint256 userBalance,\n\t\tmapping(address => DataTypes.ReserveData) storage reservesData,\n\t\tDataTypes.UserConfigurationMap storage userConfig,\n\t\tmapping(uint256 => address) storage reserves,\n\t\tuint256 reservesCount,\n\t\taddress oracle\n\t) external view {\n\t\trequire(amount != 0, Errors.VL_INVALID_AMOUNT);\n\t\trequire(amount <= userBalance, Errors.VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE);\n\n\t\t(bool isActive, , , ) = reservesData[reserveAddress].configuration.getFlags();\n\t\trequire(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\n\t\trequire(\n\t\t\tGenericLogic.balanceDecreaseAllowed(\n\t\t\t\treserveAddress,\n\t\t\t\tmsg.sender,\n\t\t\t\tamount,\n\t\t\t\treservesData,\n\t\t\t\tuserConfig,\n\t\t\t\treserves,\n\t\t\t\treservesCount,\n\t\t\t\toracle\n\t\t\t),\n\t\t\tErrors.VL_TRANSFER_NOT_ALLOWED\n\t\t);\n\t}\n\n\tstruct ValidateBorrowLocalVars {\n\t\tuint256 currentLtv;\n\t\tuint256 currentLiquidationThreshold;\n\t\tuint256 amountOfCollateralNeededETH;\n\t\tuint256 userCollateralBalanceETH;\n\t\tuint256 userBorrowBalanceETH;\n\t\tuint256 availableLiquidity;\n\t\tuint256 healthFactor;\n\t\tbool isActive;\n\t\tbool isFrozen;\n\t\tbool borrowingEnabled;\n\t\tbool stableRateBorrowingEnabled;\n\t}\n\n\t/**\n\t * @dev Validates a borrow action\n\t * @param asset The address of the asset to borrow\n\t * @param reserve The reserve state from which the user is borrowing\n\t * @param userAddress The address of the user\n\t * @param amount The amount to be borrowed\n\t * @param amountInETH The amount to be borrowed, in ETH\n\t * @param interestRateMode The interest rate mode at which the user is borrowing\n\t * @param maxStableLoanPercent The max amount of the liquidity that can be borrowed at stable rate, in percentage\n\t * @param reservesData The state of all the reserves\n\t * @param userConfig The state of the user for the specific reserve\n\t * @param reserves The addresses of all the active reserves\n\t * @param oracle The price oracle\n\t */\n\n\tfunction validateBorrow(\n\t\taddress asset,\n\t\tDataTypes.ReserveData storage reserve,\n\t\taddress userAddress,\n\t\tuint256 amount,\n\t\tuint256 amountInETH,\n\t\tuint256 interestRateMode,\n\t\tuint256 maxStableLoanPercent,\n\t\tmapping(address => DataTypes.ReserveData) storage reservesData,\n\t\tDataTypes.UserConfigurationMap storage userConfig,\n\t\tmapping(uint256 => address) storage reserves,\n\t\tuint256 reservesCount,\n\t\taddress oracle\n\t) external view {\n\t\tValidateBorrowLocalVars memory vars;\n\n\t\t(vars.isActive, vars.isFrozen, vars.borrowingEnabled, vars.stableRateBorrowingEnabled) = reserve\n\t\t\t.configuration\n\t\t\t.getFlags();\n\n\t\trequire(vars.isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\t\trequire(!vars.isFrozen, Errors.VL_RESERVE_FROZEN);\n\t\trequire(amount != 0, Errors.VL_INVALID_AMOUNT);\n\n\t\trequire(vars.borrowingEnabled, Errors.VL_BORROWING_NOT_ENABLED);\n\n\t\t//validate interest rate mode\n\t\trequire(\n\t\t\tuint256(DataTypes.InterestRateMode.VARIABLE) == interestRateMode ||\n\t\t\t\tuint256(DataTypes.InterestRateMode.STABLE) == interestRateMode,\n\t\t\tErrors.VL_INVALID_INTEREST_RATE_MODE_SELECTED\n\t\t);\n\n\t\t(\n\t\t\tvars.userCollateralBalanceETH,\n\t\t\tvars.userBorrowBalanceETH,\n\t\t\tvars.currentLtv,\n\t\t\tvars.currentLiquidationThreshold,\n\t\t\tvars.healthFactor\n\t\t) = GenericLogic.calculateUserAccountData(\n\t\t\tuserAddress,\n\t\t\treservesData,\n\t\t\tuserConfig,\n\t\t\treserves,\n\t\t\treservesCount,\n\t\t\toracle\n\t\t);\n\n\t\trequire(vars.userCollateralBalanceETH > 0, Errors.VL_COLLATERAL_BALANCE_IS_0);\n\n\t\trequire(\n\t\t\tvars.healthFactor > GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n\t\t\tErrors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n\t\t);\n\n\t\t//add the current already borrowed amount to the amount requested to calculate the total collateral needed.\n\t\tvars.amountOfCollateralNeededETH = vars.userBorrowBalanceETH.add(amountInETH).percentDiv(vars.currentLtv); //LTV is calculated in percentage\n\n\t\trequire(\n\t\t\tvars.amountOfCollateralNeededETH <= vars.userCollateralBalanceETH,\n\t\t\tErrors.VL_COLLATERAL_CANNOT_COVER_NEW_BORROW\n\t\t);\n\n\t\t/**\n\t\t * Following conditions need to be met if the user is borrowing at a stable rate:\n\t\t * 1. Reserve must be enabled for stable rate borrowing\n\t\t * 2. Users cannot borrow from the reserve if their collateral is (mostly) the same currency\n\t\t *    they are borrowing, to prevent abuses.\n\t\t * 3. Users will be able to borrow only a portion of the total available liquidity\n\t\t **/\n\n\t\tif (interestRateMode == uint256(DataTypes.InterestRateMode.STABLE)) {\n\t\t\t//check if the borrow mode is stable and if stable rate borrowing is enabled on this reserve\n\n\t\t\trequire(vars.stableRateBorrowingEnabled, Errors.VL_STABLE_BORROWING_NOT_ENABLED);\n\n\t\t\trequire(\n\t\t\t\t!userConfig.isUsingAsCollateral(reserve.id) ||\n\t\t\t\t\treserve.configuration.getLtv() == 0 ||\n\t\t\t\t\tamount > IERC20(reserve.aTokenAddress).balanceOf(userAddress),\n\t\t\t\tErrors.VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY\n\t\t\t);\n\n\t\t\tvars.availableLiquidity = IERC20(asset).balanceOf(reserve.aTokenAddress);\n\n\t\t\t//calculate the max available loan size in stable rate mode as a percentage of the\n\t\t\t//available liquidity\n\t\t\tuint256 maxLoanSizeStable = vars.availableLiquidity.percentMul(maxStableLoanPercent);\n\n\t\t\trequire(amount <= maxLoanSizeStable, Errors.VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Validates a repay action\n\t * @param reserve The reserve state from which the user is repaying\n\t * @param amountSent The amount sent for the repayment. Can be an actual value or uint256(-1)\n\t * @param onBehalfOf The address of the user msg.sender is repaying for\n\t * @param stableDebt The borrow balance of the user\n\t * @param variableDebt The borrow balance of the user\n\t */\n\tfunction validateRepay(\n\t\tDataTypes.ReserveData storage reserve,\n\t\tuint256 amountSent,\n\t\tDataTypes.InterestRateMode rateMode,\n\t\taddress onBehalfOf,\n\t\tuint256 stableDebt,\n\t\tuint256 variableDebt\n\t) external view {\n\t\tbool isActive = reserve.configuration.getActive();\n\n\t\trequire(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\n\t\trequire(amountSent > 0, Errors.VL_INVALID_AMOUNT);\n\n\t\trequire(\n\t\t\t(stableDebt > 0 && DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.STABLE) ||\n\t\t\t\t(variableDebt > 0 && DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.VARIABLE),\n\t\t\tErrors.VL_NO_DEBT_OF_SELECTED_TYPE\n\t\t);\n\n\t\trequire(\n\t\t\tamountSent != type(uint256).max || msg.sender == onBehalfOf,\n\t\t\tErrors.VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF\n\t\t);\n\t}\n\n\t/**\n\t * @dev Validates a swap of borrow rate mode.\n\t * @param reserve The reserve state on which the user is swapping the rate\n\t * @param userConfig The user reserves configuration\n\t * @param stableDebt The stable debt of the user\n\t * @param variableDebt The variable debt of the user\n\t * @param currentRateMode The rate mode of the borrow\n\t */\n\tfunction validateSwapRateMode(\n\t\tDataTypes.ReserveData storage reserve,\n\t\tDataTypes.UserConfigurationMap storage userConfig,\n\t\tuint256 stableDebt,\n\t\tuint256 variableDebt,\n\t\tDataTypes.InterestRateMode currentRateMode\n\t) external view {\n\t\t(bool isActive, bool isFrozen, , bool stableRateEnabled) = reserve.configuration.getFlags();\n\n\t\trequire(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\t\trequire(!isFrozen, Errors.VL_RESERVE_FROZEN);\n\n\t\tif (currentRateMode == DataTypes.InterestRateMode.STABLE) {\n\t\t\trequire(stableDebt > 0, Errors.VL_NO_STABLE_RATE_LOAN_IN_RESERVE);\n\t\t} else if (currentRateMode == DataTypes.InterestRateMode.VARIABLE) {\n\t\t\trequire(variableDebt > 0, Errors.VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE);\n\t\t\t/**\n\t\t\t * user wants to swap to stable, before swapping we need to ensure that\n\t\t\t * 1. stable borrow rate is enabled on the reserve\n\t\t\t * 2. user is not trying to abuse the reserve by depositing\n\t\t\t * more collateral than he is borrowing, artificially lowering\n\t\t\t * the interest rate, borrowing at variable, and switching to stable\n\t\t\t **/\n\t\t\trequire(stableRateEnabled, Errors.VL_STABLE_BORROWING_NOT_ENABLED);\n\n\t\t\trequire(\n\t\t\t\t!userConfig.isUsingAsCollateral(reserve.id) ||\n\t\t\t\t\treserve.configuration.getLtv() == 0 ||\n\t\t\t\t\tstableDebt.add(variableDebt) > IERC20(reserve.aTokenAddress).balanceOf(msg.sender),\n\t\t\t\tErrors.VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY\n\t\t\t);\n\t\t} else {\n\t\t\trevert(Errors.VL_INVALID_INTEREST_RATE_MODE_SELECTED);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Validates a stable borrow rate rebalance action\n\t * @param reserve The reserve state on which the user is getting rebalanced\n\t * @param reserveAddress The address of the reserve\n\t * @param stableDebtToken The stable debt token instance\n\t * @param variableDebtToken The variable debt token instance\n\t * @param aTokenAddress The address of the aToken contract\n\t */\n\tfunction validateRebalanceStableBorrowRate(\n\t\tDataTypes.ReserveData storage reserve,\n\t\taddress reserveAddress,\n\t\tIERC20 stableDebtToken,\n\t\tIERC20 variableDebtToken,\n\t\taddress aTokenAddress\n\t) external view {\n\t\t(bool isActive, , , ) = reserve.configuration.getFlags();\n\n\t\trequire(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\n\t\t//if the usage ratio is below 95%, no rebalances are needed\n\t\tuint256 totalDebt = stableDebtToken.totalSupply().add(variableDebtToken.totalSupply()).wadToRay();\n\t\tuint256 availableLiquidity = IERC20(reserveAddress).balanceOf(aTokenAddress).wadToRay();\n\t\tuint256 usageRatio = totalDebt == 0 ? 0 : totalDebt.rayDiv(availableLiquidity.add(totalDebt));\n\n\t\t//if the liquidity rate is below REBALANCE_UP_THRESHOLD of the max variable APR at 95% usage,\n\t\t//then we allow rebalancing of the stable rate positions.\n\n\t\tuint256 currentLiquidityRate = reserve.currentLiquidityRate;\n\t\tuint256 maxVariableBorrowRate = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)\n\t\t\t.getMaxVariableBorrowRate();\n\n\t\trequire(\n\t\t\tusageRatio >= REBALANCE_UP_USAGE_RATIO_THRESHOLD &&\n\t\t\t\tcurrentLiquidityRate <= maxVariableBorrowRate.percentMul(REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD),\n\t\t\tErrors.LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET\n\t\t);\n\t}\n\n\t/**\n\t * @dev Validates the action of setting an asset as collateral\n\t * @param reserve The state of the reserve that the user is enabling or disabling as collateral\n\t * @param reserveAddress The address of the reserve\n\t * @param reservesData The data of all the reserves\n\t * @param userConfig The state of the user for the specific reserve\n\t * @param reserves The addresses of all the active reserves\n\t * @param oracle The price oracle\n\t */\n\tfunction validateSetUseReserveAsCollateral(\n\t\tDataTypes.ReserveData storage reserve,\n\t\taddress reserveAddress,\n\t\tbool useAsCollateral,\n\t\tmapping(address => DataTypes.ReserveData) storage reservesData,\n\t\tDataTypes.UserConfigurationMap storage userConfig,\n\t\tmapping(uint256 => address) storage reserves,\n\t\tuint256 reservesCount,\n\t\taddress oracle\n\t) external view {\n\t\tuint256 underlyingBalance = IERC20(reserve.aTokenAddress).balanceOf(msg.sender);\n\n\t\trequire(underlyingBalance > 0, Errors.VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0);\n\n\t\trequire(\n\t\t\tuseAsCollateral ||\n\t\t\t\tGenericLogic.balanceDecreaseAllowed(\n\t\t\t\t\treserveAddress,\n\t\t\t\t\tmsg.sender,\n\t\t\t\t\tunderlyingBalance,\n\t\t\t\t\treservesData,\n\t\t\t\t\tuserConfig,\n\t\t\t\t\treserves,\n\t\t\t\t\treservesCount,\n\t\t\t\t\toracle\n\t\t\t\t),\n\t\t\tErrors.VL_DEPOSIT_ALREADY_IN_USE\n\t\t);\n\t}\n\n\t/**\n\t * @dev Validates a flashloan action\n\t * @param assets The assets being flashborrowed\n\t * @param amounts The amounts for each asset being borrowed\n\t **/\n\tfunction validateFlashloan(address[] memory assets, uint256[] memory amounts) internal pure {\n\t\trequire(assets.length == amounts.length, Errors.VL_INCONSISTENT_FLASHLOAN_PARAMS);\n\t}\n\n\t/**\n\t * @dev Validates the liquidation action\n\t * @param collateralReserve The reserve data of the collateral\n\t * @param principalReserve The reserve data of the principal\n\t * @param userConfig The user configuration\n\t * @param userHealthFactor The user's health factor\n\t * @param userStableDebt Total stable debt balance of the user\n\t * @param userVariableDebt Total variable debt balance of the user\n\t **/\n\tfunction validateLiquidationCall(\n\t\tDataTypes.ReserveData storage collateralReserve,\n\t\tDataTypes.ReserveData storage principalReserve,\n\t\tDataTypes.UserConfigurationMap storage userConfig,\n\t\tuint256 userHealthFactor,\n\t\tuint256 userStableDebt,\n\t\tuint256 userVariableDebt\n\t) internal view returns (uint256, string memory) {\n\t\tif (!collateralReserve.configuration.getActive() || !principalReserve.configuration.getActive()) {\n\t\t\treturn (uint256(Errors.CollateralManagerErrors.NO_ACTIVE_RESERVE), Errors.VL_NO_ACTIVE_RESERVE);\n\t\t}\n\n\t\tif (userHealthFactor >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD) {\n\t\t\treturn (\n\t\t\t\tuint256(Errors.CollateralManagerErrors.HEALTH_FACTOR_ABOVE_THRESHOLD),\n\t\t\t\tErrors.LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD\n\t\t\t);\n\t\t}\n\n\t\tbool isCollateralEnabled = collateralReserve.configuration.getLiquidationThreshold() > 0 &&\n\t\t\tuserConfig.isUsingAsCollateral(collateralReserve.id);\n\n\t\t//if collateral isn't enabled as collateral by user, it cannot be liquidated\n\t\tif (!isCollateralEnabled) {\n\t\t\treturn (\n\t\t\t\tuint256(Errors.CollateralManagerErrors.COLLATERAL_CANNOT_BE_LIQUIDATED),\n\t\t\t\tErrors.LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED\n\t\t\t);\n\t\t}\n\n\t\tif (userStableDebt == 0 && userVariableDebt == 0) {\n\t\t\treturn (\n\t\t\t\tuint256(Errors.CollateralManagerErrors.CURRRENCY_NOT_BORROWED),\n\t\t\t\tErrors.LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER\n\t\t\t);\n\t\t}\n\n\t\treturn (uint256(Errors.CollateralManagerErrors.NO_ERROR), Errors.LPCM_NO_ERRORS);\n\t}\n\n\t/**\n\t * @dev Validates an aToken transfer\n\t * @param from The user from which the aTokens are being transferred\n\t * @param reservesData The state of all the reserves\n\t * @param userConfig The state of the user for the specific reserve\n\t * @param reserves The addresses of all the active reserves\n\t * @param oracle The price oracle\n\t */\n\tfunction validateTransfer(\n\t\taddress from,\n\t\tmapping(address => DataTypes.ReserveData) storage reservesData,\n\t\tDataTypes.UserConfigurationMap storage userConfig,\n\t\tmapping(uint256 => address) storage reserves,\n\t\tuint256 reservesCount,\n\t\taddress oracle\n\t) internal view {\n\t\t(, , , , uint256 healthFactor) = GenericLogic.calculateUserAccountData(\n\t\t\tfrom,\n\t\t\treservesData,\n\t\t\tuserConfig,\n\t\t\treserves,\n\t\t\treservesCount,\n\t\t\toracle\n\t\t);\n\n\t\trequire(healthFactor >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD, Errors.VL_TRANSFER_NOT_ALLOWED);\n\t}\n}\n"
    },
    "contracts/lending/libraries/math/MathUtils.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {WadRayMath} from \"./WadRayMath.sol\";\n\nlibrary MathUtils {\n\tusing SafeMath for uint256;\n\tusing WadRayMath for uint256;\n\n\t/// @dev Ignoring leap years\n\tuint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n\t/**\n\t * @dev Function to calculate the interest accumulated using a linear interest rate formula\n\t * @param rate The interest rate, in ray\n\t * @param lastUpdateTimestamp The timestamp of the last update of the interest\n\t * @return The interest rate linearly accumulated during the timeDelta, in ray\n\t **/\n\n\tfunction calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp) internal view returns (uint256) {\n\t\t//solium-disable-next-line\n\t\tuint256 timeDifference = block.timestamp.sub(uint256(lastUpdateTimestamp));\n\n\t\treturn (rate.mul(timeDifference) / SECONDS_PER_YEAR).add(WadRayMath.ray());\n\t}\n\n\t/**\n\t * @dev Function to calculate the interest using a compounded interest rate formula\n\t * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\n\t *\n\t *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\n\t *\n\t * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great gas cost reductions\n\t * The whitepaper contains reference to the approximation and a table showing the margin of error per different time periods\n\t *\n\t * @param rate The interest rate, in ray\n\t * @param lastUpdateTimestamp The timestamp of the last update of the interest\n\t * @return The interest rate compounded during the timeDelta, in ray\n\t **/\n\tfunction calculateCompoundedInterest(\n\t\tuint256 rate,\n\t\tuint40 lastUpdateTimestamp,\n\t\tuint256 currentTimestamp\n\t) internal pure returns (uint256) {\n\t\t//solium-disable-next-line\n\t\tuint256 exp = currentTimestamp.sub(uint256(lastUpdateTimestamp));\n\n\t\tif (exp == 0) {\n\t\t\treturn WadRayMath.ray();\n\t\t}\n\n\t\tuint256 expMinusOne = exp - 1;\n\n\t\tuint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\n\n\t\tuint256 ratePerSecond = rate / SECONDS_PER_YEAR;\n\n\t\tuint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);\n\t\tuint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);\n\n\t\tuint256 secondTerm = exp.mul(expMinusOne).mul(basePowerTwo) / 2;\n\t\tuint256 thirdTerm = exp.mul(expMinusOne).mul(expMinusTwo).mul(basePowerThree) / 6;\n\n\t\treturn WadRayMath.ray().add(ratePerSecond.mul(exp)).add(secondTerm).add(thirdTerm);\n\t}\n\n\t/**\n\t * @dev Calculates the compounded interest between the timestamp of the last update and the current block timestamp\n\t * @param rate The interest rate (in ray)\n\t * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calculated\n\t **/\n\tfunction calculateCompoundedInterest(uint256 rate, uint40 lastUpdateTimestamp) internal view returns (uint256) {\n\t\treturn calculateCompoundedInterest(rate, lastUpdateTimestamp, block.timestamp);\n\t}\n}\n"
    },
    "contracts/lending/libraries/math/PercentageMath.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {Errors} from \"../helpers/Errors.sol\";\n\n/**\n * @title PercentageMath library\n * @author Aave\n * @notice Provides functions to perform percentage calculations\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\n * @dev Operations are rounded half up\n **/\n\nlibrary PercentageMath {\n\tuint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\n\tuint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\n\n\t/**\n\t * @dev Executes a percentage multiplication\n\t * @param value The value of which the percentage needs to be calculated\n\t * @param percentage The percentage of the value to be calculated\n\t * @return The percentage of value\n\t **/\n\tfunction percentMul(uint256 value, uint256 percentage) internal pure returns (uint256) {\n\t\tif (value == 0 || percentage == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\trequire(value <= (type(uint256).max - HALF_PERCENT) / percentage, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n\t\treturn (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR;\n\t}\n\n\t/**\n\t * @dev Executes a percentage division\n\t * @param value The value of which the percentage needs to be calculated\n\t * @param percentage The percentage of the value to be calculated\n\t * @return The value divided the percentage\n\t **/\n\tfunction percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256) {\n\t\trequire(percentage != 0, Errors.MATH_DIVISION_BY_ZERO);\n\t\tuint256 halfPercentage = percentage / 2;\n\n\t\trequire(value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n\t\treturn (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\n\t}\n}\n"
    },
    "contracts/lending/libraries/math/WadRayMath.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {Errors} from \"../helpers/Errors.sol\";\n\n/**\n * @title WadRayMath library\n * @author Aave\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\n **/\n\nlibrary WadRayMath {\n\tuint256 internal constant WAD = 1e18;\n\tuint256 internal constant halfWAD = WAD / 2;\n\n\tuint256 internal constant RAY = 1e27;\n\tuint256 internal constant halfRAY = RAY / 2;\n\n\tuint256 internal constant WAD_RAY_RATIO = 1e9;\n\n\t/**\n\t * @return One ray, 1e27\n\t **/\n\tfunction ray() internal pure returns (uint256) {\n\t\treturn RAY;\n\t}\n\n\t/**\n\t * @return One wad, 1e18\n\t **/\n\n\tfunction wad() internal pure returns (uint256) {\n\t\treturn WAD;\n\t}\n\n\t/**\n\t * @return Half ray, 1e27/2\n\t **/\n\tfunction halfRay() internal pure returns (uint256) {\n\t\treturn halfRAY;\n\t}\n\n\t/**\n\t * @return Half ray, 1e18/2\n\t **/\n\tfunction halfWad() internal pure returns (uint256) {\n\t\treturn halfWAD;\n\t}\n\n\t/**\n\t * @dev Multiplies two wad, rounding half up to the nearest wad\n\t * @param a Wad\n\t * @param b Wad\n\t * @return The result of a*b, in wad\n\t **/\n\tfunction wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tif (a == 0 || b == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\trequire(a <= (type(uint256).max - halfWAD) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n\t\treturn (a * b + halfWAD) / WAD;\n\t}\n\n\t/**\n\t * @dev Divides two wad, rounding half up to the nearest wad\n\t * @param a Wad\n\t * @param b Wad\n\t * @return The result of a/b, in wad\n\t **/\n\tfunction wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\trequire(b != 0, Errors.MATH_DIVISION_BY_ZERO);\n\t\tuint256 halfB = b / 2;\n\n\t\trequire(a <= (type(uint256).max - halfB) / WAD, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n\t\treturn (a * WAD + halfB) / b;\n\t}\n\n\t/**\n\t * @dev Multiplies two ray, rounding half up to the nearest ray\n\t * @param a Ray\n\t * @param b Ray\n\t * @return The result of a*b, in ray\n\t **/\n\tfunction rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tif (a == 0 || b == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\trequire(a <= (type(uint256).max - halfRAY) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n\t\treturn (a * b + halfRAY) / RAY;\n\t}\n\n\t/**\n\t * @dev Divides two ray, rounding half up to the nearest ray\n\t * @param a Ray\n\t * @param b Ray\n\t * @return The result of a/b, in ray\n\t **/\n\tfunction rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\trequire(b != 0, Errors.MATH_DIVISION_BY_ZERO);\n\t\tuint256 halfB = b / 2;\n\n\t\trequire(a <= (type(uint256).max - halfB) / RAY, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n\t\treturn (a * RAY + halfB) / b;\n\t}\n\n\t/**\n\t * @dev Casts ray down to wad\n\t * @param a Ray\n\t * @return a casted to wad, rounded half up to the nearest wad\n\t **/\n\tfunction rayToWad(uint256 a) internal pure returns (uint256) {\n\t\tuint256 halfRatio = WAD_RAY_RATIO / 2;\n\t\tuint256 result = halfRatio + a;\n\t\trequire(result >= halfRatio, Errors.MATH_ADDITION_OVERFLOW);\n\n\t\treturn result / WAD_RAY_RATIO;\n\t}\n\n\t/**\n\t * @dev Converts wad up to ray\n\t * @param a Wad\n\t * @return a converted in ray\n\t **/\n\tfunction wadToRay(uint256 a) internal pure returns (uint256) {\n\t\tuint256 result = a * WAD_RAY_RATIO;\n\t\trequire(result / WAD_RAY_RATIO == a, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\t\treturn result;\n\t}\n}\n"
    },
    "contracts/lending/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nlibrary DataTypes {\n\t// refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n\tstruct ReserveData {\n\t\t//stores the reserve configuration\n\t\tReserveConfigurationMap configuration;\n\t\t//the liquidity index. Expressed in ray\n\t\tuint128 liquidityIndex;\n\t\t//variable borrow index. Expressed in ray\n\t\tuint128 variableBorrowIndex;\n\t\t//the current supply rate. Expressed in ray\n\t\tuint128 currentLiquidityRate;\n\t\t//the current variable borrow rate. Expressed in ray\n\t\tuint128 currentVariableBorrowRate;\n\t\t//the current stable borrow rate. Expressed in ray\n\t\tuint128 currentStableBorrowRate;\n\t\tuint40 lastUpdateTimestamp;\n\t\t//tokens addresses\n\t\taddress aTokenAddress;\n\t\taddress stableDebtTokenAddress;\n\t\taddress variableDebtTokenAddress;\n\t\t//address of the interest rate strategy\n\t\taddress interestRateStrategyAddress;\n\t\t//the id of the reserve. Represents the position in the list of the active reserves\n\t\tuint8 id;\n\t}\n\n\tstruct ReserveConfigurationMap {\n\t\t//bit 0-15: LTV\n\t\t//bit 16-31: Liq. threshold\n\t\t//bit 32-47: Liq. bonus\n\t\t//bit 48-55: Decimals\n\t\t//bit 56: Reserve is active\n\t\t//bit 57: reserve is frozen\n\t\t//bit 58: borrowing is enabled\n\t\t//bit 59: stable rate borrowing enabled\n\t\t//bit 60-63: reserved\n\t\t//bit 64-79: reserve factor\n\t\tuint256 data;\n\t}\n\n\tstruct UserConfigurationMap {\n\t\tuint256 data;\n\t}\n\n\tenum InterestRateMode {\n\t\tNONE,\n\t\tSTABLE,\n\t\tVARIABLE\n\t}\n}\n"
    },
    "contracts/lending/StableAndVariableTokensHelper.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport {StableDebtToken} from \"./tokenization/StableDebtToken.sol\";\nimport {VariableDebtToken} from \"./tokenization/VariableDebtToken.sol\";\nimport {LendingRateOracle} from \"../test/oracle/LendingRateOracle.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract StableAndVariableTokensHelper is Ownable {\n\taddress payable private pool;\n\taddress private addressesProvider;\n\tevent deployedContracts(address stableToken, address variableToken);\n\n\tconstructor(address payable _pool, address _addressesProvider) {\n\t\tpool = _pool;\n\t\taddressesProvider = _addressesProvider;\n\t}\n\n\tfunction initDeployment(address[] calldata tokens, string[] calldata symbols) external onlyOwner {\n\t\trequire(tokens.length == symbols.length, \"Arrays not same length\");\n\t\trequire(pool != address(0), \"Pool can not be zero address\");\n\t\tuint256 length = tokens.length;\n\t\tfor (uint256 i = 0; i < length; ) {\n\t\t\temit deployedContracts(address(new StableDebtToken()), address(new VariableDebtToken()));\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setOracleBorrowRates(\n\t\taddress[] calldata assets,\n\t\tuint256[] calldata rates,\n\t\taddress oracle\n\t) external onlyOwner {\n\t\trequire(assets.length == rates.length, \"Arrays not same length\");\n\n\t\tuint256 length = assets.length;\n\t\tfor (uint256 i = 0; i < length; ) {\n\t\t\t// LendingRateOracle owner must be this contract\n\t\t\tLendingRateOracle(oracle).setMarketBorrowRate(assets[i], rates[i]);\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setOracleOwnership(address oracle, address admin) external onlyOwner {\n\t\trequire(admin != address(0), \"owner can not be zero\");\n\t\trequire(LendingRateOracle(oracle).owner() == address(this), \"helper is not owner\");\n\t\tLendingRateOracle(oracle).transferOwnership(admin);\n\t}\n}\n"
    },
    "contracts/lending/tokenization/AToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\nimport {IAToken} from \"../../interfaces/IAToken.sol\";\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {VersionedInitializable} from \"../libraries/aave-upgradeability/VersionedInitializable.sol\";\nimport {IncentivizedERC20} from \"./IncentivizedERC20.sol\";\nimport {IAaveIncentivesController} from \"../../interfaces/IAaveIncentivesController.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IMiddleFeeDistribution} from \"../../interfaces/IMiddleFeeDistribution.sol\";\n\n/**\n * @title Aave ERC20 AToken\n * @dev Implementation of the interest bearing token for the Aave protocol\n * @author Aave\n */\ncontract AToken is VersionedInitializable, IncentivizedERC20(\"ATOKEN_IMPL\", \"ATOKEN_IMPL\", 0), IAToken {\n\tusing WadRayMath for uint256;\n\tusing SafeERC20 for IERC20;\n\tusing SafeMath for uint256;\n\n\tbytes public constant EIP712_REVISION = bytes(\"1\");\n\tbytes32 internal constant EIP712_DOMAIN =\n\t\tkeccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\tbytes32 public constant PERMIT_TYPEHASH =\n\t\tkeccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n\tuint256 public constant ATOKEN_REVISION = 0x1;\n\n\t/// @dev owner => next valid nonce to submit with permit()\n\tmapping(address => uint256) public _nonces;\n\n\tbytes32 public DOMAIN_SEPARATOR;\n\n\taddress internal _treasury;\n\tIAaveIncentivesController internal _incentivesController;\n\n\tmodifier onlyLendingPool() {\n\t\trequire(_msgSender() == address(_pool), Errors.CT_CALLER_MUST_BE_LENDING_POOL);\n\t\t_;\n\t}\n\n\tfunction getRevision() internal pure virtual override returns (uint256) {\n\t\treturn ATOKEN_REVISION;\n\t}\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @dev Initializes the aToken\n\t * @param pool The address of the lending pool where this aToken will be used\n\t * @param treasury The address of the Aave treasury, receiving the fees on this aToken\n\t * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n\t * @param incentivesController The smart contract managing potential incentives distribution\n\t * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\n\t * @param aTokenName The name of the aToken\n\t * @param aTokenSymbol The symbol of the aToken\n\t */\n\tfunction initialize(\n\t\tILendingPool pool,\n\t\taddress treasury,\n\t\taddress underlyingAsset,\n\t\tIAaveIncentivesController incentivesController,\n\t\tuint8 aTokenDecimals,\n\t\tstring calldata aTokenName,\n\t\tstring calldata aTokenSymbol,\n\t\tbytes calldata params\n\t) external override initializer {\n\t\tuint256 chainId;\n\n\t\t//solium-disable-next-line\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\n\t\tDOMAIN_SEPARATOR = keccak256(\n\t\t\tabi.encode(EIP712_DOMAIN, keccak256(bytes(aTokenName)), keccak256(EIP712_REVISION), chainId, address(this))\n\t\t);\n\n\t\t_setName(aTokenName);\n\t\t_setSymbol(aTokenSymbol);\n\t\t_setDecimals(aTokenDecimals);\n\n\t\t_pool = pool;\n\t\t_treasury = treasury;\n\t\t_underlyingAsset = underlyingAsset;\n\t\t_incentivesController = incentivesController;\n\n\t\temit Initialized(\n\t\t\tunderlyingAsset,\n\t\t\taddress(pool),\n\t\t\ttreasury,\n\t\t\taddress(incentivesController),\n\t\t\taTokenDecimals,\n\t\t\taTokenName,\n\t\t\taTokenSymbol,\n\t\t\tparams\n\t\t);\n\t}\n\n\t/**\n\t * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n\t * - Only callable by the LendingPool, as extra state updates there need to be managed\n\t * @param user The owner of the aTokens, getting them burned\n\t * @param receiverOfUnderlying The address that will receive the underlying\n\t * @param amount The amount being burned\n\t * @param index The new liquidity index of the reserve\n\t **/\n\tfunction burn(\n\t\taddress user,\n\t\taddress receiverOfUnderlying,\n\t\tuint256 amount,\n\t\tuint256 index\n\t) external override onlyLendingPool {\n\t\tuint256 amountScaled = amount.rayDiv(index);\n\t\trequire(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n\t\t_burn(user, amountScaled);\n\n\t\tIERC20(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);\n\n\t\temit Transfer(user, address(0), amount);\n\t\temit Burn(user, receiverOfUnderlying, amount, index);\n\t}\n\n\t/**\n\t * @dev Mints `amount` aTokens to `user`\n\t * - Only callable by the LendingPool, as extra state updates there need to be managed\n\t * @param user The address receiving the minted tokens\n\t * @param amount The amount of tokens getting minted\n\t * @param index The new liquidity index of the reserve\n\t * @return `true` if the the previous balance of the user was 0\n\t */\n\tfunction mint(address user, uint256 amount, uint256 index) external override onlyLendingPool returns (bool) {\n\t\tuint256 previousBalance = super.balanceOf(user);\n\n\t\tuint256 amountScaled = amount.rayDiv(index);\n\t\trequire(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n\t\t_mint(user, amountScaled);\n\n\t\temit Transfer(address(0), user, amount);\n\t\temit Mint(user, amount, index);\n\n\t\treturn previousBalance == 0;\n\t}\n\n\t/**\n\t * @dev Mints aTokens to the reserve treasury\n\t * - Only callable by the LendingPool\n\t * @param amount The amount of tokens getting minted\n\t * @param index The new liquidity index of the reserve\n\t */\n\tfunction mintToTreasury(uint256 amount, uint256 index) external override onlyLendingPool {\n\t\tif (amount == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\taddress treasury = _treasury;\n\n\t\t// Compared to the normal mint, we don't check for rounding errors.\n\t\t// The amount to mint can easily be very small since it is a fraction of the interest ccrued.\n\t\t// In that case, the treasury will experience a (very small) loss, but it\n\t\t// wont cause potentially valid transactions to fail.\n\t\t_mint(treasury, amount.rayDiv(index));\n\n\t\temit Transfer(address(0), treasury, amount);\n\t\temit Mint(treasury, amount, index);\n\t}\n\n\t/**\n\t * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n\t * - Only callable by the LendingPool\n\t * @param from The address getting liquidated, current owner of the aTokens\n\t * @param to The recipient\n\t * @param value The amount of tokens getting transferred\n\t **/\n\tfunction transferOnLiquidation(address from, address to, uint256 value) external override onlyLendingPool {\n\t\t// Being a normal transfer, the Transfer() and BalanceTransfer() are emitted\n\t\t// so no need to emit a specific event here\n\t\t_transfer(from, to, value, false);\n\n\t\temit Transfer(from, to, value);\n\t}\n\n\t/**\n\t * @dev Calculates the balance of the user: principal balance + interest generated by the principal\n\t * @param user The user whose balance is calculated\n\t * @return The balance of the user\n\t **/\n\tfunction balanceOf(address user) public view override(IncentivizedERC20, IERC20) returns (uint256) {\n\t\treturn super.balanceOf(user).rayMul(_pool.getReserveNormalizedIncome(_underlyingAsset));\n\t}\n\n\t/**\n\t * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n\t * updated stored balance divided by the reserve's liquidity index at the moment of the update\n\t * @param user The user whose balance is calculated\n\t * @return The scaled balance of the user\n\t **/\n\tfunction scaledBalanceOf(address user) external view override returns (uint256) {\n\t\treturn super.balanceOf(user);\n\t}\n\n\t/**\n\t * @dev Returns the scaled balance of the user and the scaled total supply.\n\t * @param user The address of the user\n\t * @return The scaled balance of the user\n\t * @return The scaled balance and the scaled total supply\n\t **/\n\tfunction getScaledUserBalanceAndSupply(address user) external view override returns (uint256, uint256) {\n\t\treturn (super.balanceOf(user), super.totalSupply());\n\t}\n\n\t/**\n\t * @dev calculates the total supply of the specific aToken\n\t * since the balance of every single user increases over time, the total supply\n\t * does that too.\n\t * @return the current total supply\n\t **/\n\tfunction totalSupply() public view override(IncentivizedERC20, IERC20) returns (uint256) {\n\t\tuint256 currentSupplyScaled = super.totalSupply();\n\n\t\tif (currentSupplyScaled == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn currentSupplyScaled.rayMul(_pool.getReserveNormalizedIncome(_underlyingAsset));\n\t}\n\n\t/**\n\t * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n\t * @return the scaled total supply\n\t **/\n\tfunction scaledTotalSupply() public view virtual override returns (uint256) {\n\t\treturn super.totalSupply();\n\t}\n\n\t/**\n\t * @dev Returns the address of the Aave treasury, receiving the fees on this aToken\n\t **/\n\tfunction RESERVE_TREASURY_ADDRESS() public view returns (address) {\n\t\treturn _treasury;\n\t}\n\n\t/**\n\t * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n\t **/\n\tfunction UNDERLYING_ASSET_ADDRESS() public view override returns (address) {\n\t\treturn _underlyingAsset;\n\t}\n\n\t/**\n\t * @dev Returns the address of the lending pool where this aToken is used\n\t **/\n\tfunction POOL() public view returns (ILendingPool) {\n\t\treturn _pool;\n\t}\n\n\t/**\n\t * @dev For internal usage in the logic of the parent contract IncentivizedERC20\n\t **/\n\tfunction _getIncentivesController() internal view override returns (IAaveIncentivesController) {\n\t\treturn _incentivesController;\n\t}\n\n\t/**\n\t * @dev Returns the address of the incentives controller contract\n\t **/\n\tfunction getIncentivesController() external view override returns (IAaveIncentivesController) {\n\t\treturn _getIncentivesController();\n\t}\n\n\t/**\n\t * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\n\t * assets in borrow(), withdraw() and flashLoan()\n\t * @param target The recipient of the aTokens\n\t * @param amount The amount getting transferred\n\t * @return The amount transferred\n\t **/\n\tfunction transferUnderlyingTo(address target, uint256 amount) external override onlyLendingPool returns (uint256) {\n\t\tIERC20(_underlyingAsset).safeTransfer(target, amount);\n\t\treturn amount;\n\t}\n\n\t/**\n\t * @dev Invoked to execute actions on the aToken side after a repayment.\n\t * @param user The user executing the repayment\n\t * @param amount The amount getting repaid\n\t **/\n\tfunction handleRepayment(address user, uint256 amount) external override onlyLendingPool {}\n\n\t/**\n\t * @dev implements the permit function as for\n\t * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n\t * @param owner The owner of the funds\n\t * @param spender The spender\n\t * @param value The amount\n\t * @param deadline The deadline timestamp, type(uint256).max for max deadline\n\t * @param v Signature param\n\t * @param s Signature param\n\t * @param r Signature param\n\t */\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external {\n\t\trequire(owner != address(0), \"INVALID_OWNER\");\n\t\t//solium-disable-next-line\n\t\trequire(block.timestamp <= deadline, \"INVALID_EXPIRATION\");\n\t\tuint256 currentValidNonce = _nonces[owner];\n\t\tbytes32 digest = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\t\"\\x19\\x01\",\n\t\t\t\tDOMAIN_SEPARATOR,\n\t\t\t\tkeccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentValidNonce, deadline))\n\t\t\t)\n\t\t);\n\t\trequire(owner == ecrecover(digest, v, r, s), \"INVALID_SIGNATURE\");\n\t\t_nonces[owner] = currentValidNonce.add(1);\n\t\t_approve(owner, spender, value);\n\t}\n\n\t/**\n\t * @dev Transfers the aTokens between two users. Validates the transfer\n\t * (ie checks for valid HF after the transfer) if required\n\t * @param from The source address\n\t * @param to The destination address\n\t * @param amount The amount getting transferred\n\t * @param validate `true` if the transfer needs to be validated\n\t **/\n\tfunction _transfer(address from, address to, uint256 amount, bool validate) internal {\n\t\taddress underlyingAsset = _underlyingAsset;\n\t\tILendingPool pool = _pool;\n\n\t\tuint256 index = pool.getReserveNormalizedIncome(underlyingAsset);\n\n\t\tuint256 fromBalanceBefore = super.balanceOf(from).rayMul(index);\n\t\tuint256 toBalanceBefore = super.balanceOf(to).rayMul(index);\n\n\t\tsuper._transfer(from, to, amount.rayDiv(index));\n\n\t\tif (validate) {\n\t\t\tpool.finalizeTransfer(underlyingAsset, from, to, amount, fromBalanceBefore, toBalanceBefore);\n\t\t}\n\n\t\temit BalanceTransfer(from, to, amount, index);\n\t}\n\n\t/**\n\t * @dev Overrides the parent _transfer to force validated transfer() and transferFrom()\n\t * @param from The source address\n\t * @param to The destination address\n\t * @param amount The amount getting transferred\n\t **/\n\tfunction _transfer(address from, address to, uint256 amount) internal override {\n\t\t_transfer(from, to, amount, true);\n\t}\n}\n"
    },
    "contracts/lending/tokenization/base/DebtTokenBase.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {ILendingPool} from \"../../../interfaces/ILendingPool.sol\";\nimport {ICreditDelegationToken} from \"../../../interfaces/ICreditDelegationToken.sol\";\nimport {VersionedInitializable} from \"../../libraries/aave-upgradeability/VersionedInitializable.sol\";\nimport {IncentivizedERC20} from \"../IncentivizedERC20.sol\";\nimport {Errors} from \"../../libraries/helpers/Errors.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title DebtTokenBase\n * @notice Base contract for different types of debt tokens, like StableDebtToken or VariableDebtToken\n * @author Aave\n */\n\nabstract contract DebtTokenBase is\n\tIncentivizedERC20(\"DEBTTOKEN_IMPL\", \"DEBTTOKEN_IMPL\", 0),\n\tVersionedInitializable,\n\tICreditDelegationToken\n{\n\tusing SafeMath for uint256;\n\n\tmapping(address => mapping(address => uint256)) internal _borrowAllowances;\n\n\t/**\n\t * @dev Only lending pool can call functions marked by this modifier\n\t **/\n\tmodifier onlyLendingPool() {\n\t\trequire(_msgSender() == address(_getLendingPool()), Errors.CT_CALLER_MUST_BE_LENDING_POOL);\n\t\t_;\n\t}\n\n\t/**\n\t * @dev delegates borrowing power to a user on the specific debt token\n\t * @param delegatee the address receiving the delegated borrowing power\n\t * @param amount the maximum amount being delegated. Delegation will still\n\t * respect the liquidation constraints (even if delegated, a delegatee cannot\n\t * force a delegator HF to go below 1)\n\t **/\n\tfunction approveDelegation(address delegatee, uint256 amount) external override {\n\t\t_borrowAllowances[_msgSender()][delegatee] = amount;\n\t\temit BorrowAllowanceDelegated(_msgSender(), delegatee, _getUnderlyingAssetAddress(), amount);\n\t}\n\n\t/**\n\t * @dev returns the borrow allowance of the user\n\t * @param fromUser The user to giving allowance\n\t * @param toUser The user to give allowance to\n\t * @return the current allowance of toUser\n\t **/\n\tfunction borrowAllowance(address fromUser, address toUser) external view override returns (uint256) {\n\t\treturn _borrowAllowances[fromUser][toUser];\n\t}\n\n\t/**\n\t * @dev Being non transferrable, the debt token does not implement any of the\n\t * standard ERC20 functions for transfer and allowance.\n\t **/\n\tfunction transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n\t\trecipient;\n\t\tamount;\n\t\trevert(\"TRANSFER_NOT_SUPPORTED\");\n\t}\n\n\tfunction allowance(address owner, address spender) public view virtual override returns (uint256) {\n\t\towner;\n\t\tspender;\n\t\trevert(\"ALLOWANCE_NOT_SUPPORTED\");\n\t}\n\n\tfunction approve(address spender, uint256 amount) public virtual override returns (bool) {\n\t\tspender;\n\t\tamount;\n\t\trevert(\"APPROVAL_NOT_SUPPORTED\");\n\t}\n\n\tfunction transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n\t\tsender;\n\t\trecipient;\n\t\tamount;\n\t\trevert(\"TRANSFER_NOT_SUPPORTED\");\n\t}\n\n\tfunction increaseAllowance(address spender, uint256 addedValue) public virtual override returns (bool) {\n\t\tspender;\n\t\taddedValue;\n\t\trevert(\"ALLOWANCE_NOT_SUPPORTED\");\n\t}\n\n\tfunction decreaseAllowance(address spender, uint256 subtractedValue) public virtual override returns (bool) {\n\t\tspender;\n\t\tsubtractedValue;\n\t\trevert(\"ALLOWANCE_NOT_SUPPORTED\");\n\t}\n\n\tfunction _decreaseBorrowAllowance(address delegator, address delegatee, uint256 amount) internal {\n\t\tuint256 newAllowance = _borrowAllowances[delegator][delegatee].sub(amount, Errors.BORROW_ALLOWANCE_NOT_ENOUGH);\n\n\t\t_borrowAllowances[delegator][delegatee] = newAllowance;\n\n\t\temit BorrowAllowanceDelegated(delegator, delegatee, _getUnderlyingAssetAddress(), newAllowance);\n\t}\n\n\tfunction _getUnderlyingAssetAddress() internal view virtual returns (address);\n\n\tfunction _getLendingPool() internal view virtual returns (ILendingPool);\n}\n"
    },
    "contracts/lending/tokenization/IncentivizedERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {Context} from \"../../dependencies/openzeppelin/contracts/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IAaveIncentivesController} from \"../../interfaces/IAaveIncentivesController.sol\";\nimport {ILendingPoolAddressesProvider} from \"../../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {IPriceOracle} from \"../../interfaces/IPriceOracle.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\n\n/**\n * @title ERC20\n * @notice Basic ERC20 implementation\n * @author Aave, inspired by the Openzeppelin ERC20 implementation\n **/\nabstract contract IncentivizedERC20 is Context, IERC20, IERC20Metadata {\n\tusing SafeMath for uint256;\n\n\tmapping(address => uint256) internal _balances;\n\n\tmapping(address => mapping(address => uint256)) private _allowances;\n\tuint256 internal _totalSupply;\n\tstring private _name;\n\tstring private _symbol;\n\tuint8 private _decimals;\n\n\tILendingPool internal _pool;\n\taddress internal _underlyingAsset;\n\n\tconstructor(string memory name_, string memory symbol_, uint8 decimals_) {\n\t\t_name = name_;\n\t\t_symbol = symbol_;\n\t\t_decimals = decimals_;\n\t}\n\n\t/**\n\t * @return The name of the token\n\t **/\n\tfunction name() public view returns (string memory) {\n\t\treturn _name;\n\t}\n\n\t/**\n\t * @return The symbol of the token\n\t **/\n\tfunction symbol() public view returns (string memory) {\n\t\treturn _symbol;\n\t}\n\n\t/**\n\t * @return The decimals of the token\n\t **/\n\tfunction decimals() public view returns (uint8) {\n\t\treturn _decimals;\n\t}\n\n\t/**\n\t * @return The total supply of the token\n\t **/\n\tfunction totalSupply() public view virtual returns (uint256) {\n\t\treturn _totalSupply;\n\t}\n\n\t/**\n\t * @return The balance of the token\n\t **/\n\tfunction balanceOf(address account) public view virtual returns (uint256) {\n\t\treturn _balances[account];\n\t}\n\n\t/**\n\t * @return Abstract function implemented by the child aToken/debtToken.\n\t * Done this way in order to not break compatibility with previous versions of aTokens/debtTokens\n\t **/\n\tfunction _getIncentivesController() internal view virtual returns (IAaveIncentivesController);\n\n\t/**\n\t * @dev Executes a transfer of tokens from _msgSender() to recipient\n\t * @param recipient The recipient of the tokens\n\t * @param amount The amount of tokens being transferred\n\t * @return `true` if the transfer succeeds, `false` otherwise\n\t **/\n\tfunction transfer(address recipient, uint256 amount) public virtual returns (bool) {\n\t\t_transfer(_msgSender(), recipient, amount);\n\t\temit Transfer(_msgSender(), recipient, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Returns the allowance of spender on the tokens owned by owner\n\t * @param owner The owner of the tokens\n\t * @param spender The user allowed to spend the owner's tokens\n\t * @return The amount of owner's tokens spender is allowed to spend\n\t **/\n\tfunction allowance(address owner, address spender) public view virtual returns (uint256) {\n\t\treturn _allowances[owner][spender];\n\t}\n\n\t/**\n\t * @dev Allows `spender` to spend the tokens owned by _msgSender()\n\t * @param spender The user allowed to spend _msgSender() tokens\n\t * @return `true`\n\t **/\n\tfunction approve(address spender, uint256 amount) public virtual returns (bool) {\n\t\t_approve(_msgSender(), spender, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Executes a transfer of token from sender to recipient, if _msgSender() is allowed to do so\n\t * @param sender The owner of the tokens\n\t * @param recipient The recipient of the tokens\n\t * @param amount The amount of tokens being transferred\n\t * @return `true` if the transfer succeeds, `false` otherwise\n\t **/\n\tfunction transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) {\n\t\t_transfer(sender, recipient, amount);\n\t\t_approve(\n\t\t\tsender,\n\t\t\t_msgSender(),\n\t\t\t_allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\")\n\t\t);\n\t\temit Transfer(sender, recipient, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Increases the allowance of spender to spend _msgSender() tokens\n\t * @param spender The user allowed to spend on behalf of _msgSender()\n\t * @param addedValue The amount being added to the allowance\n\t * @return `true`\n\t **/\n\tfunction increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n\t\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Decreases the allowance of spender to spend _msgSender() tokens\n\t * @param spender The user allowed to spend on behalf of _msgSender()\n\t * @param subtractedValue The amount being subtracted to the allowance\n\t * @return `true`\n\t **/\n\tfunction decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n\t\t_approve(\n\t\t\t_msgSender(),\n\t\t\tspender,\n\t\t\t_allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\")\n\t\t);\n\t\treturn true;\n\t}\n\n\tfunction _transfer(address sender, address recipient, uint256 amount) internal virtual {\n\t\trequire(sender != address(0), \"ERC20: transfer from the zero address\");\n\t\trequire(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\t\t_beforeTokenTransfer(sender, recipient, amount);\n\n\t\tuint256 senderBalance = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n\n\t\tif (address(_getIncentivesController()) != address(0)) {\n\t\t\t// uint256 currentTotalSupply = _totalSupply;\n\t\t\t_getIncentivesController().handleActionBefore(sender);\n\t\t\tif (sender != recipient) {\n\t\t\t\t_getIncentivesController().handleActionBefore(recipient);\n\t\t\t}\n\t\t}\n\n\t\t_balances[sender] = senderBalance;\n\t\tuint256 recipientBalance = _balances[recipient].add(amount);\n\t\t_balances[recipient] = recipientBalance;\n\n\t\tif (address(_getIncentivesController()) != address(0)) {\n\t\t\tuint256 currentTotalSupply = _totalSupply;\n\t\t\t_getIncentivesController().handleActionAfter(sender, _balances[sender], currentTotalSupply);\n\t\t\tif (sender != recipient) {\n\t\t\t\t_getIncentivesController().handleActionAfter(recipient, _balances[recipient], currentTotalSupply);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction _mint(address account, uint256 amount) internal virtual {\n\t\trequire(account != address(0), \"ERC20: mint to the zero address\");\n\n\t\t_beforeTokenTransfer(address(0), account, amount);\n\n\t\tuint256 currentTotalSupply = _totalSupply.add(amount);\n\t\tuint256 accountBalance = _balances[account].add(amount);\n\t\tif (address(_getIncentivesController()) != address(0)) {\n\t\t\t_getIncentivesController().handleActionBefore(account);\n\t\t}\n\t\t_totalSupply = currentTotalSupply;\n\t\t_balances[account] = accountBalance;\n\t\tif (address(_getIncentivesController()) != address(0)) {\n\t\t\t_getIncentivesController().handleActionAfter(account, accountBalance, currentTotalSupply);\n\t\t}\n\t}\n\n\tfunction _burn(address account, uint256 amount) internal virtual {\n\t\trequire(account != address(0), \"ERC20: burn from the zero address\");\n\n\t\t_beforeTokenTransfer(account, address(0), amount);\n\n\t\tuint256 currentTotalSupply = _totalSupply.sub(amount);\n\t\tuint256 accountBalance = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n\n\t\tif (address(_getIncentivesController()) != address(0)) {\n\t\t\t_getIncentivesController().handleActionBefore(account);\n\t\t}\n\n\t\t_totalSupply = currentTotalSupply;\n\t\t_balances[account] = accountBalance;\n\n\t\tif (address(_getIncentivesController()) != address(0)) {\n\t\t\t_getIncentivesController().handleActionAfter(account, accountBalance, currentTotalSupply);\n\t\t}\n\t}\n\n\tfunction _approve(address owner, address spender, uint256 amount) internal virtual {\n\t\trequire(owner != address(0), \"ERC20: approve from the zero address\");\n\t\trequire(spender != address(0), \"ERC20: approve to the zero address\");\n\n\t\t_allowances[owner][spender] = amount;\n\t\temit Approval(owner, spender, amount);\n\t}\n\n\tfunction _setName(string memory newName) internal {\n\t\t_name = newName;\n\t}\n\n\tfunction _setSymbol(string memory newSymbol) internal {\n\t\t_symbol = newSymbol;\n\t}\n\n\tfunction _setDecimals(uint8 newDecimals) internal {\n\t\t_decimals = newDecimals;\n\t}\n\n\tfunction _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n\tfunction getAssetPrice() external view returns (uint256) {\n\t\tILendingPoolAddressesProvider provider = _pool.getAddressesProvider();\n\t\taddress oracle = provider.getPriceOracle();\n\t\treturn IPriceOracle(oracle).getAssetPrice(_underlyingAsset);\n\t}\n}\n"
    },
    "contracts/lending/tokenization/StableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {DebtTokenBase} from \"./base/DebtTokenBase.sol\";\nimport {MathUtils} from \"../libraries/math/MathUtils.sol\";\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {IStableDebtToken} from \"../../interfaces/IStableDebtToken.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\nimport {IAaveIncentivesController} from \"../../interfaces/IAaveIncentivesController.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title StableDebtToken\n * @notice Implements a stable debt token to track the borrowing positions of users\n * at stable rate mode\n * @author Aave\n **/\ncontract StableDebtToken is IStableDebtToken, DebtTokenBase {\n\tusing WadRayMath for uint256;\n\tusing SafeMath for uint256;\n\n\tuint256 public constant DEBT_TOKEN_REVISION = 0x1;\n\n\tuint256 internal _avgStableRate;\n\tmapping(address => uint40) internal _timestamps;\n\tmapping(address => uint256) internal _usersStableRate;\n\tuint40 internal _totalSupplyTimestamp;\n\n\tIAaveIncentivesController internal _incentivesController;\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @dev Initializes the debt token.\n\t * @param pool The address of the lending pool where this aToken will be used\n\t * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n\t * @param incentivesController The smart contract managing potential incentives distribution\n\t * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's\n\t * @param debtTokenName The name of the token\n\t * @param debtTokenSymbol The symbol of the token\n\t */\n\tfunction initialize(\n\t\tILendingPool pool,\n\t\taddress underlyingAsset,\n\t\tIAaveIncentivesController incentivesController,\n\t\tuint8 debtTokenDecimals,\n\t\tstring memory debtTokenName,\n\t\tstring memory debtTokenSymbol,\n\t\tbytes calldata params\n\t) public override initializer {\n\t\t_setName(debtTokenName);\n\t\t_setSymbol(debtTokenSymbol);\n\t\t_setDecimals(debtTokenDecimals);\n\n\t\t_pool = pool;\n\t\t_underlyingAsset = underlyingAsset;\n\t\t_incentivesController = incentivesController;\n\n\t\temit Initialized(\n\t\t\tunderlyingAsset,\n\t\t\taddress(pool),\n\t\t\taddress(incentivesController),\n\t\t\tdebtTokenDecimals,\n\t\t\tdebtTokenName,\n\t\t\tdebtTokenSymbol,\n\t\t\tparams\n\t\t);\n\t}\n\n\t/**\n\t * @dev Gets the revision of the stable debt token implementation\n\t * @return The debt token implementation revision\n\t **/\n\tfunction getRevision() internal pure virtual override returns (uint256) {\n\t\treturn DEBT_TOKEN_REVISION;\n\t}\n\n\t/**\n\t * @dev Returns the average stable rate across all the stable rate debt\n\t * @return the average stable rate\n\t **/\n\tfunction getAverageStableRate() external view virtual override returns (uint256) {\n\t\treturn _avgStableRate;\n\t}\n\n\t/**\n\t * @dev Returns the timestamp of the last user action\n\t * @return The last update timestamp\n\t **/\n\tfunction getUserLastUpdated(address user) external view virtual override returns (uint40) {\n\t\treturn _timestamps[user];\n\t}\n\n\t/**\n\t * @dev Returns the stable rate of the user\n\t * @param user The address of the user\n\t * @return The stable rate of user\n\t **/\n\tfunction getUserStableRate(address user) external view virtual override returns (uint256) {\n\t\treturn _usersStableRate[user];\n\t}\n\n\t/**\n\t * @dev Calculates the current user debt balance\n\t * @return The accumulated debt of the user\n\t **/\n\tfunction balanceOf(address account) public view virtual override returns (uint256) {\n\t\tuint256 accountBalance = super.balanceOf(account);\n\t\tuint256 stableRate = _usersStableRate[account];\n\t\tif (accountBalance == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);\n\t\treturn accountBalance.rayMul(cumulatedInterest);\n\t}\n\n\tstruct MintLocalVars {\n\t\tuint256 previousSupply;\n\t\tuint256 nextSupply;\n\t\tuint256 amountInRay;\n\t\tuint256 newStableRate;\n\t\tuint256 currentAvgStableRate;\n\t}\n\n\t/**\n\t * @dev Mints debt token to the `onBehalfOf` address.\n\t * -  Only callable by the LendingPool\n\t * - The resulting rate is the weighted average between the rate of the new debt\n\t * and the rate of the previous debt\n\t * @param user The address receiving the borrowed underlying, being the delegatee in case\n\t * of credit delegate, or same as `onBehalfOf` otherwise\n\t * @param onBehalfOf The address receiving the debt tokens\n\t * @param amount The amount of debt tokens to mint\n\t * @param rate The rate of the debt being minted\n\t **/\n\tfunction mint(\n\t\taddress user,\n\t\taddress onBehalfOf,\n\t\tuint256 amount,\n\t\tuint256 rate\n\t) external override onlyLendingPool returns (bool) {\n\t\tMintLocalVars memory vars;\n\n\t\tif (user != onBehalfOf) {\n\t\t\t_decreaseBorrowAllowance(onBehalfOf, user, amount);\n\t\t}\n\n\t\t(, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);\n\n\t\tvars.previousSupply = totalSupply();\n\t\tvars.currentAvgStableRate = _avgStableRate;\n\t\tvars.nextSupply = _totalSupply = vars.previousSupply.add(amount);\n\n\t\tvars.amountInRay = amount.wadToRay();\n\n\t\tvars.newStableRate = _usersStableRate[onBehalfOf]\n\t\t\t.rayMul(currentBalance.wadToRay())\n\t\t\t.add(vars.amountInRay.rayMul(rate))\n\t\t\t.rayDiv(currentBalance.add(amount).wadToRay());\n\n\t\trequire(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);\n\t\t_usersStableRate[onBehalfOf] = vars.newStableRate;\n\n\t\t//solium-disable-next-line\n\t\t_totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);\n\n\t\t// Calculates the updated average stable rate\n\t\tvars.currentAvgStableRate = _avgStableRate = vars\n\t\t\t.currentAvgStableRate\n\t\t\t.rayMul(vars.previousSupply.wadToRay())\n\t\t\t.add(rate.rayMul(vars.amountInRay))\n\t\t\t.rayDiv(vars.nextSupply.wadToRay());\n\n\t\t_mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);\n\n\t\temit Transfer(address(0), onBehalfOf, amount);\n\n\t\temit Mint(\n\t\t\tuser,\n\t\t\tonBehalfOf,\n\t\t\tamount,\n\t\t\tcurrentBalance,\n\t\t\tbalanceIncrease,\n\t\t\tvars.newStableRate,\n\t\t\tvars.currentAvgStableRate,\n\t\t\tvars.nextSupply\n\t\t);\n\n\t\treturn currentBalance == 0;\n\t}\n\n\t/**\n\t * @dev Burns debt of `user`\n\t * @param user The address of the user getting his debt burned\n\t * @param amount The amount of debt tokens getting burned\n\t **/\n\tfunction burn(address user, uint256 amount) external override onlyLendingPool {\n\t\t(, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);\n\n\t\tuint256 previousSupply = totalSupply();\n\t\tuint256 newAvgStableRate = 0;\n\t\tuint256 nextSupply = 0;\n\t\tuint256 userStableRate = _usersStableRate[user];\n\n\t\t// Since the total supply and each single user debt accrue separately,\n\t\t// there might be accumulation errors so that the last borrower repaying\n\t\t// mght actually try to repay more than the available debt supply.\n\t\t// In this case we simply set the total supply and the avg stable rate to 0\n\t\tif (previousSupply <= amount) {\n\t\t\t_avgStableRate = 0;\n\t\t\t_totalSupply = 0;\n\t\t} else {\n\t\t\tnextSupply = _totalSupply = previousSupply.sub(amount);\n\t\t\tuint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());\n\t\t\tuint256 secondTerm = userStableRate.rayMul(amount.wadToRay());\n\n\t\t\t// For the same reason described above, when the last user is repaying it might\n\t\t\t// happen that user rate * user balance > avg rate * total supply. In that case,\n\t\t\t// we simply set the avg rate to 0\n\t\t\tif (secondTerm >= firstTerm) {\n\t\t\t\tnewAvgStableRate = _avgStableRate = _totalSupply = 0;\n\t\t\t} else {\n\t\t\t\tnewAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());\n\t\t\t}\n\t\t}\n\n\t\tif (amount == currentBalance) {\n\t\t\t_usersStableRate[user] = 0;\n\t\t\t_timestamps[user] = 0;\n\t\t} else {\n\t\t\t//solium-disable-next-line\n\t\t\t_timestamps[user] = uint40(block.timestamp);\n\t\t}\n\t\t//solium-disable-next-line\n\t\t_totalSupplyTimestamp = uint40(block.timestamp);\n\n\t\tif (balanceIncrease > amount) {\n\t\t\tuint256 amountToMint = balanceIncrease.sub(amount);\n\t\t\t_mint(user, amountToMint, previousSupply);\n\t\t\temit Mint(\n\t\t\t\tuser,\n\t\t\t\tuser,\n\t\t\t\tamountToMint,\n\t\t\t\tcurrentBalance,\n\t\t\t\tbalanceIncrease,\n\t\t\t\tuserStableRate,\n\t\t\t\tnewAvgStableRate,\n\t\t\t\tnextSupply\n\t\t\t);\n\t\t} else {\n\t\t\tuint256 amountToBurn = amount.sub(balanceIncrease);\n\t\t\t_burn(user, amountToBurn, previousSupply);\n\t\t\temit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);\n\t\t}\n\n\t\temit Transfer(user, address(0), amount);\n\t}\n\n\t/**\n\t * @dev Calculates the increase in balance since the last user interaction\n\t * @param user The address of the user for which the interest is being accumulated\n\t * @return The previous principal balance, the new principal balance and the balance increase\n\t **/\n\tfunction _calculateBalanceIncrease(address user) internal view returns (uint256, uint256, uint256) {\n\t\tuint256 previousPrincipalBalance = super.balanceOf(user);\n\n\t\tif (previousPrincipalBalance == 0) {\n\t\t\treturn (0, 0, 0);\n\t\t}\n\n\t\t// Calculation of the accrued interest since the last accumulation\n\t\tuint256 balanceIncrease = balanceOf(user).sub(previousPrincipalBalance);\n\n\t\treturn (previousPrincipalBalance, previousPrincipalBalance.add(balanceIncrease), balanceIncrease);\n\t}\n\n\t/**\n\t * @dev Returns the principal and total supply, the average borrow rate and the last supply update timestamp\n\t **/\n\tfunction getSupplyData() public view override returns (uint256, uint256, uint256, uint40) {\n\t\tuint256 avgRate = _avgStableRate;\n\t\treturn (super.totalSupply(), _calcTotalSupply(avgRate), avgRate, _totalSupplyTimestamp);\n\t}\n\n\t/**\n\t * @dev Returns the the total supply and the average stable rate\n\t **/\n\tfunction getTotalSupplyAndAvgRate() public view override returns (uint256, uint256) {\n\t\tuint256 avgRate = _avgStableRate;\n\t\treturn (_calcTotalSupply(avgRate), avgRate);\n\t}\n\n\t/**\n\t * @dev Returns the total supply\n\t **/\n\tfunction totalSupply() public view override returns (uint256) {\n\t\treturn _calcTotalSupply(_avgStableRate);\n\t}\n\n\t/**\n\t * @dev Returns the timestamp at which the total supply was updated\n\t **/\n\tfunction getTotalSupplyLastUpdated() public view override returns (uint40) {\n\t\treturn _totalSupplyTimestamp;\n\t}\n\n\t/**\n\t * @dev Returns the principal debt balance of the user from\n\t * @param user The user's address\n\t * @return The debt balance of the user since the last burn/mint action\n\t **/\n\tfunction principalBalanceOf(address user) external view virtual override returns (uint256) {\n\t\treturn super.balanceOf(user);\n\t}\n\n\t/**\n\t * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n\t **/\n\tfunction UNDERLYING_ASSET_ADDRESS() public view returns (address) {\n\t\treturn _underlyingAsset;\n\t}\n\n\t/**\n\t * @dev Returns the address of the lending pool where this aToken is used\n\t **/\n\tfunction POOL() public view returns (ILendingPool) {\n\t\treturn _pool;\n\t}\n\n\t/**\n\t * @dev Returns the address of the incentives controller contract\n\t **/\n\tfunction getIncentivesController() external view override returns (IAaveIncentivesController) {\n\t\treturn _getIncentivesController();\n\t}\n\n\t/**\n\t * @dev For internal usage in the logic of the parent contracts\n\t **/\n\tfunction _getIncentivesController() internal view override returns (IAaveIncentivesController) {\n\t\treturn _incentivesController;\n\t}\n\n\t/**\n\t * @dev For internal usage in the logic of the parent contracts\n\t **/\n\tfunction _getUnderlyingAssetAddress() internal view override returns (address) {\n\t\treturn _underlyingAsset;\n\t}\n\n\t/**\n\t * @dev For internal usage in the logic of the parent contracts\n\t **/\n\tfunction _getLendingPool() internal view override returns (ILendingPool) {\n\t\treturn _pool;\n\t}\n\n\t/**\n\t * @dev Calculates the total supply\n\t * @param avgRate The average rate at which the total supply increases\n\t * @return The debt balance of the user since the last burn/mint action\n\t **/\n\tfunction _calcTotalSupply(uint256 avgRate) internal view virtual returns (uint256) {\n\t\tuint256 principalSupply = super.totalSupply();\n\n\t\tif (principalSupply == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(avgRate, _totalSupplyTimestamp);\n\n\t\treturn principalSupply.rayMul(cumulatedInterest);\n\t}\n\n\t/**\n\t * @dev Mints stable debt tokens to an user\n\t * @param account The account receiving the debt tokens\n\t * @param amount The amount being minted\n\t * @param oldTotalSupply the total supply before the minting event\n\t **/\n\tfunction _mint(address account, uint256 amount, uint256 oldTotalSupply) internal {\n\t\tuint256 oldAccountBalance = _balances[account];\n\t\tif (address(_incentivesController) != address(0)) {\n\t\t\t_incentivesController.handleActionBefore(account);\n\t\t}\n\t\t_balances[account] = oldAccountBalance.add(amount);\n\t\tif (address(_incentivesController) != address(0)) {\n\t\t\t_incentivesController.handleActionAfter(account, oldAccountBalance, oldTotalSupply);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Burns stable debt tokens of an user\n\t * @param account The user getting his debt burned\n\t * @param amount The amount being burned\n\t * @param oldTotalSupply The total supply before the burning event\n\t **/\n\tfunction _burn(address account, uint256 amount, uint256 oldTotalSupply) internal {\n\t\tuint256 oldAccountBalance = _balances[account];\n\t\tif (address(_incentivesController) != address(0)) {\n\t\t\t_incentivesController.handleActionBefore(account);\n\t\t}\n\t\t_balances[account] = oldAccountBalance.sub(amount, Errors.SDT_BURN_EXCEEDS_BALANCE);\n\t\tif (address(_incentivesController) != address(0)) {\n\t\t\t_incentivesController.handleActionAfter(account, oldAccountBalance, oldTotalSupply);\n\t\t}\n\t}\n}\n"
    },
    "contracts/lending/tokenization/VariableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {IVariableDebtToken} from \"../../interfaces/IVariableDebtToken.sol\";\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {DebtTokenBase} from \"./base/DebtTokenBase.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\nimport {IAaveIncentivesController} from \"../../interfaces/IAaveIncentivesController.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title VariableDebtToken\n * @notice Implements a variable debt token to track the borrowing positions of users\n * at variable rate mode\n * @author Aave\n **/\ncontract VariableDebtToken is DebtTokenBase, IVariableDebtToken {\n\tusing WadRayMath for uint256;\n\tusing SafeMath for uint256;\n\n\tuint256 public constant DEBT_TOKEN_REVISION = 0x1;\n\n\tIAaveIncentivesController internal _incentivesController;\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @dev Initializes the debt token.\n\t * @param pool The address of the lending pool where this aToken will be used\n\t * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n\t * @param incentivesController The smart contract managing potential incentives distribution\n\t * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's\n\t * @param debtTokenName The name of the token\n\t * @param debtTokenSymbol The symbol of the token\n\t */\n\tfunction initialize(\n\t\tILendingPool pool,\n\t\taddress underlyingAsset,\n\t\tIAaveIncentivesController incentivesController,\n\t\tuint8 debtTokenDecimals,\n\t\tstring memory debtTokenName,\n\t\tstring memory debtTokenSymbol,\n\t\tbytes calldata params\n\t) public override initializer {\n\t\t_setName(debtTokenName);\n\t\t_setSymbol(debtTokenSymbol);\n\t\t_setDecimals(debtTokenDecimals);\n\n\t\t_pool = pool;\n\t\t_underlyingAsset = underlyingAsset;\n\t\t_incentivesController = incentivesController;\n\n\t\temit Initialized(\n\t\t\tunderlyingAsset,\n\t\t\taddress(pool),\n\t\t\taddress(incentivesController),\n\t\t\tdebtTokenDecimals,\n\t\t\tdebtTokenName,\n\t\t\tdebtTokenSymbol,\n\t\t\tparams\n\t\t);\n\t}\n\n\t/**\n\t * @dev Gets the revision of the stable debt token implementation\n\t * @return The debt token implementation revision\n\t **/\n\tfunction getRevision() internal pure virtual override returns (uint256) {\n\t\treturn DEBT_TOKEN_REVISION;\n\t}\n\n\t/**\n\t * @dev Calculates the accumulated debt balance of the user\n\t * @return The debt balance of the user\n\t **/\n\tfunction balanceOf(address user) public view virtual override returns (uint256) {\n\t\tuint256 scaledBalance = super.balanceOf(user);\n\n\t\tif (scaledBalance == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn scaledBalance.rayMul(_pool.getReserveNormalizedVariableDebt(_underlyingAsset));\n\t}\n\n\t/**\n\t * @dev Mints debt token to the `onBehalfOf` address\n\t * -  Only callable by the LendingPool\n\t * @param user The address receiving the borrowed underlying, being the delegatee in case\n\t * of credit delegate, or same as `onBehalfOf` otherwise\n\t * @param onBehalfOf The address receiving the debt tokens\n\t * @param amount The amount of debt being minted\n\t * @param index The variable debt index of the reserve\n\t * @return `true` if the the previous balance of the user is 0\n\t **/\n\tfunction mint(\n\t\taddress user,\n\t\taddress onBehalfOf,\n\t\tuint256 amount,\n\t\tuint256 index\n\t) external override onlyLendingPool returns (bool) {\n\t\tif (user != onBehalfOf) {\n\t\t\t_decreaseBorrowAllowance(onBehalfOf, user, amount);\n\t\t}\n\n\t\tuint256 previousBalance = super.balanceOf(onBehalfOf);\n\t\tuint256 amountScaled = amount.rayDiv(index);\n\t\trequire(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n\n\t\t_mint(onBehalfOf, amountScaled);\n\n\t\temit Transfer(address(0), onBehalfOf, amount);\n\t\temit Mint(user, onBehalfOf, amount, index);\n\n\t\treturn previousBalance == 0;\n\t}\n\n\t/**\n\t * @dev Burns user variable debt\n\t * - Only callable by the LendingPool\n\t * @param user The user whose debt is getting burned\n\t * @param amount The amount getting burned\n\t * @param index The variable debt index of the reserve\n\t **/\n\tfunction burn(address user, uint256 amount, uint256 index) external override onlyLendingPool {\n\t\tuint256 amountScaled = amount.rayDiv(index);\n\t\trequire(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n\n\t\t_burn(user, amountScaled);\n\n\t\temit Transfer(user, address(0), amount);\n\t\temit Burn(user, amount, index);\n\t}\n\n\t/**\n\t * @dev Returns the principal debt balance of the user from\n\t * @return The debt balance of the user since the last burn/mint action\n\t **/\n\tfunction scaledBalanceOf(address user) public view virtual override returns (uint256) {\n\t\treturn super.balanceOf(user);\n\t}\n\n\t/**\n\t * @dev Returns the total supply of the variable debt token. Represents the total debt accrued by the users\n\t * @return The total supply\n\t **/\n\tfunction totalSupply() public view virtual override returns (uint256) {\n\t\treturn super.totalSupply().rayMul(_pool.getReserveNormalizedVariableDebt(_underlyingAsset));\n\t}\n\n\t/**\n\t * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n\t * @return the scaled total supply\n\t **/\n\tfunction scaledTotalSupply() public view virtual override returns (uint256) {\n\t\treturn super.totalSupply();\n\t}\n\n\t/**\n\t * @dev Returns the principal balance of the user and principal total supply.\n\t * @param user The address of the user\n\t * @return The principal balance of the user\n\t * @return The principal total supply\n\t **/\n\tfunction getScaledUserBalanceAndSupply(address user) external view override returns (uint256, uint256) {\n\t\treturn (super.balanceOf(user), super.totalSupply());\n\t}\n\n\t/**\n\t * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n\t **/\n\tfunction UNDERLYING_ASSET_ADDRESS() public view returns (address) {\n\t\treturn _underlyingAsset;\n\t}\n\n\t/**\n\t * @dev Returns the address of the incentives controller contract\n\t **/\n\tfunction getIncentivesController() external view override returns (IAaveIncentivesController) {\n\t\treturn _getIncentivesController();\n\t}\n\n\t/**\n\t * @dev Returns the address of the lending pool where this aToken is used\n\t **/\n\tfunction POOL() public view returns (ILendingPool) {\n\t\treturn _pool;\n\t}\n\n\tfunction _getIncentivesController() internal view override returns (IAaveIncentivesController) {\n\t\treturn _incentivesController;\n\t}\n\n\tfunction _getUnderlyingAssetAddress() internal view override returns (address) {\n\t\treturn _underlyingAsset;\n\t}\n\n\tfunction _getLendingPool() internal view override returns (ILendingPool) {\n\t\treturn _pool;\n\t}\n}\n"
    },
    "contracts/lending/UiPoolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ILendingPoolAddressesProvider} from \"../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {IAaveIncentivesController} from \"../interfaces/IAaveIncentivesController.sol\";\nimport {IUiPoolDataProvider} from \"../interfaces/IUiPoolDataProvider.sol\";\nimport {ILendingPool} from \"../interfaces/ILendingPool.sol\";\nimport {IPriceOracleGetter} from \"../interfaces/IPriceOracleGetter.sol\";\nimport {IAToken} from \"../interfaces/IAToken.sol\";\nimport {IVariableDebtToken} from \"../interfaces/IVariableDebtToken.sol\";\nimport {IStableDebtToken} from \"../interfaces/IStableDebtToken.sol\";\nimport {WadRayMath} from \"./libraries/math/WadRayMath.sol\";\nimport {ReserveConfiguration} from \"./libraries/configuration/ReserveConfiguration.sol\";\nimport {UserConfiguration} from \"./libraries/configuration/UserConfiguration.sol\";\nimport {DataTypes} from \"./libraries/types/DataTypes.sol\";\nimport {DefaultReserveInterestRateStrategy} from \"./lendingpool/DefaultReserveInterestRateStrategy.sol\";\n\ncontract UiPoolDataProvider is IUiPoolDataProvider {\n\tusing WadRayMath for uint256;\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\tusing UserConfiguration for DataTypes.UserConfigurationMap;\n\n\taddress public constant MOCK_USD_ADDRESS = 0x10F7Fc1F91Ba351f9C629c5947AD69bD03C05b96;\n\tIAaveIncentivesController public immutable incentivesController;\n\tIPriceOracleGetter public immutable oracle;\n\n\tconstructor(IAaveIncentivesController _incentivesController, IPriceOracleGetter _oracle) {\n\t\tincentivesController = _incentivesController;\n\t\toracle = _oracle;\n\t}\n\n\tfunction getInterestRateStrategySlopes(\n\t\tDefaultReserveInterestRateStrategy interestRateStrategy\n\t) internal view returns (uint256, uint256, uint256, uint256) {\n\t\treturn (\n\t\t\tinterestRateStrategy.variableRateSlope1(),\n\t\t\tinterestRateStrategy.variableRateSlope2(),\n\t\t\tinterestRateStrategy.stableRateSlope1(),\n\t\t\tinterestRateStrategy.stableRateSlope2()\n\t\t);\n\t}\n\n\tfunction getReservesData(\n\t\tILendingPoolAddressesProvider provider,\n\t\taddress user\n\t)\n\t\texternal\n\t\tview\n\t\treturns (AggregatedReserveData[] memory, UserReserveData[] memory, uint256, IncentivesControllerData memory)\n\t{\n\t\tILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n\t\taddress[] memory reserves = lendingPool.getReservesList();\n\t\tDataTypes.UserConfigurationMap memory userConfig = lendingPool.getUserConfiguration(user);\n\n\t\tAggregatedReserveData[] memory reservesData = new AggregatedReserveData[](reserves.length);\n\t\tUserReserveData[] memory userReservesData = new UserReserveData[](user != address(0) ? reserves.length : 0);\n\n\t\tfor (uint256 i = 0; i < reserves.length; ) {\n\t\t\tAggregatedReserveData memory reserveData = reservesData[i];\n\t\t\treserveData.underlyingAsset = reserves[i];\n\n\t\t\t// reserve current state\n\t\t\tDataTypes.ReserveData memory baseData = lendingPool.getReserveData(reserveData.underlyingAsset);\n\t\t\treserveData.liquidityIndex = baseData.liquidityIndex;\n\t\t\treserveData.variableBorrowIndex = baseData.variableBorrowIndex;\n\t\t\treserveData.liquidityRate = baseData.currentLiquidityRate;\n\t\t\treserveData.variableBorrowRate = baseData.currentVariableBorrowRate;\n\t\t\treserveData.stableBorrowRate = baseData.currentStableBorrowRate;\n\t\t\treserveData.lastUpdateTimestamp = baseData.lastUpdateTimestamp;\n\t\t\treserveData.aTokenAddress = baseData.aTokenAddress;\n\t\t\treserveData.stableDebtTokenAddress = baseData.stableDebtTokenAddress;\n\t\t\treserveData.variableDebtTokenAddress = baseData.variableDebtTokenAddress;\n\t\t\treserveData.interestRateStrategyAddress = baseData.interestRateStrategyAddress;\n\t\t\treserveData.priceInEth = oracle.getAssetPrice(reserveData.underlyingAsset);\n\n\t\t\treserveData.availableLiquidity = IERC20Metadata(reserveData.underlyingAsset).balanceOf(\n\t\t\t\treserveData.aTokenAddress\n\t\t\t);\n\t\t\t(\n\t\t\t\treserveData.totalPrincipalStableDebt,\n\t\t\t\t,\n\t\t\t\treserveData.averageStableRate,\n\t\t\t\treserveData.stableDebtLastUpdateTimestamp\n\t\t\t) = IStableDebtToken(reserveData.stableDebtTokenAddress).getSupplyData();\n\t\t\treserveData.totalScaledVariableDebt = IVariableDebtToken(reserveData.variableDebtTokenAddress)\n\t\t\t\t.scaledTotalSupply();\n\n\t\t\t// reserve configuration\n\n\t\t\t// we're getting this info from the aToken, because some of assets can be not compliant with ETC20Detailed\n\t\t\treserveData.symbol = IERC20Metadata(reserveData.aTokenAddress).symbol();\n\t\t\treserveData.name = \"\";\n\n\t\t\t(\n\t\t\t\treserveData.baseLTVasCollateral,\n\t\t\t\treserveData.reserveLiquidationThreshold,\n\t\t\t\treserveData.reserveLiquidationBonus,\n\t\t\t\treserveData.decimals,\n\t\t\t\treserveData.reserveFactor\n\t\t\t) = baseData.configuration.getParamsMemory();\n\t\t\t(\n\t\t\t\treserveData.isActive,\n\t\t\t\treserveData.isFrozen,\n\t\t\t\treserveData.borrowingEnabled,\n\t\t\t\treserveData.stableBorrowRateEnabled\n\t\t\t) = baseData.configuration.getFlagsMemory();\n\t\t\treserveData.usageAsCollateralEnabled = reserveData.baseLTVasCollateral != 0;\n\t\t\t(\n\t\t\t\treserveData.variableRateSlope1,\n\t\t\t\treserveData.variableRateSlope2,\n\t\t\t\treserveData.stableRateSlope1,\n\t\t\t\treserveData.stableRateSlope2\n\t\t\t) = getInterestRateStrategySlopes(\n\t\t\t\tDefaultReserveInterestRateStrategy(reserveData.interestRateStrategyAddress)\n\t\t\t);\n\n\t\t\t// incentives\n\t\t\tif (address(0) != address(incentivesController)) {\n\t\t\t\t(\n\t\t\t\t\treserveData.aTokenIncentivesIndex,\n\t\t\t\t\treserveData.aEmissionPerSecond,\n\t\t\t\t\treserveData.aIncentivesLastUpdateTimestamp\n\t\t\t\t) = incentivesController.getAssetData(reserveData.aTokenAddress);\n\n\t\t\t\t(\n\t\t\t\t\treserveData.sTokenIncentivesIndex,\n\t\t\t\t\treserveData.sEmissionPerSecond,\n\t\t\t\t\treserveData.sIncentivesLastUpdateTimestamp\n\t\t\t\t) = incentivesController.getAssetData(reserveData.stableDebtTokenAddress);\n\n\t\t\t\t(\n\t\t\t\t\treserveData.vTokenIncentivesIndex,\n\t\t\t\t\treserveData.vEmissionPerSecond,\n\t\t\t\t\treserveData.vIncentivesLastUpdateTimestamp\n\t\t\t\t) = incentivesController.getAssetData(reserveData.variableDebtTokenAddress);\n\t\t\t}\n\n\t\t\tif (user != address(0)) {\n\t\t\t\t// incentives\n\t\t\t\tif (address(0) != address(incentivesController)) {\n\t\t\t\t\tuserReservesData[i].aTokenincentivesUserIndex = incentivesController.getUserAssetData(\n\t\t\t\t\t\tuser,\n\t\t\t\t\t\treserveData.aTokenAddress\n\t\t\t\t\t);\n\t\t\t\t\tuserReservesData[i].vTokenincentivesUserIndex = incentivesController.getUserAssetData(\n\t\t\t\t\t\tuser,\n\t\t\t\t\t\treserveData.variableDebtTokenAddress\n\t\t\t\t\t);\n\t\t\t\t\tuserReservesData[i].sTokenincentivesUserIndex = incentivesController.getUserAssetData(\n\t\t\t\t\t\tuser,\n\t\t\t\t\t\treserveData.stableDebtTokenAddress\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t// user reserve data\n\t\t\t\tuserReservesData[i].underlyingAsset = reserveData.underlyingAsset;\n\t\t\t\tuserReservesData[i].scaledATokenBalance = IAToken(reserveData.aTokenAddress).scaledBalanceOf(user);\n\t\t\t\tuserReservesData[i].usageAsCollateralEnabledOnUser = userConfig.isUsingAsCollateral(i);\n\n\t\t\t\tif (userConfig.isBorrowing(i)) {\n\t\t\t\t\tuserReservesData[i].scaledVariableDebt = IVariableDebtToken(reserveData.variableDebtTokenAddress)\n\t\t\t\t\t\t.scaledBalanceOf(user);\n\t\t\t\t\tuserReservesData[i].principalStableDebt = IStableDebtToken(reserveData.stableDebtTokenAddress)\n\t\t\t\t\t\t.principalBalanceOf(user);\n\t\t\t\t\tif (userReservesData[i].principalStableDebt != 0) {\n\t\t\t\t\t\tuserReservesData[i].stableBorrowRate = IStableDebtToken(reserveData.stableDebtTokenAddress)\n\t\t\t\t\t\t\t.getUserStableRate(user);\n\t\t\t\t\t\tuserReservesData[i].stableBorrowLastUpdateTimestamp = IStableDebtToken(\n\t\t\t\t\t\t\treserveData.stableDebtTokenAddress\n\t\t\t\t\t\t).getUserLastUpdated(user);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tIncentivesControllerData memory incentivesControllerData;\n\n\t\tif (address(0) != address(incentivesController)) {\n\t\t\tif (user != address(0)) {\n\t\t\t\tincentivesControllerData.userUnclaimedRewards = incentivesController.getUserUnclaimedRewards(user);\n\t\t\t}\n\t\t\tincentivesControllerData.emissionEndTimestamp = incentivesController.DISTRIBUTION_END();\n\t\t}\n\n\t\treturn (reservesData, userReservesData, 10 ** 8, incentivesControllerData);\n\t}\n}\n"
    },
    "contracts/lending/UiPoolDataProviderV2V3.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ILendingPoolAddressesProvider} from \"../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {IUiPoolDataProviderV3} from \"../interfaces/IUiPoolDataProviderV3.sol\";\nimport {ILendingPool} from \"../interfaces/ILendingPool.sol\";\nimport {IAaveOracle} from \"../interfaces/IAaveOracle.sol\";\nimport {IAToken} from \"../interfaces/IAToken.sol\";\nimport {IVariableDebtToken} from \"../interfaces/IVariableDebtToken.sol\";\nimport {IStableDebtToken} from \"../interfaces/IStableDebtToken.sol\";\nimport {WadRayMath} from \"./libraries/math/WadRayMath.sol\";\nimport {ReserveConfiguration} from \"./libraries/configuration/ReserveConfiguration.sol\";\nimport {UserConfiguration} from \"./libraries/configuration/UserConfiguration.sol\";\nimport {DataTypes} from \"./libraries/types/DataTypes.sol\";\nimport {IChainlinkAggregator} from \"../interfaces/IChainlinkAggregator.sol\";\nimport {DefaultReserveInterestRateStrategy} from \"./lendingpool/DefaultReserveInterestRateStrategy.sol\";\nimport {IERC20DetailedBytes} from \"../interfaces/IERC20DetailedBytes.sol\";\n\ncontract UiPoolDataProviderV2V3 is IUiPoolDataProviderV3 {\n\tusing WadRayMath for uint256;\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\tusing UserConfiguration for DataTypes.UserConfigurationMap;\n\n\tIChainlinkAggregator public immutable networkBaseTokenPriceInUsdProxyAggregator;\n\tIChainlinkAggregator public immutable marketReferenceCurrencyPriceInUsdProxyAggregator;\n\tuint256 public constant ETH_CURRENCY_UNIT = 1 ether;\n\taddress public constant MKRAddress = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;\n\n\tconstructor(\n\t\tIChainlinkAggregator _networkBaseTokenPriceInUsdProxyAggregator,\n\t\tIChainlinkAggregator _marketReferenceCurrencyPriceInUsdProxyAggregator\n\t) {\n\t\tnetworkBaseTokenPriceInUsdProxyAggregator = _networkBaseTokenPriceInUsdProxyAggregator;\n\t\tmarketReferenceCurrencyPriceInUsdProxyAggregator = _marketReferenceCurrencyPriceInUsdProxyAggregator;\n\t}\n\n\tfunction getInterestRateStrategySlopes(\n\t\tDefaultReserveInterestRateStrategy interestRateStrategy\n\t) internal view returns (uint256, uint256, uint256, uint256) {\n\t\treturn (\n\t\t\tinterestRateStrategy.variableRateSlope1(),\n\t\t\tinterestRateStrategy.variableRateSlope2(),\n\t\t\tinterestRateStrategy.stableRateSlope1(),\n\t\t\tinterestRateStrategy.stableRateSlope2()\n\t\t);\n\t}\n\n\tfunction getReservesList(ILendingPoolAddressesProvider provider) public view returns (address[] memory) {\n\t\tILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n\t\treturn lendingPool.getReservesList();\n\t}\n\n\tfunction getReservesData(\n\t\tILendingPoolAddressesProvider provider\n\t) public view returns (AggregatedReserveData[] memory, BaseCurrencyInfo memory) {\n\t\tIAaveOracle oracle = IAaveOracle(provider.getPriceOracle());\n\t\tILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n\t\taddress[] memory reserves = lendingPool.getReservesList();\n\t\tAggregatedReserveData[] memory reservesData = new AggregatedReserveData[](reserves.length);\n\n\t\tfor (uint256 i = 0; i < reserves.length; ) {\n\t\t\tAggregatedReserveData memory reserveData = reservesData[i];\n\t\t\treserveData.underlyingAsset = reserves[i];\n\n\t\t\t// reserve current state\n\t\t\tDataTypes.ReserveData memory baseData = lendingPool.getReserveData(reserveData.underlyingAsset);\n\t\t\treserveData.liquidityIndex = baseData.liquidityIndex;\n\t\t\treserveData.variableBorrowIndex = baseData.variableBorrowIndex;\n\t\t\treserveData.liquidityRate = baseData.currentLiquidityRate;\n\t\t\treserveData.variableBorrowRate = baseData.currentVariableBorrowRate;\n\t\t\treserveData.stableBorrowRate = baseData.currentStableBorrowRate;\n\t\t\treserveData.lastUpdateTimestamp = baseData.lastUpdateTimestamp;\n\t\t\treserveData.aTokenAddress = baseData.aTokenAddress;\n\t\t\treserveData.stableDebtTokenAddress = baseData.stableDebtTokenAddress;\n\t\t\treserveData.variableDebtTokenAddress = baseData.variableDebtTokenAddress;\n\t\t\treserveData.interestRateStrategyAddress = baseData.interestRateStrategyAddress;\n\t\t\treserveData.priceInMarketReferenceCurrency = oracle.getAssetPrice(reserveData.underlyingAsset);\n\n\t\t\treserveData.availableLiquidity = IERC20Metadata(reserveData.underlyingAsset).balanceOf(\n\t\t\t\treserveData.aTokenAddress\n\t\t\t);\n\t\t\t(\n\t\t\t\treserveData.totalPrincipalStableDebt,\n\t\t\t\t,\n\t\t\t\treserveData.averageStableRate,\n\t\t\t\treserveData.stableDebtLastUpdateTimestamp\n\t\t\t) = IStableDebtToken(reserveData.stableDebtTokenAddress).getSupplyData();\n\t\t\treserveData.totalScaledVariableDebt = IVariableDebtToken(reserveData.variableDebtTokenAddress)\n\t\t\t\t.scaledTotalSupply();\n\n\t\t\tif (address(reserveData.underlyingAsset) == address(MKRAddress)) {\n\t\t\t\tbytes32 symbol = IERC20DetailedBytes(reserveData.underlyingAsset).symbol();\n\t\t\t\treserveData.symbol = bytes32ToString(symbol);\n\t\t\t} else {\n\t\t\t\treserveData.symbol = IERC20Metadata(reserveData.underlyingAsset).symbol();\n\t\t\t}\n\n\t\t\t(\n\t\t\t\treserveData.baseLTVasCollateral,\n\t\t\t\treserveData.reserveLiquidationThreshold,\n\t\t\t\treserveData.reserveLiquidationBonus,\n\t\t\t\treserveData.decimals,\n\t\t\t\treserveData.reserveFactor\n\t\t\t) = baseData.configuration.getParamsMemory();\n\t\t\t(\n\t\t\t\treserveData.isActive,\n\t\t\t\treserveData.isFrozen,\n\t\t\t\treserveData.borrowingEnabled,\n\t\t\t\treserveData.stableBorrowRateEnabled\n\t\t\t) = baseData.configuration.getFlagsMemory();\n\t\t\treserveData.usageAsCollateralEnabled = reserveData.baseLTVasCollateral != 0;\n\t\t\t(\n\t\t\t\treserveData.variableRateSlope1,\n\t\t\t\treserveData.variableRateSlope2,\n\t\t\t\treserveData.stableRateSlope1,\n\t\t\t\treserveData.stableRateSlope2\n\t\t\t) = getInterestRateStrategySlopes(\n\t\t\t\tDefaultReserveInterestRateStrategy(reserveData.interestRateStrategyAddress)\n\t\t\t);\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tBaseCurrencyInfo memory baseCurrencyInfo;\n\t\tbaseCurrencyInfo.networkBaseTokenPriceInUsd = networkBaseTokenPriceInUsdProxyAggregator.latestAnswer();\n\t\tbaseCurrencyInfo.networkBaseTokenPriceDecimals = networkBaseTokenPriceInUsdProxyAggregator.decimals();\n\n\t\ttry oracle.BASE_CURRENCY_UNIT() returns (uint256 baseCurrencyUnit) {\n\t\t\tif (ETH_CURRENCY_UNIT == baseCurrencyUnit) {\n\t\t\t\tbaseCurrencyInfo.marketReferenceCurrencyUnit = ETH_CURRENCY_UNIT;\n\t\t\t\tbaseCurrencyInfo.marketReferenceCurrencyPriceInUsd = marketReferenceCurrencyPriceInUsdProxyAggregator\n\t\t\t\t\t.latestAnswer();\n\t\t\t} else {\n\t\t\t\tbaseCurrencyInfo.marketReferenceCurrencyUnit = baseCurrencyUnit;\n\t\t\t\tbaseCurrencyInfo.marketReferenceCurrencyPriceInUsd = int256(baseCurrencyUnit);\n\t\t\t}\n\t\t} catch (bytes memory /*lowLevelData*/) {\n\t\t\tbaseCurrencyInfo.marketReferenceCurrencyUnit = ETH_CURRENCY_UNIT;\n\t\t\tbaseCurrencyInfo.marketReferenceCurrencyPriceInUsd = marketReferenceCurrencyPriceInUsdProxyAggregator\n\t\t\t\t.latestAnswer();\n\t\t}\n\n\t\treturn (reservesData, baseCurrencyInfo);\n\t}\n\n\tfunction getUserReservesData(\n\t\tILendingPoolAddressesProvider provider,\n\t\taddress user\n\t) external view returns (UserReserveData[] memory, uint8) {\n\t\tILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n\t\taddress[] memory reserves = lendingPool.getReservesList();\n\t\tDataTypes.UserConfigurationMap memory userConfig = lendingPool.getUserConfiguration(user);\n\n\t\tUserReserveData[] memory userReservesData = new UserReserveData[](user != address(0) ? reserves.length : 0);\n\n\t\tfor (uint256 i = 0; i < reserves.length; ) {\n\t\t\tDataTypes.ReserveData memory baseData = lendingPool.getReserveData(reserves[i]);\n\n\t\t\t// user reserve data\n\t\t\tuserReservesData[i].underlyingAsset = reserves[i];\n\t\t\tuserReservesData[i].scaledATokenBalance = IAToken(baseData.aTokenAddress).scaledBalanceOf(user);\n\t\t\tuserReservesData[i].usageAsCollateralEnabledOnUser = userConfig.isUsingAsCollateral(i);\n\n\t\t\tif (userConfig.isBorrowing(i)) {\n\t\t\t\tuserReservesData[i].scaledVariableDebt = IVariableDebtToken(baseData.variableDebtTokenAddress)\n\t\t\t\t\t.scaledBalanceOf(user);\n\t\t\t\tuserReservesData[i].principalStableDebt = IStableDebtToken(baseData.stableDebtTokenAddress)\n\t\t\t\t\t.principalBalanceOf(user);\n\t\t\t\tif (userReservesData[i].principalStableDebt != 0) {\n\t\t\t\t\tuserReservesData[i].stableBorrowRate = IStableDebtToken(baseData.stableDebtTokenAddress)\n\t\t\t\t\t\t.getUserStableRate(user);\n\t\t\t\t\tuserReservesData[i].stableBorrowLastUpdateTimestamp = IStableDebtToken(\n\t\t\t\t\t\tbaseData.stableDebtTokenAddress\n\t\t\t\t\t).getUserLastUpdated(user);\n\t\t\t\t}\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t// Return 0 to be compatible with v3 userEmodeCategoryId return\n\t\treturn (userReservesData, 0);\n\t}\n\n\tfunction bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\n\t\tuint8 i = 0;\n\t\twhile (i < 32 && _bytes32[i] != 0) {\n\t\t\ti++;\n\t\t}\n\t\tbytes memory bytesArray = new bytes(i);\n\t\tfor (i = 0; i < 32 && _bytes32[i] != 0; ) {\n\t\t\tbytesArray[i] = _bytes32[i];\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn string(bytesArray);\n\t}\n}\n"
    },
    "contracts/lending/WalletBalanceProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {ILendingPoolAddressesProvider} from \"../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {ILendingPool} from \"../interfaces/ILendingPool.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReserveConfiguration} from \"./libraries/configuration/ReserveConfiguration.sol\";\nimport {DataTypes} from \"./libraries/types/DataTypes.sol\";\n\n/**\n * @title WalletBalanceProvider contract\n * @author Aave, influenced by https://github.com/wbobeirne/eth-balance-checker/blob/master/contracts/BalanceChecker.sol\n * @notice Implements a logic of getting multiple tokens balance for one user address\n * @dev NOTE: THIS CONTRACT IS NOT USED WITHIN THE AAVE PROTOCOL. It's an accessory contract used to reduce the number of calls\n * towards the blockchain from the Aave backend.\n **/\ncontract WalletBalanceProvider {\n\tusing Address for address payable;\n\tusing Address for address;\n\tusing SafeERC20 for IERC20;\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n\taddress constant MOCK_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n\t/**\n    @dev Fallback function, don't accept any ETH\n    **/\n\treceive() external payable {\n\t\t//only contracts can send ETH to the core\n\t\trequire(msg.sender.isContract(), \"22\");\n\t}\n\n\t/**\n    @dev Check the token balance of a wallet in a token contract\n\n    Returns the balance of the token for user. Avoids possible errors:\n      - return 0 on non-contract address\n    **/\n\tfunction balanceOf(address user, address token) public view returns (uint256) {\n\t\tif (token == MOCK_ETH_ADDRESS) {\n\t\t\treturn user.balance; // ETH balance\n\t\t\t// check if token is actually a contract\n\t\t} else if (token.isContract()) {\n\t\t\treturn IERC20(token).balanceOf(user);\n\t\t}\n\t\trevert(\"INVALID_TOKEN\");\n\t}\n\n\t/**\n\t * @notice Fetches, for a list of _users and _tokens (ETH included with mock address), the balances\n\t * @param users The list of users\n\t * @param tokens The list of tokens\n\t * @return And array with the concatenation of, for each user, his/her balances\n\t **/\n\tfunction batchBalanceOf(\n\t\taddress[] calldata users,\n\t\taddress[] calldata tokens\n\t) external view returns (uint256[] memory) {\n\t\tuint256[] memory balances = new uint256[](users.length * tokens.length);\n\n\t\tfor (uint256 i = 0; i < users.length; ) {\n\t\t\tfor (uint256 j = 0; j < tokens.length; ) {\n\t\t\t\tbalances[i * tokens.length + j] = balanceOf(users[i], tokens[j]);\n\t\t\t\tunchecked {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\treturn balances;\n\t}\n\n\t/**\n    @dev provides balances of user wallet for all reserves available on the pool\n    */\n\tfunction getUserWalletBalances(\n\t\taddress provider,\n\t\taddress user\n\t) external view returns (address[] memory, uint256[] memory) {\n\t\tILendingPool pool = ILendingPool(ILendingPoolAddressesProvider(provider).getLendingPool());\n\n\t\taddress[] memory reserves = pool.getReservesList();\n\t\taddress[] memory reservesWithEth = new address[](reserves.length + 1);\n\t\tfor (uint256 i = 0; i < reserves.length; ) {\n\t\t\treservesWithEth[i] = reserves[i];\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treservesWithEth[reserves.length] = MOCK_ETH_ADDRESS;\n\n\t\tuint256[] memory balances = new uint256[](reservesWithEth.length);\n\n\t\tfor (uint256 j = 0; j < reserves.length; ) {\n\t\t\tDataTypes.ReserveConfigurationMap memory configuration = pool.getConfiguration(reservesWithEth[j]);\n\n\t\t\t(bool isActive, , , ) = configuration.getFlagsMemory();\n\n\t\t\tif (!isActive) {\n\t\t\t\tbalances[j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbalances[j] = balanceOf(user, reservesWithEth[j]);\n\t\t\tunchecked {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tbalances[reserves.length] = balanceOf(user, MOCK_ETH_ADDRESS);\n\n\t\treturn (reservesWithEth, balances);\n\t}\n}\n"
    },
    "contracts/lending/WETHGateway.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {IWETHGateway} from \"../interfaces/IWETHGateway.sol\";\nimport {ILendingPool} from \"../interfaces/ILendingPool.sol\";\nimport {IAToken} from \"../interfaces/IAToken.sol\";\nimport {ReserveConfiguration} from \"./libraries/configuration/ReserveConfiguration.sol\";\nimport {UserConfiguration} from \"./libraries/configuration/UserConfiguration.sol\";\nimport {Helpers} from \"./libraries/helpers/Helpers.sol\";\nimport {DataTypes} from \"./libraries/types/DataTypes.sol\";\n\ncontract WETHGateway is IWETHGateway, Ownable {\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\tusing UserConfiguration for DataTypes.UserConfigurationMap;\n\n\tIWETH internal immutable WETH;\n\n\t/**\n\t * @dev Sets the WETH address and the LendingPoolAddressesProvider address. Infinite approves lending pool.\n\t * @param weth Address of the Wrapped Ether contract\n\t **/\n\tconstructor(address weth) {\n\t\tWETH = IWETH(weth);\n\t}\n\n\tfunction authorizeLendingPool(address lendingPool) external onlyOwner {\n\t\tWETH.approve(lendingPool, type(uint256).max);\n\t}\n\n\t/**\n\t * @dev deposits WETH into the reserve, using native ETH. A corresponding amount of the overlying asset (aTokens)\n\t * is minted.\n\t * @param lendingPool address of the targeted underlying lending pool\n\t * @param onBehalfOf address of the user who will receive the aTokens representing the deposit\n\t * @param referralCode integrators are assigned a referral code and can potentially receive rewards.\n\t **/\n\tfunction depositETH(address lendingPool, address onBehalfOf, uint16 referralCode) external payable {\n\t\tWETH.deposit{value: msg.value}();\n\t\tILendingPool(lendingPool).deposit(address(WETH), msg.value, onBehalfOf, referralCode);\n\t}\n\n\tfunction depositETHWithAutoDLP(address lendingPool, address onBehalfOf, uint16 referralCode) external payable {\n\t\tWETH.deposit{value: msg.value}();\n\t\tILendingPool(lendingPool).depositWithAutoDLP(address(WETH), msg.value, onBehalfOf, referralCode);\n\t}\n\n\t/**\n\t * @dev withdraws the WETH _reserves of msg.sender.\n\t * @param lendingPool address of the targeted underlying lending pool\n\t * @param amount amount of aWETH to withdraw and receive native ETH\n\t * @param to address of the user who will receive native ETH\n\t */\n\tfunction withdrawETH(address lendingPool, uint256 amount, address to) external {\n\t\tIAToken aWETH = IAToken(ILendingPool(lendingPool).getReserveData(address(WETH)).aTokenAddress);\n\t\tuint256 userBalance = aWETH.balanceOf(msg.sender);\n\t\tuint256 amountToWithdraw = amount;\n\n\t\t// if amount is equal to uint256(-1), the user wants to redeem everything\n\t\tif (amount == type(uint256).max) {\n\t\t\tamountToWithdraw = userBalance;\n\t\t}\n\t\taWETH.transferFrom(msg.sender, address(this), amountToWithdraw);\n\t\tILendingPool(lendingPool).withdraw(address(WETH), amountToWithdraw, address(this));\n\t\tWETH.withdraw(amountToWithdraw);\n\t\t_safeTransferETH(to, amountToWithdraw);\n\t}\n\n\t/**\n\t * @dev repays a borrow on the WETH reserve, for the specified amount (or for the whole amount, if uint256(-1) is specified).\n\t * @param lendingPool address of the targeted underlying lending pool\n\t * @param amount the amount to repay, or uint256(-1) if the user wants to repay everything\n\t * @param rateMode the rate mode to repay\n\t * @param onBehalfOf the address for which msg.sender is repaying\n\t */\n\tfunction repayETH(address lendingPool, uint256 amount, uint256 rateMode, address onBehalfOf) external payable {\n\t\t(uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebtMemory(\n\t\t\tonBehalfOf,\n\t\t\tILendingPool(lendingPool).getReserveData(address(WETH))\n\t\t);\n\n\t\tuint256 paybackAmount = DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.STABLE\n\t\t\t? stableDebt\n\t\t\t: variableDebt;\n\n\t\tif (amount < paybackAmount) {\n\t\t\tpaybackAmount = amount;\n\t\t}\n\t\trequire(msg.value >= paybackAmount, \"msg.value is less than repayment amount\");\n\t\tWETH.deposit{value: paybackAmount}();\n\t\tILendingPool(lendingPool).repay(address(WETH), msg.value, rateMode, onBehalfOf);\n\n\t\t// refund remaining dust eth\n\t\tif (msg.value > paybackAmount) _safeTransferETH(msg.sender, msg.value - paybackAmount);\n\t}\n\n\t/**\n\t * @dev borrow WETH, unwraps to ETH and send both the ETH and DebtTokens to msg.sender, via `approveDelegation` and onBehalf argument in `LendingPool.borrow`.\n\t * @param lendingPool address of the targeted underlying lending pool\n\t * @param amount the amount of ETH to borrow\n\t * @param interesRateMode the interest rate mode\n\t * @param referralCode integrators are assigned a referral code and can potentially receive rewards\n\t */\n\tfunction borrowETH(address lendingPool, uint256 amount, uint256 interesRateMode, uint16 referralCode) external {\n\t\tILendingPool(lendingPool).borrow(address(WETH), amount, interesRateMode, referralCode, msg.sender);\n\t\tWETH.withdraw(amount);\n\t\t_safeTransferETH(msg.sender, amount);\n\t}\n\n\t/**\n\t * @dev transfer ETH to an address, revert if it fails.\n\t * @param to recipient of the transfer\n\t * @param value the amount to send\n\t */\n\tfunction _safeTransferETH(address to, uint256 value) internal {\n\t\t(bool success, ) = to.call{value: value}(new bytes(0));\n\t\trequire(success, \"ETH_TRANSFER_FAILED\");\n\t}\n\n\t/**\n\t * @dev transfer ERC20 from the utility contract, for ERC20 recovery in case of stuck tokens due\n\t * direct transfers to the contract address.\n\t * @param token token to transfer\n\t * @param to recipient of the transfer\n\t * @param amount amount to send\n\t */\n\tfunction emergencyTokenTransfer(address token, address to, uint256 amount) external onlyOwner {\n\t\tIERC20(token).transfer(to, amount);\n\t}\n\n\t/**\n\t * @dev transfer native Ether from the utility contract, for native Ether recovery in case of stuck Ether\n\t * due selfdestructs or transfer ether to pre-computated contract address before deployment.\n\t * @param to recipient of the transfer\n\t * @param amount amount to send\n\t */\n\tfunction emergencyEtherTransfer(address to, uint256 amount) external onlyOwner {\n\t\t_safeTransferETH(to, amount);\n\t}\n\n\t/**\n\t * @dev Get WETH address used by WETHGateway\n\t */\n\tfunction getWETHAddress() external view returns (address) {\n\t\treturn address(WETH);\n\t}\n\n\t/**\n\t * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\n\t */\n\treceive() external payable {\n\t\trequire(msg.sender == address(WETH), \"Receive not allowed\");\n\t}\n\n\t/**\n\t * @dev Revert fallback calls\n\t */\n\tfallback() external payable {\n\t\trevert(\"Fallback not allowed\");\n\t}\n}\n"
    },
    "contracts/prime/accessories/Compounder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IUniswapV2Router} from \"@uniswap/lib/contracts/interfaces/IUniswapV2Router.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IAToken} from \"../../interfaces/IAToken.sol\";\nimport {IMultiFeeDistribution} from \"../../interfaces/IMultiFeeDistribution.sol\";\nimport {ILendingPoolAddressesProvider} from \"../../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {IAaveOracle} from \"../../interfaces/IAaveOracle.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\nimport {ILockZap} from \"../../interfaces/ILockZap.sol\";\nimport {IPriceProvider} from \"../../interfaces/IPriceProvider.sol\";\nimport {IFeeDistribution} from \"../../interfaces/IFeeDistribution.sol\";\nimport {IMintableToken} from \"../../interfaces/IMintableToken.sol\";\nimport {IBountyManager} from \"../../interfaces/IBountyManager.sol\";\n\n/// @title Compounder Contract\n/// @author Prime\ncontract Compounder is OwnableUpgradeable, PausableUpgradeable {\n\tusing SafeERC20 for IERC20;\n\n\t/// @notice Reward data struct\n\tstruct RewardData {\n\t\taddress token;\n\t\tuint256 amount;\n\t}\n\n\t/********************** Events ***********************/\n\n\t/// @notice Emitted when routes are updated\n\tevent RoutesUpdated(address _token, address[] _routes);\n\n\t/// @notice Emitted when bounty manager is updated\n\tevent BountyManagerUpdated(address indexed _manager);\n\n\t/// @notice Emitted when compounding fee is updated\n\tevent CompoundFeeUpdated(uint256 indexed _compoundFee);\n\n\t/// @notice Emitted when slippage limit is updated\n\tevent SlippageLimitUpdated(uint256 indexed _slippageLimit);\n\n\t/********************** Errors ***********************/\n\terror AddressZero();\n\n\terror InvalidCompoundFee();\n\n\terror InvalidSlippage();\n\n\terror NotBountyManager();\n\n\terror NotEligible();\n\n\terror InsufficientStakeAmount();\n\n\terror ArrayLengthMismatch();\n\n\terror SwapFailed(address asset, uint256 amount);\n\n\t/// @notice The maximum slippage limit that can be set by admins\n\t/// @dev The max slippage should be equal to the max slippage of the LockZap contract, otherwise transactions could revert\n\tuint256 public constant MAX_SLIPPAGE_LIMIT = 8500; //15%\n\n\t/// @notice Percent divisor which is equal to 100%\n\tuint256 public constant PERCENT_DIVISOR = 10000;\n\tuint256 public constant MAX_COMPOUND_FEE = 2000;\n\tuint256 public constant MIN_DELAY = 1 days;\n\t/// @notice Fee of compounding\n\tuint256 public compoundFee;\n\n\t/// @notice Slippage limit for swap\n\tuint256 public slippageLimit;\n\n\t/// @notice PRNT token address\n\tIMintableToken public prntToken;\n\n\t/// @notice Token that PRNT is paired with in LP\n\taddress public baseToken;\n\n\t/// @notice Lending Pool Addresses Provider contract address\n\taddress public addressProvider;\n\n\t/// @notice Price provider contract address\n\taddress public priceProvider;\n\n\t/// @notice Swap route WETH -> PRNT\n\taddress[] public wethToPrime;\n\n\t/// @notice Swap router\n\taddress public uniRouter;\n\n\t/// @notice MFD address\n\taddress public multiFeeDistribution;\n\n\t/// @notice Lockzap address\n\taddress public lockZap;\n\n\t/// @notice BountyManager address\n\taddress public bountyManager;\n\n\t/// @notice Timestamp of last auto compounding\n\tmapping(address => uint256) public lastAutocompound;\n\n\t/// @notice Swap route from rewardToken to baseToken\n\tmapping(address => address[]) public rewardToBaseRoute;\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Initializer\n\t * @param _uniRouter Address of swap router\n\t * @param _mfd Address of MFD\n\t * @param _baseToken Address of pair asset of PRNT LP\n\t * @param _addressProvider Address of LendingPoolAddressesProvider\n\t * @param _lockZap Address of LockZap contract\n\t * @param _compoundFee Compounding fee\n\t * @param _slippageLimit Slippage limit\n\t */\n\tfunction initialize(\n\t\taddress _uniRouter,\n\t\taddress _mfd,\n\t\taddress _baseToken,\n\t\taddress _addressProvider,\n\t\taddress _lockZap,\n\t\tuint256 _compoundFee,\n\t\tuint256 _slippageLimit\n\t) external initializer {\n\t\tif (_uniRouter == address(0)) revert AddressZero();\n\t\tif (_mfd == address(0)) revert AddressZero();\n\t\tif (_baseToken == address(0)) revert AddressZero();\n\t\tif (_addressProvider == address(0)) revert AddressZero();\n\t\tif (_lockZap == address(0)) revert AddressZero();\n\t\tif (_compoundFee == 0) revert InvalidCompoundFee();\n\t\tif (_compoundFee > MAX_COMPOUND_FEE) revert InvalidCompoundFee();\n\t\t_validateSlippageLimit(_slippageLimit);\n\n\t\tuniRouter = _uniRouter;\n\t\tmultiFeeDistribution = _mfd;\n\t\tbaseToken = _baseToken;\n\t\taddressProvider = _addressProvider;\n\t\tlockZap = _lockZap;\n\t\tprntToken = IMultiFeeDistribution(multiFeeDistribution).prntToken();\n\t\tpriceProvider = IMultiFeeDistribution(multiFeeDistribution).getPriceProvider();\n\t\twethToPrime = [baseToken, address(prntToken)];\n\t\tcompoundFee = _compoundFee;\n\t\tslippageLimit = _slippageLimit;\n\t\t__Ownable_init();\n\t\t__Pausable_init();\n\t}\n\n\t/**\n\t * @notice Pause contract\n\t */\n\tfunction pause() external onlyOwner {\n\t\t_pause();\n\t}\n\n\t/**\n\t * @notice Unpause contract\n\t */\n\tfunction unpause() external onlyOwner {\n\t\t_unpause();\n\t}\n\n\t/**\n\t * @notice Set swap routes\n\t * @param _token Token for swap\n\t * @param _routes Swap route for token\n\t */\n\tfunction setRoutes(address _token, address[] memory _routes) external onlyOwner {\n\t\trewardToBaseRoute[_token] = _routes;\n\t\temit RoutesUpdated(_token, _routes);\n\t}\n\n\t/**\n\t * @notice Set bounty manager\n\t * @param _manager Bounty manager address\n\t */\n\tfunction setBountyManager(address _manager) external onlyOwner {\n\t\tif (_manager == address(0)) revert AddressZero();\n\t\tbountyManager = _manager;\n\t\temit BountyManagerUpdated(_manager);\n\t}\n\n\t/**\n\t * @notice Sets the fee for compounding.\n\t * @param _compoundFee fee ratio for compounding\n\t */\n\tfunction setCompoundFee(uint256 _compoundFee) external onlyOwner {\n\t\tif (_compoundFee == 0) revert InvalidCompoundFee();\n\t\tif (_compoundFee > MAX_COMPOUND_FEE) revert InvalidCompoundFee();\n\t\tcompoundFee = _compoundFee;\n\t\temit CompoundFeeUpdated(_compoundFee);\n\t}\n\n\t/**\n\t * @notice Sets slippage limit.\n\t * @param _slippageLimit new slippage limit\n\t */\n\tfunction setSlippageLimit(uint256 _slippageLimit) external onlyOwner {\n\t\t_validateSlippageLimit(_slippageLimit);\n\t\tslippageLimit = _slippageLimit;\n\t\temit SlippageLimitUpdated(_slippageLimit);\n\t}\n\n\t/**\n\t * @notice Claim and swap them into base token.\n\t * @param _user User whose rewards are compounded into dLP\n\t * @param tokens Tokens to claim and turn into dLP\n\t * @param amts Amounts of each token to be claimed and turned into dLP\n\t * @return Total base token amount\n\t */\n\tfunction _claimAndSwapToBase(\n\t\taddress _user,\n\t\taddress[] memory tokens,\n\t\tuint256[] memory amts\n\t) internal returns (uint256) {\n\t\tIMultiFeeDistribution mfd = IMultiFeeDistribution(multiFeeDistribution);\n\t\tmfd.claimFromConverter(_user);\n\t\tILendingPool lendingPool = ILendingPool(ILendingPoolAddressesProvider(addressProvider).getLendingPool());\n\n\t\tuint256 length = tokens.length;\n\t\tfor (uint256 i; i < length; i++) {\n\t\t\tuint256 balance = amts[i];\n\t\t\tif (balance == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\taddress tokenToTrade = tokens[i];\n\t\t\tuint256 amount;\n\t\t\ttry lendingPool.withdraw(tokenToTrade, type(uint256).max, address(this)) returns (uint256 withdrawnAmt) {\n\t\t\t\tamount = withdrawnAmt;\n\t\t\t} catch {\n\t\t\t\tamount = balance;\n\t\t\t}\n\n\t\t\tif (tokenToTrade != baseToken) {\n\t\t\t\tIERC20(tokenToTrade).forceApprove(uniRouter, amount);\n\t\t\t\ttry\n\t\t\t\t\tIUniswapV2Router(uniRouter).swapExactTokensForTokens(\n\t\t\t\t\t\tamount,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\trewardToBaseRoute[tokenToTrade],\n\t\t\t\t\t\taddress(this),\n\t\t\t\t\t\tblock.timestamp\n\t\t\t\t\t)\n\t\t\t\t{} catch {\n\t\t\t\t\trevert SwapFailed(tokenToTrade, amount);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn IERC20(baseToken).balanceOf(address(this));\n\t}\n\n\t/**\n\t * @notice Converts base token to lp token and stake them.\n\t * @param _user User for this action\n\t * @param _slippage maximum tolerated slippage for any occurring swaps\n\t * @return liquidity LP token amount\n\t */\n\tfunction _convertBaseToLPandStake(address _user, uint256 _slippage) internal returns (uint256 liquidity) {\n\t\tuint256 baseBal = IERC20(baseToken).balanceOf(address(this));\n\t\tif (baseBal != 0) {\n\t\t\tIERC20(baseToken).forceApprove(lockZap, baseBal);\n\t\t\tliquidity = ILockZap(lockZap).zapOnBehalf(false, address(0), baseBal, 0, _user, _slippage);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Compound user's rewards\n\t * @dev Can be auto compound or manual compound\n\t * @param _user user address\n\t * @param _execute whether to execute txn, or just quote (expected amount out for bounty executor)\n\t * @param _slippage that shouldn't be exceeded when performing swaps\n\t * @return fee amount\n\t */\n\tfunction claimCompound(address _user, bool _execute, uint256 _slippage) public returns (uint256 fee) {\n\t\tif (paused()) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 slippageLimit_ = slippageLimit;\n\n\t\tbool isAutoCompound = _user != msg.sender;\n\n\t\t(address[] memory tokens, uint256[] memory amts) = viewPendingRewards(_user);\n\t\tuint256 noSlippagePendingEth = _quoteSwapWithOracles(tokens, amts, baseToken);\n\n\t\tif (isAutoCompound) {\n\t\t\t_slippage = IMultiFeeDistribution(multiFeeDistribution).userSlippage(_user);\n\t\t}\n\t\tif (_slippage == 0) {\n\t\t\t_slippage = slippageLimit_;\n\t\t}\n\t\tif (_slippage < slippageLimit_ || _slippage >= PERCENT_DIVISOR) revert InvalidSlippage();\n\n\t\tif (isAutoCompound) {\n\t\t\tif (msg.sender != bountyManager) revert NotBountyManager();\n\t\t\tbool eligible = isEligibleForAutoCompound(_user, noSlippagePendingEth);\n\t\t\tif (!eligible) {\n\t\t\t\tif (_execute) {\n\t\t\t\t\trevert NotEligible();\n\t\t\t\t} else {\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!isEligibleForCompound(noSlippagePendingEth)) revert InsufficientStakeAmount();\n\t\t}\n\n\t\tif (!_execute) {\n\t\t\tif (isAutoCompound) {\n\t\t\t\tuint256 pendingInPrnt = _wethToPrnt(noSlippagePendingEth, _execute, _slippage);\n\t\t\t\tfee = (pendingInPrnt * compoundFee) / PERCENT_DIVISOR;\n\t\t\t\treturn fee;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tuint256 actualWethAfterSwap = _claimAndSwapToBase(_user, tokens, amts);\n\t\tif ((PERCENT_DIVISOR * actualWethAfterSwap) / noSlippagePendingEth < _slippage) revert InvalidSlippage();\n\n\t\tif (isAutoCompound) {\n\t\t\tfee = _wethToPrnt(((actualWethAfterSwap * compoundFee) / PERCENT_DIVISOR), _execute, _slippage);\n\t\t}\n\n\t\t_convertBaseToLPandStake(_user, _slippage);\n\n\t\tif (isAutoCompound) {\n\t\t\tprntToken.approve(bountyManager, fee);\n\t\t\tlastAutocompound[_user] = block.timestamp;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Compound `msg.sender`'s rewards.\n\t * @param _slippage that shouldn't be exceeded when performing swaps\n\t */\n\tfunction selfCompound(uint256 _slippage) external {\n\t\tclaimCompound(msg.sender, true, _slippage);\n\t}\n\n\t/**\n\t * @notice Returns the pending rewards of the `_user`\n\t * @param _user owner of rewards\n\t * @return tokens array of reward token addresses\n\t * @return amts array of reward amounts\n\t */\n\tfunction viewPendingRewards(address _user) public view returns (address[] memory tokens, uint256[] memory amts) {\n\t\tIFeeDistribution.RewardData[] memory pending = IMultiFeeDistribution(multiFeeDistribution).claimableRewards(\n\t\t\t_user\n\t\t);\n\t\ttokens = new address[](pending.length - 1);\n\t\tamts = new uint256[](pending.length - 1);\n\t\tuint256 index;\n\t\tuint256 length = pending.length;\n\t\tfor (uint256 i; i < length;) {\n\t\t\tif (pending[i].token != address(prntToken)) {\n\t\t\t\ttry IAToken(pending[i].token).UNDERLYING_ASSET_ADDRESS() returns (address underlyingAddress) {\n\t\t\t\t\ttokens[index] = underlyingAddress;\n\t\t\t\t} catch {\n\t\t\t\t\ttokens[index] = pending[i].token;\n\t\t\t\t}\n\t\t\t\tamts[index] = pending[i].amount;\n\t\t\t\tunchecked {\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Estimate the out tokens amount.\n\t * @param _in token address\n\t * @param _out token address\n\t * @param _amtIn amount of input token\n\t * @return tokensOut amount of output\n\t */\n\tfunction _estimateTokensOut(address _in, address _out, uint256 _amtIn) internal view returns (uint256 tokensOut) {\n\t\tIAaveOracle oracle = IAaveOracle(ILendingPoolAddressesProvider(addressProvider).getPriceOracle());\n\t\tuint256 priceInAsset = oracle.getAssetPrice(_in); //USDC: 100000000\n\t\tuint256 priceOutAsset = oracle.getAssetPrice(_out); //WETH: 153359950000\n\t\tuint256 decimalsIn = IERC20Metadata(_in).decimals();\n\t\tuint256 decimalsOut = IERC20Metadata(_out).decimals();\n\t\ttokensOut = (_amtIn * priceInAsset * (10 ** decimalsOut)) / (priceOutAsset * (10 ** decimalsIn));\n\t}\n\n\t/**\n\t * @notice Estimate the out tokens amount.\n\t * @param _in array of input token address\n\t * @param _amtsIn amount of input tokens\n\t * @return amtOut Sum of outputs\n\t */\n\tfunction _quoteSwapWithOracles(\n\t\taddress[] memory _in,\n\t\tuint256[] memory _amtsIn,\n\t\taddress _out\n\t) internal view returns (uint256 amtOut) {\n\t\tif (_in.length != _amtsIn.length) revert ArrayLengthMismatch();\n\t\tuint256 length = _in.length;\n\t\tfor (uint256 i; i < length;) {\n\t\t\tamtOut += _estimateTokensOut(_in[i], _out, _amtsIn[i]);\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Swap WETH to PRNT.\n\t * @param _wethIn WETH input amount\n\t * @param _execute Option to excute this action or not\n\t * @param _slippageLimit User defined slippage limit\n\t * @return prntOut Output PRNT amount\n\t */\n\tfunction _wethToPrnt(uint256 _wethIn, bool _execute, uint256 _slippageLimit) internal returns (uint256 prntOut) {\n\t\tif (_execute) {\n\t\t\tIPriceProvider(priceProvider).update();\n\t\t}\n\t\tuint256 prntPrice = IPriceProvider(priceProvider).getTokenPrice();\n\t\tif (_wethIn != 0) {\n\t\t\tif (_execute) {\n\t\t\t\tIERC20(baseToken).forceApprove(uniRouter, _wethIn);\n\t\t\t\tuint256[] memory amounts = IUniswapV2Router(uniRouter).swapExactTokensForTokens(\n\t\t\t\t\t_wethIn,\n\t\t\t\t\t0,\n\t\t\t\t\twethToPrime,\n\t\t\t\t\taddress(this),\n\t\t\t\t\tblock.timestamp\n\t\t\t\t);\n\t\t\t\tprntOut = amounts[amounts.length - 1];\n\t\t\t} else {\n\t\t\t\tuint256[] memory amounts = IUniswapV2Router(uniRouter).getAmountsOut(\n\t\t\t\t\t_wethIn, //amt in\n\t\t\t\t\twethToPrime\n\t\t\t\t);\n\t\t\t\tprntOut = amounts[amounts.length - 1];\n\t\t\t}\n\t\t}\n\t\tuint256 ethValueOfPRNT = prntPrice * prntOut;\n\t\tif (ethValueOfPRNT / 10 ** 8 < (_wethIn * _slippageLimit) / PERCENT_DIVISOR) revert InvalidSlippage();\n\t}\n\n\t/**\n\t * @notice Returns minimum stake amount in ETH\n\t * @return minStakeAmtEth Minimum stake amount in ETH\n\t */\n\tfunction autocompoundThreshold() public view returns (uint256 minStakeAmtEth) {\n\t\tIPriceProvider priceProv = IPriceProvider(priceProvider);\n\n\t\tuint256 minStakeLpAmt = IBountyManager(bountyManager).minDLPBalance();\n\t\tuint256 lpPriceEth = priceProv.getLpTokenPrice();\n\n\t\tminStakeAmtEth = (minStakeLpAmt * lpPriceEth) / (10 ** priceProv.decimals());\n\t}\n\n\t/**\n\t * @notice Returns if user is eligbile for auto compounding\n\t * @param _user address\n\t * @param _pending amount\n\t * @return True or False\n\t */\n\tfunction isEligibleForAutoCompound(address _user, uint256 _pending) public view returns (bool) {\n\t\tbool delayComplete = true;\n\t\tif (lastAutocompound[_user] != 0) {\n\t\t\tdelayComplete = (block.timestamp - lastAutocompound[_user]) >= MIN_DELAY;\n\t\t}\n\t\treturn\n\t\t\tIMultiFeeDistribution(multiFeeDistribution).autocompoundEnabled(_user) &&\n\t\t\tisEligibleForCompound(_pending) &&\n\t\t\tdelayComplete;\n\t}\n\n\t/**\n\t * @notice Returns if pending amount is elgible for auto compounding\n\t * @param _pending amount\n\t * @return eligible True or False\n\t */\n\tfunction isEligibleForCompound(uint256 _pending) public view returns (bool eligible) {\n\t\teligible = _pending >= autocompoundThreshold();\n\t}\n\n\t/**\n\t * @notice Returns if the user is eligible for auto compound\n\t * @param _user address\n\t * @return eligible `true` or `false`\n\t */\n\tfunction userEligibleForCompound(address _user) external view returns (bool eligible) {\n\t\teligible = _userEligibleForCompound(_user);\n\t}\n\n\t/**\n\t * @notice Returns if the `msg.sender` is eligible for self compound\n\t * @return eligible `true` or `false`\n\t */\n\tfunction selfEligibleCompound() external view returns (bool eligible) {\n\t\teligible = _userEligibleForCompound(msg.sender);\n\t}\n\n\t/**\n\t * @notice Returns if the user is eligible for auto compound\n\t * @param _user address the be checked\n\t * @return eligible `true` if eligible or `false` if not\n\t */\n\tfunction _userEligibleForCompound(address _user) internal view returns (bool eligible) {\n\t\t(address[] memory tokens, uint256[] memory amts) = viewPendingRewards(_user);\n\t\tuint256 pendingEth = _quoteSwapWithOracles(tokens, amts, baseToken);\n\t\teligible = pendingEth >= autocompoundThreshold();\n\t}\n\n\t/**\n\t * @notice Validate if the slippage limit is within the boundaries\n\t * @param _slippageLimit slippage limit to be validated\n\t */\n\tfunction _validateSlippageLimit(uint256 _slippageLimit) internal pure {\n\t\tif (_slippageLimit < MAX_SLIPPAGE_LIMIT || _slippageLimit >= PERCENT_DIVISOR) revert InvalidSlippage();\n\t}\n}\n"
    },
    "contracts/prime/accessories/Leverager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {TransferHelper} from \"../libraries/TransferHelper.sol\";\nimport {ILendingPool, DataTypes} from \"../../interfaces/ILendingPool.sol\";\nimport {IEligibilityDataProvider} from \"../../interfaces/IEligibilityDataProvider.sol\";\nimport {IChainlinkAggregator} from \"../../interfaces/IChainlinkAggregator.sol\";\nimport {IChefIncentivesController} from \"../../interfaces/IChefIncentivesController.sol\";\nimport {ILockZap} from \"../../interfaces/ILockZap.sol\";\nimport {IAaveOracle} from \"../../interfaces/IAaveOracle.sol\";\nimport {IWETH} from \"../../interfaces/IWETH.sol\";\n\n/// @title Leverager Contract\n/// @author Prime\ncontract Leverager is OwnableUpgradeable {\n\tusing SafeERC20 for IERC20;\n\n\t/// @notice margin estimation used for zapping eth to dlp\n\tuint256 public constant ZAP_MARGIN_ESTIMATION = 6;\n\n\t/// @notice maximum margin allowed to be set by the deployer\n\tuint256 public constant MAX_MARGIN = 10;\n\n\t/// @notice Ratio Divisor\n\tuint256 public constant RATIO_DIVISOR = 10000;\n\n\t// Max reasonable fee, 1%\n\tuint256 public constant MAX_REASONABLE_FEE = 100;\n\n\t/// @notice Mock ETH address\n\taddress public constant API_ETH_MOCK_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n\t/// @notice LTV Calculation precision\n\tuint256 public constant TWO_POW_16 = 2 ** 16;\n\n\t/// @notice Interest rate mode\n\tuint256 public constant INTEREST_RATE_MODE = 2;\n\n\t/// @notice Lending Pool address\n\tILendingPool public lendingPool;\n\n\t/// @notice EligibilityDataProvider contract address\n\tIEligibilityDataProvider public eligibilityDataProvider;\n\n\t/// @notice LockZap contract address\n\tILockZap public lockZap;\n\n\t/// @notice Wrapped ETH contract address\n\tIWETH public weth;\n\n\t/// @notice Aave oracle address\n\tIAaveOracle public aaveOracle;\n\n\t/// @notice Fee ratio\n\tuint256 public feePercent;\n\n\t/// @notice Treasury address\n\taddress public treasury;\n\n\t/// @notice ChefIncentivesController contract address\n\tIChefIncentivesController public cic;\n\n\t/// @notice Emitted when fee ratio is updated\n\tevent FeePercentUpdated(uint256 indexed _feePercent);\n\n\t/// @notice Emitted when treasury is updated\n\tevent TreasuryUpdated(address indexed _treasury);\n\n\terror AddressZero();\n\n\terror ReceiveNotAllowed();\n\n\terror FallbackNotAllowed();\n\n\terror InsufficientPermission();\n\n\terror EthTransferFailed();\n\n\t/// @notice Disallow a loop count of 0\n\terror InvalidLoopCount();\n\n\t/// @notice Emitted when ratio is invalid\n\terror InvalidRatio();\n\n\t/// @notice Thrown when deployer sets the margin too high\n\terror MarginTooHigh();\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Initializer\n\t * @param _lendingPool Address of lending pool.\n\t * @param _rewardEligibleDataProvider EligibilityProvider address.\n\t * @param _aaveOracle address.\n\t * @param _lockZap address.\n\t * @param _cic address.\n\t * @param _weth WETH address.\n\t * @param _feePercent leveraging fee ratio.\n\t * @param _treasury address.\n\t */\n\tfunction initialize(\n\t\tILendingPool _lendingPool,\n\t\tIEligibilityDataProvider _rewardEligibleDataProvider,\n\t\tIAaveOracle _aaveOracle,\n\t\tILockZap _lockZap,\n\t\tIChefIncentivesController _cic,\n\t\tIWETH _weth,\n\t\tuint256 _feePercent,\n\t\taddress _treasury\n\t) public initializer {\n\t\tif (address(_lendingPool) == address(0)) revert AddressZero();\n\t\tif (address(_rewardEligibleDataProvider) == address(0)) revert AddressZero();\n\t\tif (address(_aaveOracle) == address(0)) revert AddressZero();\n\t\tif (address(_lockZap) == address(0)) revert AddressZero();\n\t\tif (address(_cic) == address(0)) revert AddressZero();\n\t\tif (address(_weth) == address(0)) revert AddressZero();\n\t\tif (_treasury == address(0)) revert AddressZero();\n\t\tif (_feePercent > MAX_REASONABLE_FEE) revert InvalidRatio();\n\t\t__Ownable_init();\n\n\t\tlendingPool = _lendingPool;\n\t\teligibilityDataProvider = _rewardEligibleDataProvider;\n\t\tlockZap = _lockZap;\n\t\taaveOracle = _aaveOracle;\n\t\tcic = _cic;\n\t\tweth = _weth;\n\t\tfeePercent = _feePercent;\n\t\ttreasury = _treasury;\n\t}\n\n\t/**\n\t * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\n\t */\n\treceive() external payable {\n\t\tif (msg.sender != address(weth)) revert ReceiveNotAllowed();\n\t}\n\n\t/**\n\t * @dev Revert fallback calls\n\t */\n\tfallback() external payable {\n\t\trevert FallbackNotAllowed();\n\t}\n\n\t/**\n\t * @notice Sets fee ratio\n\t * @param _feePercent fee ratio.\n\t */\n\tfunction setFeePercent(uint256 _feePercent) external onlyOwner {\n\t\tif (_feePercent > MAX_REASONABLE_FEE) revert InvalidRatio();\n\t\tfeePercent = _feePercent;\n\t\temit FeePercentUpdated(_feePercent);\n\t}\n\n\t/**\n\t * @notice Sets fee ratio\n\t * @param _treasury address\n\t */\n\tfunction setTreasury(address _treasury) external onlyOwner {\n\t\tif (_treasury == address(0)) revert AddressZero();\n\t\ttreasury = _treasury;\n\t\temit TreasuryUpdated(_treasury);\n\t}\n\n\t/**\n\t * @dev Returns the configuration of the reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The configuration of the reserve\n\t **/\n\tfunction getConfiguration(address asset) public view returns (DataTypes.ReserveConfigurationMap memory) {\n\t\treturn lendingPool.getConfiguration(asset);\n\t}\n\n\t/**\n\t * @dev Returns variable debt token address of asset\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return varaiableDebtToken address of the asset\n\t **/\n\tfunction getVDebtToken(address asset) external view returns (address) {\n\t\tDataTypes.ReserveData memory reserveData = lendingPool.getReserveData(asset);\n\t\treturn reserveData.variableDebtTokenAddress;\n\t}\n\n\t/**\n\t * @dev Returns loan to value\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return ltv of the asset\n\t **/\n\tfunction ltv(address asset) external view returns (uint256) {\n\t\tDataTypes.ReserveConfigurationMap memory conf = getConfiguration(asset);\n\t\treturn conf.data % TWO_POW_16;\n\t}\n\n\t/**\n\t * @dev Loop the deposit and borrow of an asset\n\t * @param asset for loop\n\t * @param amount for the initial deposit\n\t * @param interestRateMode stable or variable borrow mode\n\t * @param borrowRatio Ratio of tokens to borrow\n\t * @param loopCount Repeat count for loop\n\t * @param isBorrow true when the loop without deposit tokens\n\t **/\n\tfunction loop(\n\t\taddress asset,\n\t\tuint256 amount,\n\t\tuint256 interestRateMode,\n\t\tuint256 borrowRatio,\n\t\tuint256 loopCount,\n\t\tbool isBorrow\n\t) external {\n\t\tif (!(borrowRatio > 0 && borrowRatio <= RATIO_DIVISOR)) revert InvalidRatio();\n\t\tif (loopCount == 0) revert InvalidLoopCount();\n\t\tuint16 referralCode = 0;\n\t\tuint256 fee;\n\t\tif (!isBorrow) {\n\t\t\tIERC20(asset).safeTransferFrom(msg.sender, address(this), amount);\n\t\t\tfee = (amount * feePercent) / RATIO_DIVISOR;\n\t\t\tif (fee > 0) {\n\t\t\t\tIERC20(asset).safeTransfer(treasury, fee);\n\t\t\t\tamount = amount - fee;\n\t\t\t}\n\t\t}\n\t\t_approve(asset);\n\n\t\tcic.setEligibilityExempt(msg.sender, true);\n\n\t\tif (!isBorrow) {\n\t\t\tlendingPool.deposit(asset, amount, msg.sender, referralCode);\n\t\t} else {\n\t\t\tamount = (amount * RATIO_DIVISOR) / borrowRatio;\n\t\t}\n\n\t\tfor (uint256 i = 0; i < loopCount; ) {\n\t\t\t// Reenable on last deposit\n\t\t\tif (i == (loopCount - 1)) {\n\t\t\t\tcic.setEligibilityExempt(msg.sender, false);\n\t\t\t}\n\n\t\t\tamount = (amount * borrowRatio) / RATIO_DIVISOR;\n\t\t\tlendingPool.borrow(asset, amount, interestRateMode, referralCode, msg.sender);\n\n\t\t\tfee = (amount * feePercent) / RATIO_DIVISOR;\n\t\t\tif (fee > 0) {\n\t\t\t\tIERC20(asset).safeTransfer(treasury, fee);\n\t\t\t\tamount = amount - fee;\n\t\t\t}\n\n\t\t\tlendingPool.deposit(asset, amount, msg.sender, referralCode);\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tzapWETHWithBorrow(wethToZap(msg.sender), msg.sender);\n\t}\n\n\t/**\n\t * @dev Loop the deposit and borrow of ETH\n\t * @param interestRateMode stable or variable borrow mode\n\t * @param borrowRatio Ratio of tokens to borrow\n\t * @param loopCount Repeat count for loop\n\t **/\n\tfunction loopETH(uint256 interestRateMode, uint256 borrowRatio, uint256 loopCount) external payable {\n\t\tif (!(borrowRatio > 0 && borrowRatio <= RATIO_DIVISOR)) revert InvalidRatio();\n\t\tif (loopCount == 0) revert InvalidLoopCount();\n\t\tuint16 referralCode = 0;\n\t\tuint256 amount = msg.value;\n\t\t_approve(address(weth));\n\n\t\tuint256 fee = (amount * feePercent) / RATIO_DIVISOR;\n\t\tif (fee > 0) {\n\t\t\tTransferHelper.safeTransferETH(treasury, fee);\n\t\t\tamount = amount - fee;\n\t\t}\n\n\t\tcic.setEligibilityExempt(msg.sender, true);\n\n\t\tweth.deposit{value: amount}();\n\t\tlendingPool.deposit(address(weth), amount, msg.sender, referralCode);\n\n\t\tfor (uint256 i = 0; i < loopCount; ) {\n\t\t\t// Reenable on last deposit\n\t\t\tif (i == (loopCount - 1)) {\n\t\t\t\tcic.setEligibilityExempt(msg.sender, false);\n\t\t\t}\n\n\t\t\tamount = (amount * borrowRatio) / RATIO_DIVISOR;\n\t\t\tlendingPool.borrow(address(weth), amount, interestRateMode, referralCode, msg.sender);\n\n\t\t\tfee = (amount * feePercent) / RATIO_DIVISOR;\n\t\t\tif (fee > 0) {\n\t\t\t\tweth.withdraw(fee);\n\t\t\t\tTransferHelper.safeTransferETH(treasury, fee);\n\t\t\t\tamount = amount - fee;\n\t\t\t}\n\n\t\t\tlendingPool.deposit(address(weth), amount, msg.sender, referralCode);\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tzapWETHWithBorrow(wethToZap(msg.sender), msg.sender);\n\t}\n\n\t/**\n\t * @dev Loop the borrow and deposit of ETH\n\t * @param interestRateMode stable or variable borrow mode\n\t * @param amount initial amount to borrow\n\t * @param borrowRatio Ratio of tokens to borrow\n\t * @param loopCount Repeat count for loop\n\t **/\n\tfunction loopETHFromBorrow(\n\t\tuint256 interestRateMode,\n\t\tuint256 amount,\n\t\tuint256 borrowRatio,\n\t\tuint256 loopCount\n\t) external {\n\t\tif (!(borrowRatio > 0 && borrowRatio <= RATIO_DIVISOR)) revert InvalidRatio();\n\t\tif (loopCount == 0) revert InvalidLoopCount();\n\t\tuint16 referralCode = 0;\n\t\t_approve(address(weth));\n\n\t\tuint256 fee;\n\n\t\tcic.setEligibilityExempt(msg.sender, true);\n\n\t\tfor (uint256 i = 0; i < loopCount; ) {\n\t\t\t// Reenable on last deposit\n\t\t\tif (i == (loopCount - 1)) {\n\t\t\t\tcic.setEligibilityExempt(msg.sender, false);\n\t\t\t}\n\n\t\t\tlendingPool.borrow(address(weth), amount, interestRateMode, referralCode, msg.sender);\n\n\t\t\tfee = (amount * feePercent) / RATIO_DIVISOR;\n\t\t\tif (fee > 0) {\n\t\t\t\tweth.withdraw(fee);\n\t\t\t\tTransferHelper.safeTransferETH(treasury, fee);\n\t\t\t\tamount = amount - fee;\n\t\t\t}\n\n\t\t\tlendingPool.deposit(address(weth), amount, msg.sender, referralCode);\n\n\t\t\tamount = (amount * borrowRatio) / RATIO_DIVISOR;\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tzapWETHWithBorrow(wethToZap(msg.sender), msg.sender);\n\t}\n\n\t/**\n\t * @notice Return estimated zap WETH amount for eligbility after loop.\n\t * @param user for zap\n\t * @param asset src token\n\t * @param amount of `asset`\n\t * @param borrowRatio Single ratio of borrow\n\t * @param loopCount Repeat count for loop\n\t * @return WETH amount\n\t **/\n\tfunction wethToZapEstimation(\n\t\taddress user,\n\t\taddress asset,\n\t\tuint256 amount,\n\t\tuint256 borrowRatio,\n\t\tuint256 loopCount\n\t) external view returns (uint256) {\n\t\tif (asset == API_ETH_MOCK_ADDRESS) {\n\t\t\tasset = address(weth);\n\t\t}\n\t\tuint256 required = eligibilityDataProvider.requiredUsdValue(user);\n\t\tuint256 locked = eligibilityDataProvider.lockedUsdValue(user);\n\n\t\tuint256 fee = (amount * feePercent) / RATIO_DIVISOR;\n\t\tamount = amount - fee;\n\n\t\trequired = required + _requiredLocked(asset, amount);\n\n\t\tfor (uint256 i = 0; i < loopCount; ) {\n\t\t\tamount = (amount * borrowRatio) / RATIO_DIVISOR;\n\t\t\tfee = (amount * feePercent) / RATIO_DIVISOR;\n\t\t\tamount = amount - fee;\n\t\t\trequired = required + _requiredLocked(asset, amount);\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn _calcWethAmount(locked, required);\n\t}\n\n\t/**\n\t * @notice Return estimated zap WETH amount for eligbility.\n\t * @param user for zap\n\t * @return WETH amount\n\t **/\n\tfunction wethToZap(address user) public view returns (uint256) {\n\t\tuint256 required = eligibilityDataProvider.requiredUsdValue(user);\n\t\tuint256 locked = eligibilityDataProvider.lockedUsdValue(user);\n\t\treturn _calcWethAmount(locked, required);\n\t}\n\n\t/**\n\t * @notice Zap WETH by borrowing.\n\t * @param amount to zap\n\t * @param borrower to zap\n\t * @return liquidity amount by zapping\n\t **/\n\tfunction zapWETHWithBorrow(uint256 amount, address borrower) public returns (uint256 liquidity) {\n\t\tif (msg.sender != borrower && msg.sender != address(lendingPool)) revert InsufficientPermission();\n\n\t\tif (amount > 0) {\n\t\t\tuint16 referralCode = 0;\n\t\t\tlendingPool.borrow(address(weth), amount, INTEREST_RATE_MODE, referralCode, borrower);\n\t\t\tif (IERC20(address(weth)).allowance(address(this), address(lockZap)) == 0) {\n\t\t\t\tIERC20(address(weth)).forceApprove(address(lockZap), type(uint256).max);\n\t\t\t}\n\t\t\t// Using default slippage value\n\t\t\tliquidity = lockZap.zapOnBehalf(false, address(0), amount, 0, borrower, 0);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Set the CIC contract address\n\t * @param _cic CIC contract address\n\t */\n\tfunction setChefIncentivesController(IChefIncentivesController _cic) external onlyOwner {\n\t\tif (address(_cic) == address(0)) revert AddressZero();\n\t\tcic = _cic;\n\t}\n\n\t/**\n\t * @notice Returns required LP lock amount.\n\t * @param asset underlying asset\n\t * @param amount of tokens\n\t * @return Required lock value\n\t **/\n\tfunction _requiredLocked(address asset, uint256 amount) internal view returns (uint256) {\n\t\tuint256 assetPrice = aaveOracle.getAssetPrice(asset);\n\t\tuint8 assetDecimal = IERC20Metadata(asset).decimals();\n\t\tuint256 requiredVal = (((assetPrice * amount) / (10 ** assetDecimal)) *\n\t\t\teligibilityDataProvider.requiredDepositRatio()) / eligibilityDataProvider.RATIO_DIVISOR();\n\t\treturn requiredVal;\n\t}\n\n\t/**\n\t * @notice Approves token allowance of `lendingPool` and `treasury`.\n\t * @param asset underlyig asset\n\t **/\n\tfunction _approve(address asset) internal {\n\t\tif (IERC20(asset).allowance(address(this), address(lendingPool)) == 0) {\n\t\t\tIERC20(asset).forceApprove(address(lendingPool), type(uint256).max);\n\t\t}\n\t\tif (IERC20(asset).allowance(address(this), address(treasury)) == 0) {\n\t\t\tIERC20(asset).forceApprove(treasury, type(uint256).max);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Calculated needed WETH amount to be eligible.\n\t * @param locked usd value\n\t * @param required usd value\n\t **/\n\tfunction _calcWethAmount(uint256 locked, uint256 required) internal view returns (uint256 wethAmount) {\n\t\tif (locked < required) {\n\t\t\tuint256 deltaUsdValue = required - locked; //decimals === 8\n\t\t\tuint256 wethPrice = aaveOracle.getAssetPrice(address(weth));\n\t\t\tuint8 priceDecimal = IChainlinkAggregator(aaveOracle.getSourceOfAsset(address(weth))).decimals();\n\t\t\twethAmount = (deltaUsdValue * (10 ** 18) * (10 ** priceDecimal)) / wethPrice / (10 ** 8);\n\t\t\twethAmount = wethAmount + ((wethAmount * ZAP_MARGIN_ESTIMATION) / 100);\n\t\t}\n\t}\n}\n"
    },
    "contracts/prime/accessories/Multicall3.sol": {
      "content": "// https://github.com/mds1/multicall/blob/70f5a3ef3bace87e3b273f7de21a132cd77bfabd/src/Multicall3.sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\n/// @title Multicall3\n/// @notice Aggregate results from multiple function calls\n/// @dev Multicall & Multicall2 backwards-compatible\n/// @dev Aggregate methods are marked `payable` to save 24 gas per call\n/// @author Michael Elliot <mike@makerdao.com>\n/// @author Joshua Levine <joshua@makerdao.com>\n/// @author Nick Johnson <arachnid@notdot.net>\n/// @author Andreas Bigger <andreas@nascent.xyz>\n/// @author Matt Solomon <matt@mattsolomon.dev>\ncontract Multicall3 {\n\tstruct Call {\n\t\taddress target;\n\t\tbytes callData;\n\t}\n\n\tstruct Call3 {\n\t\taddress target;\n\t\tbool allowFailure;\n\t\tbytes callData;\n\t}\n\n\tstruct Call3Value {\n\t\taddress target;\n\t\tbool allowFailure;\n\t\tuint256 value;\n\t\tbytes callData;\n\t}\n\n\tstruct Result {\n\t\tbool success;\n\t\tbytes returnData;\n\t}\n\n\t/// @notice Backwards-compatible call aggregation with Multicall\n\t/// @param calls An array of Call structs\n\t/// @return blockNumber The block number where the calls were executed\n\t/// @return returnData An array of bytes containing the responses\n\tfunction aggregate(Call[] calldata calls) public payable returns (uint256 blockNumber, bytes[] memory returnData) {\n\t\tblockNumber = block.number;\n\t\tuint256 length = calls.length;\n\t\treturnData = new bytes[](length);\n\t\tCall calldata call;\n\t\tfor (uint256 i = 0; i < length;) {\n\t\t\tbool success;\n\t\t\tcall = calls[i];\n\t\t\t(success, returnData[i]) = call.target.call(call.callData);\n\t\t\trequire(success, \"Multicall3: call failed\");\n\t\t\tunchecked { ++i; }\n\t\t}\n\t}\n\n\t/// @notice Backwards-compatible with Multicall2\n\t/// @notice Aggregate calls without requiring success\n\t/// @param requireSuccess If true, require all calls to succeed\n\t/// @param calls An array of Call structs\n\t/// @return returnData An array of Result structs\n\tfunction tryAggregate(bool requireSuccess, Call[] calldata calls) public payable returns (Result[] memory returnData) {\n\t\tuint256 length = calls.length;\n\t\treturnData = new Result[](length);\n\t\tCall calldata call;\n\t\tfor (uint256 i = 0; i < length;) {\n\t\t\tResult memory result = returnData[i];\n\t\t\tcall = calls[i];\n\t\t\t(result.success, result.returnData) = call.target.call(call.callData);\n\t\t\tif (requireSuccess) require(result.success, \"Multicall3: call failed\");\n\t\t\tunchecked { ++i; }\n\t\t}\n\t}\n\n\t/// @notice Backwards-compatible with Multicall2\n\t/// @notice Aggregate calls and allow failures using tryAggregate\n\t/// @param calls An array of Call structs\n\t/// @return blockNumber The block number where the calls were executed\n\t/// @return blockHash The hash of the block where the calls were executed\n\t/// @return returnData An array of Result structs\n\tfunction tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls) public payable returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {\n\t\tblockNumber = block.number;\n\t\tblockHash = blockhash(block.number);\n\t\treturnData = tryAggregate(requireSuccess, calls);\n\t}\n\n\t/// @notice Backwards-compatible with Multicall2\n\t/// @notice Aggregate calls and allow failures using tryAggregate\n\t/// @param calls An array of Call structs\n\t/// @return blockNumber The block number where the calls were executed\n\t/// @return blockHash The hash of the block where the calls were executed\n\t/// @return returnData An array of Result structs\n\tfunction blockAndAggregate(Call[] calldata calls) public payable returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {\n\t\t(blockNumber, blockHash, returnData) = tryBlockAndAggregate(true, calls);\n\t}\n\n\t/// @notice Aggregate calls, ensuring each returns success if required\n\t/// @param calls An array of Call3 structs\n\t/// @return returnData An array of Result structs\n\tfunction aggregate3(Call3[] calldata calls) public payable returns (Result[] memory returnData) {\n\t\tuint256 length = calls.length;\n\t\treturnData = new Result[](length);\n\t\tCall3 calldata calli;\n\t\tfor (uint256 i = 0; i < length;) {\n\t\t\tResult memory result = returnData[i];\n\t\t\tcalli = calls[i];\n\t\t\t(result.success, result.returnData) = calli.target.call(calli.callData);\n\t\t\tassembly {\n\t\t\t// Revert if the call fails and failure is not allowed\n\t\t\t// `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\n\t\t\t\tif iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\n\t\t\t\t// set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\n\t\t\t\t\tmstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\t\t\t\t// set data offset\n\t\t\t\t\tmstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n\t\t\t\t// set length of revert string\n\t\t\t\t\tmstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\n\t\t\t\t// set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\n\t\t\t\t\tmstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\n\t\t\t\t\trevert(0x00, 0x64)\n\t\t\t\t}\n\t\t\t}\n\t\t\tunchecked { ++i; }\n\t\t}\n\t}\n\n\t/// @notice Aggregate calls with a msg value\n\t/// @notice Reverts if msg.value is less than the sum of the call values\n\t/// @param calls An array of Call3Value structs\n\t/// @return returnData An array of Result structs\n\tfunction aggregate3Value(Call3Value[] calldata calls) public payable returns (Result[] memory returnData) {\n\t\tuint256 valAccumulator;\n\t\tuint256 length = calls.length;\n\t\treturnData = new Result[](length);\n\t\tCall3Value calldata calli;\n\t\tfor (uint256 i = 0; i < length;) {\n\t\t\tResult memory result = returnData[i];\n\t\t\tcalli = calls[i];\n\t\t\tuint256 val = calli.value;\n\t\t\t// Humanity will be a Type V Kardashev Civilization before this overflows - andreas\n\t\t\t// ~ 10^25 Wei in existence << ~ 10^76 size uint fits in a uint256\n\t\t\tunchecked { valAccumulator += val; }\n\t\t\t(result.success, result.returnData) = calli.target.call{value: val}(calli.callData);\n\t\t\tassembly {\n\t\t\t// Revert if the call fails and failure is not allowed\n\t\t\t// `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\n\t\t\t\tif iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\n\t\t\t\t// set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\n\t\t\t\t\tmstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\t\t\t\t// set data offset\n\t\t\t\t\tmstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n\t\t\t\t// set length of revert string\n\t\t\t\t\tmstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\n\t\t\t\t// set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\n\t\t\t\t\tmstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\n\t\t\t\t\trevert(0x00, 0x84)\n\t\t\t\t}\n\t\t\t}\n\t\t\tunchecked { ++i; }\n\t\t}\n\t\t// Finally, make sure the msg.value = SUM(call[0...i].value)\n\t\trequire(msg.value == valAccumulator, \"Multicall3: value mismatch\");\n\t}\n\n\t/// @notice Returns the block hash for the given block number\n\t/// @param blockNumber The block number\n\tfunction getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\n\t\tblockHash = blockhash(blockNumber);\n\t}\n\n\t/// @notice Returns the block number\n\tfunction getBlockNumber() public view returns (uint256 blockNumber) {\n\t\tblockNumber = block.number;\n\t}\n\n\t/// @notice Returns the block coinbase\n\tfunction getCurrentBlockCoinbase() public view returns (address coinbase) {\n\t\tcoinbase = block.coinbase;\n\t}\n\n\t/// @notice Returns the block difficulty\n\tfunction getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\n\t\tdifficulty = block.difficulty;\n\t}\n\n\t/// @notice Returns the block gas limit\n\tfunction getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\n\t\tgaslimit = block.gaslimit;\n\t}\n\n\t/// @notice Returns the block timestamp\n\tfunction getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\n\t\ttimestamp = block.timestamp;\n\t}\n\n\t/// @notice Returns the (ETH) balance of a given address\n\tfunction getEthBalance(address addr) public view returns (uint256 balance) {\n\t\tbalance = addr.balance;\n\t}\n\n\t/// @notice Returns the block hash of the last block\n\tfunction getLastBlockHash() public view returns (bytes32 blockHash) {\n\t\tunchecked {\n\t\t\tblockHash = blockhash(block.number - 1);\n\t\t}\n\t}\n\n\t/// @notice Gets the base fee of the given block\n\t/// @notice Can revert if the BASEFEE opcode is not implemented by the given chain\n\tfunction getBasefee() public view returns (uint256 basefee) {\n\t\tbasefee = block.basefee;\n\t}\n\n\t/// @notice Returns the chain id\n\tfunction getChainId() public view returns (uint256 chainid) {\n\t\tchainid = block.chainid;\n\t}\n}\n"
    },
    "contracts/prime/accessories/StargateBorrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {TransferHelper} from \"../libraries/TransferHelper.sol\";\nimport {IStargateRouter} from \"../../interfaces/IStargateRouter.sol\";\nimport {IRouterETH} from \"../../interfaces/IRouterETH.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\nimport {IWETH} from \"../../interfaces/IWETH.sol\";\n\n/*\n    Chain Ids\n        Ethereum: 101\n        BSC: 102\n        Avalanche: 106\n        Polygon: 109\n        Arbitrum: 110\n        Optimism: 111\n        Fantom: 112\n        Swimmer: 114\n        DFK: 115\n        Harmony: 116\n        Moonbeam: 126\n\n    Pool Ids\n        Ethereum\n            USDC: 1\n            USDT: 2\n            ETH: 13\n        BSC\n            USDT: 2\n            BUSD: 5\n        Avalanche\n            USDC: 1\n            USDT: 2\n        Polygon\n            USDC: 1\n            USDT: 2\n        Arbitrum\n            USDC: 1\n            USDT: 2\n            ETH: 13\n        Optimism\n            USDC: 1\n            ETH: 13\n        Fantom\n            USDC: 1\n */\n\n/// @title Borrow gate via stargate\n/// @author Prime\ncontract StargateBorrow is OwnableUpgradeable {\n\tusing SafeERC20 for IERC20;\n\n\t/// @notice FEE ratio DIVISOR\n\tuint256 public constant FEE_PERCENT_DIVISOR = 10000;\n\n\t// MAX slippage that cannot be exceeded when setting slippage variable\n\tuint256 public constant MAX_SLIPPAGE = 80;\n\n\t// ETH address\n\taddress private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n\t// Max reasonable fee, 1%\n\tuint256 public constant MAX_REASONABLE_FEE = 100;\n\n\t/// @notice Stargate Router\n\tIStargateRouter public router;\n\n\t/// @notice Stargate Router ETH\n\tIRouterETH public routerETH;\n\n\t/// @notice Lending Pool address\n\tILendingPool public lendingPool;\n\n\t// Weth address\n\tIWETH internal weth;\n\n\t// Referral code\n\tuint16 public constant REFERRAL_CODE = 0;\n\n\t/// @notice asset => poolId; at the moment, pool IDs for USDC and USDT are the same accross all chains\n\tmapping(address => uint256) public poolIdPerChain;\n\n\t/// @notice DAO wallet\n\taddress public daoTreasury;\n\n\t/// @notice Cross chain borrow fee ratio\n\tuint256 public xChainBorrowFeePercent;\n\n\t/// @notice Max slippage allowed for SG bridge swaps\n\t/// 99 = 1%\n\tuint256 public maxSlippage;\n\n\t/// @notice Emitted when DAO address is updated\n\tevent DAOTreasuryUpdated(address indexed _daoTreasury);\n\n\t/// @notice Emitted when fee info is updated\n\tevent XChainBorrowFeePercentUpdated(uint256 indexed percent);\n\n\t/// @notice Emited when pool ids of assets are updated\n\tevent PoolIDsUpdated(address[] assets, uint256[] poolIDs);\n\n\terror InvalidRatio();\n\n\terror AddressZero();\n\n\t/// @notice Emitted when new slippage is set too high\n\terror SlippageSetToHigh();\n\n\terror LengthMismatch();\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Constructor\n\t * @param _router Stargate Router address\n\t * @param _routerETH Stargate Router for ETH\n\t * @param _lendingPool Lending pool\n\t * @param _weth WETH address\n\t * @param _treasury Treasury address\n\t * @param _xChainBorrowFeePercent Cross chain borrow fee ratio\n\t */\n\tfunction initialize(\n\t\tIStargateRouter _router,\n\t\tIRouterETH _routerETH,\n\t\tILendingPool _lendingPool,\n\t\tIWETH _weth,\n\t\taddress _treasury,\n\t\tuint256 _xChainBorrowFeePercent,\n\t\tuint256 _maxSlippage\n\t) external initializer {\n\t\tif (address(_router) == address(0)) revert AddressZero();\n\t\tif (address(_lendingPool) == address(0)) revert AddressZero();\n\t\tif (address(_weth) == address(0)) revert AddressZero();\n\t\tif (_treasury == address(0)) revert AddressZero();\n\t\tif (_xChainBorrowFeePercent > MAX_REASONABLE_FEE) revert AddressZero();\n\t\tif (_maxSlippage < MAX_SLIPPAGE) revert SlippageSetToHigh();\n\n\t\trouter = _router;\n\t\trouterETH = _routerETH;\n\t\tlendingPool = _lendingPool;\n\t\tdaoTreasury = _treasury;\n\t\txChainBorrowFeePercent = _xChainBorrowFeePercent;\n\t\tweth = _weth;\n\t\tmaxSlippage = _maxSlippage;\n\t\t__Ownable_init();\n\t}\n\n\treceive() external payable {}\n\n\t/**\n\t * @notice Set DAO Treasury.\n\t * @param _daoTreasury DAO Treasury address.\n\t */\n\tfunction setDAOTreasury(address _daoTreasury) external onlyOwner {\n\t\tif (_daoTreasury == address(0)) revert AddressZero();\n\t\tdaoTreasury = _daoTreasury;\n\t\temit DAOTreasuryUpdated(_daoTreasury);\n\t}\n\n\t/**\n\t * @notice Set Cross Chain Borrow Fee Percent.\n\t * @param percent Fee ratio.\n\t */\n\tfunction setXChainBorrowFeePercent(uint256 percent) external onlyOwner {\n\t\tif (percent > MAX_REASONABLE_FEE) revert InvalidRatio();\n\t\txChainBorrowFeePercent = percent;\n\t\temit XChainBorrowFeePercentUpdated(percent);\n\t}\n\n\t/**\n\t * @notice Set pool ids of assets.\n\t * @param assets array.\n\t * @param poolIDs array.\n\t */\n\tfunction setPoolIDs(address[] calldata assets, uint256[] calldata poolIDs) external onlyOwner {\n\t\tuint256 length = assets.length;\n\t\tif (length != poolIDs.length) revert LengthMismatch();\n\t\tfor (uint256 i = 0; i < length; ) {\n\t\t\tpoolIdPerChain[assets[i]] = poolIDs[i];\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\temit PoolIDsUpdated(assets, poolIDs);\n\t}\n\n\t/**\n\t * @notice Set max slippage allowed for StarGate bridge Swaps.\n\t * @param _maxSlippage Max slippage allowed.\n\t */\n\tfunction setMaxSlippage(uint256 _maxSlippage) external onlyOwner {\n\t\tif (_maxSlippage < MAX_SLIPPAGE) revert SlippageSetToHigh();\n\t\tmaxSlippage = _maxSlippage;\n\t}\n\n\t/**\n\t * @notice Get Cross Chain Borrow Fee amount.\n\t * @param amount Fee cost.\n\t * @return Fee amount for cross chain borrow\n\t */\n\tfunction getXChainBorrowFeeAmount(uint256 amount) public view returns (uint256) {\n\t\tuint256 feeAmount = (amount * (xChainBorrowFeePercent)) / (FEE_PERCENT_DIVISOR);\n\t\treturn feeAmount;\n\t}\n\n\t/**\n\t * @notice Quote LZ swap fee\n\t * @dev Call Router.sol method to get the value for swap()\n\t * @param _dstChainId dest LZ chain id\n\t * @param _functionType function type\n\t * @param _toAddress address\n\t * @param _transferAndCallPayload payload to call after transfer\n\t * @param _lzTxParams transaction params\n\t * @return Message Fee\n\t * @return amount of wei in source gas token\n\t */\n\tfunction quoteLayerZeroSwapFee(\n\t\tuint16 _dstChainId,\n\t\tuint8 _functionType,\n\t\tbytes calldata _toAddress,\n\t\tbytes calldata _transferAndCallPayload,\n\t\tIStargateRouter.lzTxObj memory _lzTxParams\n\t) external view returns (uint256, uint256) {\n\t\treturn router.quoteLayerZeroFee(_dstChainId, _functionType, _toAddress, _transferAndCallPayload, _lzTxParams);\n\t}\n\n\t/**\n\t * @dev Borrow asset for another chain\n\t * @param asset for loop\n\t * @param amount for the initial deposit\n\t * @param interestRateMode stable or variable borrow mode\n\t * @param dstChainId Destination chain id\n\t **/\n\tfunction borrow(address asset, uint256 amount, uint256 interestRateMode, uint16 dstChainId) external payable {\n\t\tif (address(asset) == ETH_ADDRESS && address(routerETH) != address(0)) {\n\t\t\t_borrowETH(amount, interestRateMode, dstChainId);\n\t\t} else {\n\t\t\tlendingPool.borrow(asset, amount, interestRateMode, REFERRAL_CODE, msg.sender);\n\t\t\tuint256 feeAmount = getXChainBorrowFeeAmount(amount);\n\t\t\tif (feeAmount > 0) {\n\t\t\t\tIERC20(asset).safeTransfer(daoTreasury, feeAmount);\n\t\t\t\tamount = amount - feeAmount;\n\t\t\t}\n\t\t\tIERC20(asset).forceApprove(address(router), amount);\n\t\t\trouter.swap{value: msg.value}(\n\t\t\t\tdstChainId, // dest chain id\n\t\t\t\tpoolIdPerChain[asset], // src chain pool id\n\t\t\t\tpoolIdPerChain[asset], // dst chain pool id\n\t\t\t\tpayable(msg.sender), // receive address\n\t\t\t\tamount, // transfer amount\n\t\t\t\t(amount * maxSlippage) / 100, // max slippage: 1%\n\t\t\t\tIStargateRouter.lzTxObj(0, 0, \"0x\"),\n\t\t\t\tabi.encodePacked(msg.sender),\n\t\t\t\tbytes(\"\")\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Borrow ETH\n\t * @param amount for the initial deposit\n\t * @param interestRateMode stable or variable borrow mode\n\t * @param dstChainId Destination chain id\n\t **/\n\tfunction _borrowETH(uint256 amount, uint256 interestRateMode, uint16 dstChainId) internal {\n\t\tlendingPool.borrow(address(weth), amount, interestRateMode, REFERRAL_CODE, msg.sender);\n\t\tweth.withdraw(amount);\n\t\tuint256 feeAmount = getXChainBorrowFeeAmount(amount);\n\t\tif (feeAmount > 0) {\n\t\t\tTransferHelper.safeTransferETH(daoTreasury, feeAmount);\n\t\t\tamount = amount - feeAmount;\n\t\t}\n\n\t\trouterETH.swapETH{value: amount + msg.value}(\n\t\t\tdstChainId, // dest chain id\n\t\t\tpayable(msg.sender), // receive address\n\t\t\tabi.encodePacked(msg.sender),\n\t\t\tamount, // transfer amount\n\t\t\t(amount * maxSlippage) / 100 // max slippage: 1%\n\t\t);\n\t}\n\n\t/**\n\t * @notice Allows owner to recover ETH locked in this contract.\n\t * @param to ETH receiver\n\t * @param value ETH amount\n\t */\n\tfunction withdrawLockedETH(address to, uint256 value) external onlyOwner {\n\t\tTransferHelper.safeTransferETH(to, value);\n\t}\n}"
    },
    "contracts/prime/eligibility/BountyManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {RecoverERC20} from \"../libraries/RecoverERC20.sol\";\nimport {IMFDPlus} from \"../../interfaces/IMultiFeeDistribution.sol\";\nimport {IChefIncentivesController} from \"../../interfaces/IChefIncentivesController.sol\";\nimport {IPriceProvider} from \"../../interfaces/IPriceProvider.sol\";\nimport {IEligibilityDataProvider} from \"../../interfaces/IEligibilityDataProvider.sol\";\nimport {ICompounder} from \"../../interfaces/ICompounder.sol\";\nimport {IBountyManager} from \"../../interfaces/IBountyManager.sol\";\n\n/// @title BountyManager Contract\n/// @author Prime Devs\ncontract BountyManager is Initializable, OwnableUpgradeable, PausableUpgradeable, RecoverERC20 {\n\tusing SafeERC20 for IERC20;\n\n\taddress public prnt;\n\taddress public weth;\n\taddress public mfd;\n\taddress public chef;\n\taddress public priceProvider;\n\taddress public eligibilityDataProvider;\n\taddress public compounder;\n\tuint256 public hunterShare;\n\tuint256 public baseBountyUsdTarget; // decimals 18\n\tuint256 public maxBaseBounty;\n\tuint256 public bountyCount;\n\tuint256 public minStakeAmount;\n\n\t/// @notice Ratio Divisor\n\tuint256 public constant RATIO_DIVISOR = 10000;\n\n\t/// @notice The users specified slippage value for auto-compounding will be used \n\tuint256 internal constant DEFAULT_USERS_SLIPPAGE = 0;\n\n\t// Array of available Bounty functions to run. See _getMfdBounty, _getChefBounty, etc.\n\tmapping(uint256 => function(address, bool) returns (address, uint256, bool)) private bounties;\n\n\tmapping(address => bool) public whitelist;\n\tbool public whitelistActive;\n\n\tmodifier isWhitelisted() {\n\t\tif (whitelistActive) {\n\t\t\tif (!whitelist[msg.sender] && msg.sender != address(this)) revert NotWhitelisted();\n\t\t}\n\t\t_;\n\t}\n\n\tevent MinStakeAmountUpdated(uint256 indexed _minStakeAmount);\n\tevent BaseBountyUsdTargetUpdated(uint256 indexed _newVal);\n\tevent HunterShareUpdated(uint256 indexed _newVal);\n\tevent MaxBaseBountyUpdated(uint256 indexed _newVal);\n\tevent BountiesSet();\n\tevent BountyReserveEmpty(uint256 indexed _bal);\n\tevent WhitelistUpdated(address indexed _user, bool indexed _isActive);\n\tevent WhitelistActiveChanged(bool indexed isActive);\n\n\terror AddressZero();\n\terror InvalidNumber();\n\terror QuoteFail();\n\terror Ineligible();\n\terror InvalidSlippage();\n\terror ActionTypeIndexOutOfBounds();\n\terror NotWhitelisted();\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Initialize\n\t * @param _prnt PRNT address\n\t * @param _weth WETH address\n\t * @param _mfd MFD, to send bounties as vesting PRNT to Hunter (user calling bounty)\n\t * @param _chef CIC, to query bounties for ineligible emissions\n\t * @param _priceProvider PriceProvider service, to get PRNT price for bounty quotes\n\t * @param _eligibilityDataProvider Eligibility data provider\n\t * @param _compounder Compounder address\n\t * @param _hunterShare % of reclaimed rewards to send to Hunter\n\t * @param _baseBountyUsdTarget Base Bounty is paid in PRNT, will scale to match this USD target value\n\t * @param _maxBaseBounty cap the scaling above\n\t */\n\tfunction initialize(\n\t\taddress _prnt,\n\t\taddress _weth,\n\t\taddress _mfd,\n\t\taddress _chef,\n\t\taddress _priceProvider,\n\t\taddress _eligibilityDataProvider,\n\t\taddress _compounder,\n\t\tuint256 _hunterShare,\n\t\tuint256 _baseBountyUsdTarget,\n\t\tuint256 _maxBaseBounty\n\t) external initializer {\n\t\tif (_prnt == address(0)) revert AddressZero();\n\t\tif (_weth == address(0)) revert AddressZero();\n\t\tif (_mfd == address(0)) revert AddressZero();\n\t\tif (_chef == address(0)) revert AddressZero();\n\t\tif (_priceProvider == address(0)) revert AddressZero();\n\t\tif (_eligibilityDataProvider == address(0)) revert AddressZero();\n\t\tif (_compounder == address(0)) revert AddressZero();\n\t\tif (_hunterShare > RATIO_DIVISOR) revert InvalidNumber();\n\t\tif (_baseBountyUsdTarget == 0) revert InvalidNumber();\n\t\tif (_maxBaseBounty == 0) revert InvalidNumber();\n\n\t\tprnt = _prnt;\n\t\tweth = _weth;\n\t\tmfd = _mfd;\n\t\tchef = _chef;\n\t\tpriceProvider = _priceProvider;\n\t\teligibilityDataProvider = _eligibilityDataProvider;\n\t\tcompounder = _compounder;\n\n\t\thunterShare = _hunterShare;\n\t\tbaseBountyUsdTarget = _baseBountyUsdTarget;\n\t\tmaxBaseBounty = _maxBaseBounty;\n\n\t\tbounties[1] = _getMfdBounty;\n\t\tbounties[2] = _getChefBounty;\n\t\tbounties[3] = _getAutoCompoundBounty;\n\t\tbountyCount = 3;\n\n\t\t__Ownable_init();\n\t\t__Pausable_init();\n\t}\n\n\t/**\n\t * @notice Given a user, return their bounty amount. uses staticcall to run same bounty aglo, but without execution\n\t * @param _user address\n\t * @return bounty amount of PRNT Hunter will recieve.\n\t * can be a fixed amt (Base Bounty) or dynamic amt based on rewards removed from target user during execution (ineligible revenue, autocompound fee)\n\t * @return actionType which of the 3 bounty types (above) to run.\n\t * _getAvailableBounty returns this based on priority (expired locks first, then inelig emissions, then autocompound)\n\t */\n\tfunction quote(address _user) public view returns (uint256 bounty, uint256 actionType) {\n\t\t(bool success, bytes memory data) = address(this).staticcall(\n\t\t\tabi.encodeCall(IBountyManager.executeBounty, (_user, false, 0))\n\t\t);\n\t\tif (!success) revert QuoteFail();\n\n\t\t(bounty, actionType) = abi.decode(data, (uint256, uint256));\n\t}\n\n\t/**\n\t * @notice Execute a bounty.\n\t * @param _user address\n\t * can be a fixed amt (Base Bounty) or dynamic amt based on rewards removed from target user during execution (ineligible revenue, autocompound fee)\n\t * @param _actionType which of the 3 bounty types (above) to run.\n\t * @return bounty in PRNT to be paid to Hunter (via vesting)\n\t * @return actionType which bounty ran\n\t */\n\tfunction claim(address _user, uint256 _actionType) public returns (uint256, uint256) {\n\t\treturn executeBounty(_user, true, _actionType);\n\t}\n\n\t/**\n\t * @notice Execute the most appropriate bounty on a user, check returned amount for slippage, calc amount going to Hunter, send to vesting.\n\t * @param _user address\n\t * @param _execute whether to execute this txn, or just quote what its execution would return\n\t * can be a fixed amt (Base Bounty) or dynamic amt based on rewards removed from target user during execution (ineligible revenue, autocompound fee)\n\t * @param _actionType which of the 3 bounty types (above) to run.\n\t * @return bounty in PRNT to be paid to Hunter (via vesting)\n\t * @return actionType which bounty ran\n\t */\n\tfunction executeBounty(\n\t\taddress _user,\n\t\tbool _execute,\n\t\tuint256 _actionType\n\t) public whenNotPaused isWhitelisted returns (uint256 bounty, uint256 actionType) {\n\t\tif (_execute && msg.sender != address(this)) {\n\t\t\tif (!_canBountyHunt(msg.sender)) revert Ineligible();\n\t\t}\n\t\tuint256 totalBounty;\n\t\tbool issueBaseBounty;\n\t\taddress incentivizer;\n\n\t\t(incentivizer, totalBounty, issueBaseBounty, actionType) = _getAvailableBounty(_user, _execute, _actionType);\n\t\tif (issueBaseBounty) {\n\t\t\tbounty = getBaseBounty();\n\t\t} else {\n\t\t\tif (totalBounty != 0) {\n\t\t\t\tbounty = (totalBounty * hunterShare) / RATIO_DIVISOR;\n\t\t\t}\n\t\t}\n\n\t\tif (_execute && bounty != 0) {\n\t\t\tif (!issueBaseBounty) {\n\t\t\t\tIERC20(prnt).safeTransferFrom(incentivizer, address(this), totalBounty);\n\t\t\t}\n\t\t\tbounty = _sendBounty(msg.sender, bounty);\n\t\t}\n\t}\n\n\tfunction _canBountyHunt(address _user) internal view returns (bool) {\n\t\t(, , uint256 lockedLP, , ) = IMFDPlus(mfd).lockedBalances(_user);\n\t\tbool isEmissionsEligible = IEligibilityDataProvider(eligibilityDataProvider).isEligibleForRewards(_user);\n\t\treturn lockedLP >= minDLPBalance() && isEmissionsEligible;\n\t}\n\n\t/**\n\t * @notice Given a user and actionType, execute that bounty on either CIC or MFD or Compounder.\n\t * @param _user address\n\t * @param _execute whether to execute this txn, or just quote what its execution would return\n\t * @param _actionTypeIndex, which of the 3 bounty types (above) to run.\n\t * @return incentivizer the contract that had a bounty operation performed for it.\n\t * Either CIC (to remove ineligible user from emission pool, or MFD to remove expired locks)\n\t * @return totalBounty raw amount of PRNT returned from Incentivizer. Hunter % will be deducted from this.\n\t * @return issueBaseBounty whether Incentivizer will pay bounty from its own PRNT reserve, or from this contracts PRNT reserve\n\t * @return actionType the action type index executed\n\t */\n\tfunction _getAvailableBounty(\n\t\taddress _user,\n\t\tbool _execute,\n\t\tuint256 _actionTypeIndex\n\t) internal returns (address incentivizer, uint256 totalBounty, bool issueBaseBounty, uint256 actionType) {\n\t\tif (_actionTypeIndex > bountyCount) revert ActionTypeIndexOutOfBounds();\n\t\tif (_actionTypeIndex != 0) {\n\t\t\t// execute bounty w/ given params\n\t\t\t(incentivizer, totalBounty, issueBaseBounty) = bounties[_actionTypeIndex](_user, _execute);\n\t\t\tactionType = _actionTypeIndex;\n\t\t} else {\n\t\t\tfor (uint256 i = 1; i <= bountyCount; ) {\n\t\t\t\t(incentivizer, totalBounty, issueBaseBounty) = bounties[i](_user, _execute);\n\t\t\t\tif (totalBounty != 0 || issueBaseBounty) {\n\t\t\t\t\tactionType = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tunchecked {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice call MFDPlus.claimBounty()\n\t * @param _user address\n\t * @param _execute whether to execute this txn, or just quote what its execution would return\n\t * @return incentivizer in this case MFD\n\t * @return totalBounty PRNT to pay for this _user's bounty execution\n\t * @return issueBaseBounty false when !autorelock because they will have rewards removed from their ineligible time after locks expired\n\t */\n\tfunction _getMfdBounty(\n\t\taddress _user,\n\t\tbool _execute\n\t) internal returns (address incentivizer, uint256, bool issueBaseBounty) {\n\t\ttry IMFDPlus(mfd).claimBounty(_user, _execute) returns (bool issueBaseBounty_) {\n\t\t\tissueBaseBounty = issueBaseBounty_;\n\t\t} catch {\n\t\t\tissueBaseBounty = false;\n\t\t}\n\t\tincentivizer = mfd;\n\t\treturn (incentivizer, 0, issueBaseBounty);\n\t}\n\n\t/**\n\t * @notice call CIC.claimBounty()\n\t * @param _user address\n\t * @param _execute whether to execute this txn, or just quote what its execution would return\n\t * @return incentivizer in this case CIC\n\t * @return totalBounty PRNT to pay for this _user's bounty execution\n\t * @return issueBaseBounty will be true\n\t */\n\tfunction _getChefBounty(\n\t\taddress _user,\n\t\tbool _execute\n\t) internal returns (address incentivizer, uint256, bool issueBaseBounty) {\n\t\tissueBaseBounty = IChefIncentivesController(chef).claimBounty(_user, _execute);\n\t\tincentivizer = chef;\n\t\treturn (incentivizer, 0, issueBaseBounty);\n\t}\n\n\t/**\n\t * @notice call Compounder.claimCompound(). compound pending rewards for _user into locked LP\n\t * @param _user address\n\t * @param _execute whether to execute this txn, or just quote what its execution would return\n\t * @return incentivizer is the Compounder\n\t * @return totalBounty PRNT to pay for this _user's bounty execution. paid from Autocompound fee\n\t * @return issueBaseBounty will be false, will vary based on autocompound fee\n\t */\n\tfunction _getAutoCompoundBounty(\n\t\taddress _user,\n\t\tbool _execute\n\t) internal returns (address incentivizer, uint256 totalBounty, bool issueBaseBounty) {\n\t\t(totalBounty) = ICompounder(compounder).claimCompound(_user, _execute, DEFAULT_USERS_SLIPPAGE);\n\t\tissueBaseBounty = false;\n\t\tincentivizer = compounder;\n\t}\n\n\t/**\n\t * @notice Vest a bounty in MFD for successful bounty by Hunter\n\t * @param _to Hunter address\n\t * @param _amount of PRNT\n\t * @return amt added to vesting\n\t */\n\tfunction _sendBounty(address _to, uint256 _amount) internal returns (uint256) {\n\t\tuint256 bountyReserve = IERC20(prnt).balanceOf(address(this));\n\t\tif (_amount > bountyReserve) {\n\t\t\tIERC20(prnt).safeTransfer(address(mfd), bountyReserve);\n\t\t\tIMFDPlus(mfd).vestTokens(_to, bountyReserve, true);\n\t\t\temit BountyReserveEmpty(bountyReserve);\n\t\t\t_pause();\n\t\t\treturn bountyReserve;\n\t\t} else {\n\t\t\tIERC20(prnt).safeTransfer(address(mfd), _amount);\n\t\t\tIMFDPlus(mfd).vestTokens(_to, _amount, true);\n\t\t\treturn _amount;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Return PRNT amount for Base Bounty.\n\t * Base Bounty used to incentivize operations that don't generate their own reward to pay to Hunter.\n\t * @return bounty in PRNT\n\t */\n\tfunction getBaseBounty() public view whenNotPaused returns (uint256) {\n\t\tuint256 prntPrice = IPriceProvider(priceProvider).getTokenPriceUsd();\n\t\tuint256 bounty = (baseBountyUsdTarget * 1e8) / prntPrice;\n\t\treturn bounty > maxBaseBounty ? maxBaseBounty : bounty;\n\t}\n\n\t/**\n\t * @notice Minimum locked lp balance\n\t */\n\tfunction minDLPBalance() public view returns (uint256 min) {\n\t\tuint256 lpTokenPrice = IPriceProvider(priceProvider).getLpTokenPriceUsd();\n\t\tmin = (minStakeAmount * 1e8) / lpTokenPrice;\n\t}\n\n\t/**\n\t * @notice Sets minimum stake amount.\n\t * @dev Only owner can call this function.\n\t * @param _minStakeAmount Minimum stake amount\n\t */\n\tfunction setMinStakeAmount(uint256 _minStakeAmount) external onlyOwner {\n\t\tminStakeAmount = _minStakeAmount;\n\t\temit MinStakeAmountUpdated(_minStakeAmount);\n\t}\n\n\t/**\n\t * @notice Sets target price of base bounty.\n\t * @dev Only owner can call this function.\n\t * @param _newVal New USD value\n\t */\n\tfunction setBaseBountyUsdTarget(uint256 _newVal) external onlyOwner {\n\t\tbaseBountyUsdTarget = _newVal;\n\t\temit BaseBountyUsdTargetUpdated(_newVal);\n\t}\n\n\t/**\n\t * @notice Sets hunter's share ratio.\n\t * @dev Only owner can call this function.\n\t * @param _newVal New hunter share ratio\n\t */\n\tfunction setHunterShare(uint256 _newVal) external onlyOwner {\n\t\tif (_newVal > RATIO_DIVISOR) revert InvalidNumber();\n\t\thunterShare = _newVal;\n\t\temit HunterShareUpdated(_newVal);\n\t}\n\n\t/**\n\t * @notice Updates maximum base bounty.\n\t * @dev Only owner can call this function.\n\t * @param _newVal Maximum base bounty\n\t */\n\tfunction setMaxBaseBounty(uint256 _newVal) external onlyOwner {\n\t\tmaxBaseBounty = _newVal;\n\t\temit MaxBaseBountyUpdated(_newVal);\n\t}\n\n\t/**\n\t * @notice Set bounty operations.\n\t * @dev Only owner can call this function.\n\t */\n\tfunction setBounties() external onlyOwner {\n\t\tbounties[1] = _getMfdBounty;\n\t\tbounties[2] = _getChefBounty;\n\t\tbounties[3] = _getAutoCompoundBounty;\n\t\temit BountiesSet();\n\t}\n\n\t/**\n\t * @notice Recover ERC20 tokens from the contract.\n\t * @param tokenAddress Token address to recover\n\t * @param tokenAmount Amount to recover\n\t */\n\tfunction recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n\t\t_recoverERC20(tokenAddress, tokenAmount);\n\t}\n\n\t/**\n\t * @notice Add new address to whitelist.\n\t * @param user address\n\t * @param status for whitelist\n\t */\n\tfunction addAddressToWL(address user, bool status) external onlyOwner {\n\t\twhitelist[user] = status;\n\t\temit WhitelistUpdated(user, status);\n\t}\n\n\t/**\n\t * @notice Update whitelist active status.\n\t * @param status New whitelist status\n\t */\n\tfunction changeWL(bool status) external onlyOwner {\n\t\twhitelistActive = status;\n\t\temit WhitelistActiveChanged(status);\n\t}\n\n\t/**\n\t * @notice Pause the bounty operations.\n\t */\n\tfunction pause() public onlyOwner {\n\t\t_pause();\n\t}\n\n\t/**\n\t * @notice Unpause the bounty operations.\n\t */\n\tfunction unpause() public onlyOwner {\n\t\t_unpause();\n\t}\n}\n"
    },
    "contracts/prime/eligibility/EligibilityDataProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\nimport {IMultiFeeDistribution} from \"../../interfaces/IMultiFeeDistribution.sol\";\nimport {IChefIncentivesController} from \"../../interfaces/IChefIncentivesController.sol\";\nimport {IPriceProvider} from \"../../interfaces/IPriceProvider.sol\";\nimport {IMiddleFeeDistribution} from \"../../interfaces/IMiddleFeeDistribution.sol\";\nimport {LockedBalance, Balances} from \"../../interfaces/LockedBalance.sol\";\n\n/// @title Eligible Deposit Provider\n/// @author Prime Labs\ncontract EligibilityDataProvider is OwnableUpgradeable {\n\t/********************** Common Info ***********************/\n\n\t/// @notice RATIO BASE equal to 100%\n\tuint256 public constant RATIO_DIVISOR = 10000;\n\n\t/// @notice Initial required ratio of TVL to get reward; in bips\n\tuint256 public constant INITIAL_REQUIRED_DEPOSIT_RATIO = 500;\n\n\t/// @notice Initial ratio of the required price to still allow without disqualification; in bips\n\tuint256 public constant INITIAL_PRICE_TOLERANCE_RATIO = 9000;\n\n\t/// @notice Minimum required ratio of TVL to get reward; in bips\n\tuint256 public constant MIN_PRICE_TOLERANCE_RATIO = 8000;\n\n\t/// @notice Address of Lending Pool\n\tILendingPool public lendingPool;\n\n\t/// @notice Address of CIC\n\tIChefIncentivesController public chef;\n\n\t/// @notice Address of Middle fee distribution\n\tIMiddleFeeDistribution public middleFeeDistribution;\n\n\t/// @notice PRNT + LP price provider\n\tIPriceProvider public priceProvider;\n\n\t/// @notice Required ratio of TVL to get reward; in bips\n\tuint256 public requiredDepositRatio;\n\n\t/// @notice Ratio of the required price to still allow without disqualification; in bips\n\tuint256 public priceToleranceRatio;\n\n\t/// @notice PRNT-ETH LP token\n\taddress public lpToken;\n\n\t/********************** Eligible info ***********************/\n\n\t/// @notice Last eligible status of the user\n\tmapping(address => bool) public lastEligibleStatus;\n\n\t/// @notice Disqualified time of the user\n\tmapping(address => uint256) public disqualifiedTime;\n\n\t/********************** Events ***********************/\n\n\t/// @notice Emitted when CIC is set\n\tevent ChefIncentivesControllerUpdated(IChefIncentivesController indexed _chef);\n\n\t/// @notice Emitted when LP token is set\n\tevent LPTokenUpdated(address indexed _lpToken);\n\n\t/// @notice Emitted when required TVL ratio is updated\n\tevent RequiredDepositRatioUpdated(uint256 indexed requiredDepositRatio);\n\n\t/// @notice Emitted when price tolerance ratio is updated\n\tevent PriceToleranceRatioUpdated(uint256 indexed priceToleranceRatio);\n\n\t/// @notice Emitted when DQ time is set\n\tevent DqTimeUpdated(address indexed _user, uint256 _time);\n\n\t/********************** Errors ***********************/\n\terror AddressZero();\n\n\terror LPTokenSet();\n\n\terror InvalidRatio();\n\n\terror OnlyCIC();\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Constructor\n\t * @param _lendingPool Address of lending pool.\n\t * @param _middleFeeDistribution MiddleFeeDistribution address.\n\t * @param _priceProvider PriceProvider address.\n\t */\n\tfunction initialize(\n\t\tILendingPool _lendingPool,\n\t\tIMiddleFeeDistribution _middleFeeDistribution,\n\t\tIPriceProvider _priceProvider\n\t) public initializer {\n\t\tif (address(_lendingPool) == address(0)) revert AddressZero();\n\t\tif (address(_middleFeeDistribution) == address(0)) revert AddressZero();\n\t\tif (address(_priceProvider) == address(0)) revert AddressZero();\n\n\t\tlendingPool = _lendingPool;\n\t\tmiddleFeeDistribution = _middleFeeDistribution;\n\t\tpriceProvider = _priceProvider;\n\t\trequiredDepositRatio = INITIAL_REQUIRED_DEPOSIT_RATIO;\n\t\tpriceToleranceRatio = INITIAL_PRICE_TOLERANCE_RATIO;\n\t\t__Ownable_init();\n\t}\n\n\t/********************** Setters ***********************/\n\n\t/**\n\t * @notice Set CIC\n\t * @param _chef address.\n\t */\n\tfunction setChefIncentivesController(IChefIncentivesController _chef) external onlyOwner {\n\t\tif (address(_chef) == address(0)) revert AddressZero();\n\t\tchef = _chef;\n\t\temit ChefIncentivesControllerUpdated(_chef);\n\t}\n\n\t/**\n\t * @notice Set LP token\n\t */\n\tfunction setLPToken(address _lpToken) external onlyOwner {\n\t\tif (_lpToken == address(0)) revert AddressZero();\n\t\tif (lpToken != address(0)) revert LPTokenSet();\n\t\tlpToken = _lpToken;\n\n\t\temit LPTokenUpdated(_lpToken);\n\t}\n\n\t/**\n\t * @notice Sets required tvl ratio. Can only be called by the owner.\n\t * @param _requiredDepositRatio Ratio in bips.\n\t */\n\tfunction setRequiredDepositRatio(uint256 _requiredDepositRatio) external onlyOwner {\n\t\tif (_requiredDepositRatio > RATIO_DIVISOR) revert InvalidRatio();\n\t\trequiredDepositRatio = _requiredDepositRatio;\n\n\t\temit RequiredDepositRatioUpdated(_requiredDepositRatio);\n\t}\n\n\t/**\n\t * @notice Sets price tolerance ratio. Can only be called by the owner.\n\t * @param _priceToleranceRatio Ratio in bips.\n\t */\n\tfunction setPriceToleranceRatio(uint256 _priceToleranceRatio) external onlyOwner {\n\t\tif (_priceToleranceRatio < MIN_PRICE_TOLERANCE_RATIO || _priceToleranceRatio > RATIO_DIVISOR)\n\t\t\trevert InvalidRatio();\n\t\tpriceToleranceRatio = _priceToleranceRatio;\n\n\t\temit PriceToleranceRatioUpdated(_priceToleranceRatio);\n\t}\n\n\t/**\n\t * @notice Sets DQ time of the user\n\t * @dev Only callable by CIC\n\t * @param _user's address\n\t * @param _time for DQ\n\t */\n\tfunction setDqTime(address _user, uint256 _time) external {\n\t\tif (msg.sender != address(chef)) revert OnlyCIC();\n\t\tdisqualifiedTime[_user] = _time;\n\n\t\temit DqTimeUpdated(_user, _time);\n\t}\n\n\t/********************** View functions ***********************/\n\n\t/**\n\t * @notice Returns locked PRNT and LP token value in eth\n\t * @param user's address\n\t */\n\tfunction lockedUsdValue(address user) public view returns (uint256) {\n\t\tIMultiFeeDistribution multiFeeDistribution = IMultiFeeDistribution(\n\t\t\tmiddleFeeDistribution.getMultiFeeDistributionAddress()\n\t\t);\n\t\tBalances memory _balances = multiFeeDistribution.getBalances(user);\n\t\treturn _lockedUsdValue(_balances.locked);\n\t}\n\n\t/**\n\t * @notice Returns USD value required to be locked\n\t * @param user's address\n\t * @return required USD value.\n\t */\n\tfunction requiredUsdValue(address user) public view returns (uint256 required) {\n\t\t(uint256 totalCollateralUSD, , , , , ) = lendingPool.getUserAccountData(user);\n\t\trequired = (totalCollateralUSD * requiredDepositRatio) / RATIO_DIVISOR;\n\t}\n\n\t/**\n\t * @notice Returns if the user is eligible to receive rewards\n\t * @param _user's address\n\t */\n\tfunction isEligibleForRewards(address _user) public view returns (bool) {\n\t\tuint256 lockedValue = lockedUsdValue(_user);\n\t\tuint256 requiredValue = (requiredUsdValue(_user) * priceToleranceRatio) / RATIO_DIVISOR;\n\t\treturn requiredValue != 0 && lockedValue >= requiredValue;\n\t}\n\n\t/**\n\t * @notice Returns DQ time of the user\n\t * @param _user's address\n\t */\n\tfunction getDqTime(address _user) public view returns (uint256) {\n\t\treturn disqualifiedTime[_user];\n\t}\n\n\t/**\n\t * @notice Returns last eligible time of the user\n\t * @dev If user is still eligible, it will return future time\n\t *  CAUTION: this function only works perfect when the array\n\t *  is ordered by lock time. This is assured when _stake happens.\n\t * @param user's address\n\t * @return lastEligibleTimestamp of the user. Returns 0 if user is not eligible.\n\t */\n\tfunction lastEligibleTime(address user) public view returns (uint256 lastEligibleTimestamp) {\n\t\tif (!isEligibleForRewards(user)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 requiredValue = requiredUsdValue(user);\n\n\t\tIMultiFeeDistribution multiFeeDistribution = IMultiFeeDistribution(\n\t\t\tmiddleFeeDistribution.getMultiFeeDistributionAddress()\n\t\t);\n\t\tLockedBalance[] memory lpLockData = multiFeeDistribution.lockInfo(user);\n\n\t\tuint256 lockedLP;\n\t\tfor (uint256 i = lpLockData.length; i > 0; ) {\n\t\t\tLockedBalance memory currentLockData = lpLockData[i - 1];\n\t\t\tlockedLP += currentLockData.amount;\n\n\t\t\tif (_lockedUsdValue(lockedLP) >= requiredValue) {\n\t\t\t\treturn currentLockData.unlockTime;\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/********************** Operate functions ***********************/\n\t/**\n\t * @notice Refresh token amount for eligibility\n\t * @param user The address of the user\n\t * @return currentEligibility The current eligibility status of the user\n\t */\n\tfunction refresh(address user) external returns (bool currentEligibility) {\n\t\tif (msg.sender != address(chef)) revert OnlyCIC();\n\t\tif (user == address(0)) revert AddressZero();\n\n\t\tupdatePrice();\n\t\tcurrentEligibility = isEligibleForRewards(user);\n\t\tif (currentEligibility && disqualifiedTime[user] != 0) {\n\t\t\tdisqualifiedTime[user] = 0;\n\t\t}\n\t\tlastEligibleStatus[user] = currentEligibility;\n\t}\n\n\t/**\n\t * @notice Update token price\n\t */\n\tfunction updatePrice() public {\n\t\tpriceProvider.update();\n\t}\n\n\t/********************** Internal functions ***********************/\n\n\t/**\n\t * @notice Returns locked PRNT and LP token value in USD\n\t * @param lockedLP is locked lp amount\n\t */\n\tfunction _lockedUsdValue(uint256 lockedLP) internal view returns (uint256) {\n\t\tuint256 lpPrice = priceProvider.getLpTokenPriceUsd();\n\t\treturn (lockedLP * lpPrice) / 10 ** 18;\n\t}\n}\n"
    },
    "contracts/prime/libraries/AddressPagination.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\n/// @title Library for pagination of address array\n/// @author Prime Devs\nlibrary AddressPagination {\n\t/**\n\t * @notice Paginate address array.\n\t * @param array storage slot of the array to paginate.\n\t * @param page number\n\t * @param limit per page\n\t * @return result address array.\n\t */\n\tfunction paginate(\n\t\taddress[] storage array,\n\t\tuint256 page,\n\t\tuint256 limit\n\t) internal view returns (address[] memory result) {\n\t\tresult = new address[](limit);\n\t\tuint256 length = array.length;\n\t\tfor (uint256 i = 0; i < limit; ) {\n\t\t\tif (page * limit + i >= length) {\n\t\t\t\tresult[i] = address(0);\n\t\t\t} else {\n\t\t\t\tresult[i] = array[page * limit + i];\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "contracts/prime/libraries/balancer-reentrancy/VaultReentrancyLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Modified by Prime Capital to accommodate different interface files\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol\";\nimport {IVault} from \"../../../interfaces/balancer/IWeightedPoolFactory.sol\";\n\nlibrary VaultReentrancyLib {\n\t/**\n\t * @dev Ensure we are not in a Vault context when this function is called, by attempting a no-op internal\n\t * balance operation. If we are already in a Vault transaction (e.g., a swap, join, or exit), the Vault's\n\t * reentrancy protection will cause this function to revert.\n\t *\n\t * The exact function call doesn't really matter: we're just trying to trigger the Vault reentrancy check\n\t * (and not hurt anything in case it works). An empty operation array with no specific operation at all works\n\t * for that purpose, and is also the least expensive in terms of gas and bytecode size.\n\t *\n\t * Call this at the top of any function that can cause a state change in a pool and is either public itself,\n\t * or called by a public function *outside* a Vault operation (e.g., join, exit, or swap).\n\t *\n\t * If this is *not* called in functions that are vulnerable to the read-only reentrancy issue described\n\t * here (https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345), those functions are unsafe,\n\t * and subject to manipulation that may result in loss of funds.\n\t */\n\tfunction ensureNotInVaultContext(IVault vault) internal view {\n\t\t// Perform the following operation to trigger the Vault's reentrancy guard:\n\t\t//\n\t\t// IVault.UserBalanceOp[] memory noop = new IVault.UserBalanceOp[](0);\n\t\t// _vault.manageUserBalance(noop);\n\t\t//\n\t\t// However, use a static call so that it can be a view function (even though the function is non-view).\n\t\t// This allows the library to be used more widely, as some functions that need to be protected might be\n\t\t// view.\n\t\t//\n\t\t// This staticcall always reverts, but we need to make sure it doesn't fail due to a re-entrancy attack.\n\t\t// Staticcalls consume all gas forwarded to them on a revert caused by storage modification.\n\t\t// By default, almost the entire available gas is forwarded to the staticcall,\n\t\t// causing the entire call to revert with an 'out of gas' error.\n\t\t//\n\t\t// We set the gas limit to 10k for the staticcall to\n\t\t// avoid wasting gas when it reverts due to storage modification.\n\t\t// `manageUserBalance` is a non-reentrant function in the Vault, so calling it invokes `_enterNonReentrant`\n\t\t// in the `ReentrancyGuard` contract, reproduced here:\n\t\t//\n\t\t//    function _enterNonReentrant() private {\n\t\t//        // If the Vault is actually being reentered, it will revert in the first line, at the `_require` that\n\t\t//        // checks the reentrancy flag, with \"BAL#400\" (corresponding to Errors.REENTRANCY) in the revertData.\n\t\t//        // The full revertData will be: `abi.encodeWithSignature(\"Error(string)\", \"BAL#400\")`.\n\t\t//        _require(_status != _ENTERED, Errors.REENTRANCY);\n\t\t//\n\t\t//        // If the Vault is not being reentered, the check above will pass: but it will *still* revert,\n\t\t//        // because the next line attempts to modify storage during a staticcall. However, this type of\n\t\t//        // failure results in empty revertData.\n\t\t//        _status = _ENTERED;\n\t\t//    }\n\t\t//\n\t\t// So based on this analysis, there are only two possible revertData values: empty, or abi.encoded BAL#400.\n\t\t//\n\t\t// It is of course much more bytecode and gas efficient to check for zero-length revertData than to compare it\n\t\t// to the encoded REENTRANCY revertData.\n\t\t//\n\t\t// While it should be impossible for the call to fail in any other way (especially since it reverts before\n\t\t// `manageUserBalance` even gets called), any other error would generate non-zero revertData, so checking for\n\t\t// empty data guards against this case too.\n\n\t\t(, bytes memory revertData) = address(vault).staticcall{gas: 10_000}(\n\t\t\tabi.encodeWithSelector(vault.manageUserBalance.selector, 0)\n\t\t);\n\n\t\t_require(revertData.length == 0, Errors.REENTRANCY);\n\t}\n}\n"
    },
    "contracts/prime/libraries/RecoverERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title RecoverERC20 contract\n/// @author Prime Devs\n/// @dev All function calls are currently implemented without side effects\ncontract RecoverERC20 {\n\tusing SafeERC20 for IERC20;\n\n\t/// @notice Emitted when ERC20 token is recovered\n\tevent Recovered(address indexed token, uint256 amount);\n\n\t/**\n\t * @notice Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n\t */\n\tfunction _recoverERC20(address tokenAddress, uint256 tokenAmount) internal {\n\t\tIERC20(tokenAddress).safeTransfer(msg.sender, tokenAmount);\n\t\temit Recovered(tokenAddress, tokenAmount);\n\t}\n}\n"
    },
    "contracts/prime/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\n// helper methods from uniswap, for sending ETH that do not consistently return true/false\n// we modified the original code\nlibrary TransferHelper {\n\terror ETHTransferFailed();\n\n\t/**\n\t * @notice Transfer ETH\n\t * @param to address\n\t * @param value ETH amount\n\t */\n\tfunction safeTransferETH(address to, uint256 value) internal {\n\t\t(bool success, ) = to.call{value: value}(new bytes(0));\n\t\tif (!success) revert ETHTransferFailed();\n\t}\n}\n"
    },
    "contracts/prime/libraries/UniV2Helper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IUniswapV2Router02} from \"../../interfaces/uniswap/IUniswapV2Router02.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nlibrary UniV2Helper {\n    using SafeERC20 for IERC20;\n\n    /**\n\t * @notice Swap the privded amount of _inTokens for _outTokens\n\t * @param _router the AMM router that will be used to perform the price query\n\t * @param _inToken the address of the token that will be sold\n\t * @param _outToken the address of the token that will be bought\n\t * @param _inAmount amount of _inTokens to be sold\n\t * @return amount of _outTokens received\n\t */\n    function _swap(address _router, address _inToken, address _outToken, uint256 _inAmount) internal returns(uint256){\n        address[] memory path = new address[](2);\n        path[0] = _inToken;\n        path[1] = _outToken;\n        IERC20(_inToken).forceApprove(_router, _inAmount);\n        return IUniswapV2Router02(_router).swapExactTokensForTokens(\n            _inAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        )[1];\n    } \n\n    /**\n\t * @notice Query the amount of _outTokens received for a given amount of _inTokens\n\t * @param _router the AMM router that will be used to perform the price query\n\t * @param _inToken the address of the token that will be sold\n\t * @param _outToken the address of the token that will be bought\n\t * @param _inAmount amount of _inTokens to be sold\n\t * @return amount of _outTokens received\n\t */\n    function _quoteSwap(address _router, address _inToken, address _outToken, uint256 _inAmount) internal view returns(uint256){\n        address[] memory path = new address[](2);\n        path[0] = _inToken;\n        path[1] = _outToken;\n        return IUniswapV2Router02(_router).getAmountsOut(_inAmount, path)[1];\n    } \n}"
    },
    "contracts/prime/oracles/BaseOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IChainlinkAggregator} from \"../../interfaces/IChainlinkAggregator.sol\";\nimport {IBaseOracle} from \"../../interfaces/IBaseOracle.sol\";\n\n/// @title BaseOracle Contract\n/// @author Prime\nabstract contract BaseOracle is Initializable, OwnableUpgradeable {\n\t/// @notice Token for price\n\taddress public token;\n\n\t/// @notice Chainlink price feed for ETH\n\taddress public ethChainlinkFeed;\n\n\t/// @notice Enable/Disable fallback\n\tbool public fallbackEnabled;\n\n\t/// @notice Oracle to be used as a fallback\n\tIBaseOracle public fallbackOracle;\n\n\terror AddressZero();\n\n\terror FallbackNotSet();\n\n\t/********************** Events ***********************/\n\tevent FallbackOracleUpdated(address indexed _fallback);\n\n\tevent FallbackOracleEnabled(bool indexed _enabled);\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Initializer\n\t * @param _token Token address.\n\t * @param _ethChainlinkFeed chainlink price feed for ETH.\n\t */\n\tfunction __BaseOracle_init(address _token, address _ethChainlinkFeed) internal onlyInitializing {\n\t\t__Ownable_init();\n\t\ttoken = _token;\n\t\tethChainlinkFeed = _ethChainlinkFeed;\n\t}\n\n\t/**\n\t * @notice Sets fallback oracle\n\t * @param _fallback Oracle address for fallback.\n\t */\n\tfunction setFallback(address _fallback) external onlyOwner {\n\t\tif (_fallback == address(0)) revert AddressZero();\n\t\tfallbackOracle = IBaseOracle(_fallback);\n\t\temit FallbackOracleUpdated(_fallback);\n\t}\n\n\t/**\n\t * @notice Enable/Disable use of fallback oracle\n\t * @param _enabled Boolean value.\n\t */\n\tfunction enableFallback(bool _enabled) external onlyOwner {\n\t\tif (address(fallbackOracle) == (address(0))) revert FallbackNotSet();\n\t\tfallbackEnabled = _enabled;\n\t\temit FallbackOracleEnabled(_enabled);\n\t}\n\n\t/**\n\t * @notice Returns USD price in quote token.\n\t * @dev supports 18 decimal token\n\t * @return price of token in decimal 8\n\t */\n\tfunction latestAnswer() public view returns (uint256 price) {\n\t\t// returns decimals 8\n\t\tuint256 priceInEth = latestAnswerInEth();\n\n\t\t// returns decimals 8\n\t\tuint256 ethPrice = uint256(IChainlinkAggregator(ethChainlinkFeed).latestAnswer());\n\n\t\tprice = (priceInEth * ethPrice) / (10 ** 8);\n\t}\n\n\t/**\n\t * @notice Returns price in ETH\n\t * @dev supports 18 decimal token\n\t * @return price of token in decimal 8.\n\t */\n\tfunction latestAnswerInEth() public view returns (uint256 price) {\n\t\tif (!fallbackEnabled) {\n\t\t\tprice = consult();\n\t\t} else {\n\t\t\tprice = fallbackOracle.consult();\n\t\t}\n\t\tprice = price / (10 ** 10);\n\t}\n\n\t/**\n\t * @dev returns possibility for update\n\t */\n\tfunction canUpdate() public view virtual returns (bool) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * @dev implement in child contract\n\t */\n\tfunction consult() public view virtual returns (uint256) {}\n\n\t// Allowing for storage vars to be added/shifted above without effecting any inheriting contracts/proxies\n\tuint256[50] private __gap;\n}"
    },
    "contracts/prime/oracles/chainlink/BaseChainlinkAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {AggregatorV3Interface} from \"../../../interfaces/AggregatorV3Interface.sol\";\n\n/// @title ChainlinkAdapter Contract\n/// @author Prime\ncontract BaseChainlinkAdapter is AggregatorV3Interface {\n\t/// @notice Token price feed\n\tAggregatorV3Interface public chainlinkFeed;\n\tuint256 public immutable heartbeat;\n\t/// @notice How late since heartbeat before a price reverts\n\tuint256 public constant HEART_BEAT_TOLERANCE = 300;\n\n\terror AddressZero();\n\terror RoundNotComplete();\n\terror StalePrice();\n\terror InvalidPrice();\n\n\t/**\n\t * @notice constructor\n\t * @param _chainlinkFeed Chainlink price feed for token.\n\t * @param _heartbeat heartbeat for feed\n\t */\n\tconstructor(address _chainlinkFeed, uint256 _heartbeat) {\n\t\tif (_chainlinkFeed == address(0)) revert AddressZero();\n\t\tchainlinkFeed = AggregatorV3Interface(_chainlinkFeed);\n\t\theartbeat = _heartbeat;\n\t}\n\n\t/**\n\t * @notice Returns USD price in quote token.\n\t * @dev supports 18 decimal token\n\t * @return price of token in decimal 8\n\t */\n\tfunction latestAnswer() external view virtual returns (uint256 price) {}\n\n\tfunction validate(int256 _answer, uint256 _updatedAt) public view {\n\t\tif (_updatedAt == 0) revert RoundNotComplete();\n\t\tif (heartbeat > 0 && block.timestamp - _updatedAt >= heartbeat + HEART_BEAT_TOLERANCE) revert StalePrice();\n\t\tif (_answer <= 0) revert InvalidPrice();\n\t}\n\n\t/**\n\t * @notice Returns version of chainlink price feed for token\n\t */\n\tfunction version() external view returns (uint256) {\n\t\treturn chainlinkFeed.version();\n\t}\n\n\t/**\n\t * @notice Returns decimals of chainlink price feed for token\n\t */\n\tfunction decimals() external view returns (uint8) {\n\t\treturn chainlinkFeed.decimals();\n\t}\n\n\t/**\n\t * @notice Returns description of chainlink price feed for token\n\t */\n\tfunction description() external view returns (string memory) {\n\t\treturn chainlinkFeed.description();\n\t}\n\n\t/**\n\t * @notice Get data about a round\n\t * @param _roundId the requested round ID\n\t * @return roundId is the round ID from the aggregator for which the data was retrieved.\n\t * @return answer is the answer for the given round\n\t * @return startedAt is the timestamp when the round was started.\n\t * @return updatedAt is the timestamp when the round last was updated.\n\t * @return answeredInRound is the round ID of the round in which the answer was computed.\n\t */\n\tfunction getRoundData(\n\t\tuint80 _roundId\n\t)\n\t\texternal\n\t\tview\n\t\treturns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n\t{\n\t\t(roundId, answer, startedAt, updatedAt, answeredInRound) = chainlinkFeed.getRoundData(_roundId);\n\t}\n\n\t/**\n\t * @notice Returns data of latest round\n\t * @return roundId is the round ID from the aggregator for which the data was retrieved.\n\t * @return answer is the answer for the given round\n\t * @return startedAt is the timestamp when the round was started.\n\t * @return updatedAt is the timestamp when the round last was updated.\n\t * @return answeredInRound is the round ID of the round in which the answer was computed.\n\t */\n\tfunction latestRoundData()\n\t\tpublic\n\t\tview\n\t\treturns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n\t{\n\t\t(roundId, answer, startedAt, updatedAt, answeredInRound) = chainlinkFeed.latestRoundData();\n\t}\n}\n"
    },
    "contracts/prime/oracles/chainlink/UnvalidatedChainlinkAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {AggregatorV3Interface} from \"../../../interfaces/AggregatorV3Interface.sol\";\nimport {BaseChainlinkAdapter} from \"./BaseChainlinkAdapter.sol\";\n\n/// @title ChainlinkAdapter Contract\n/// @author Prime\ncontract UnvalidatedChainlinkAdapter is BaseChainlinkAdapter {\n\tconstructor(address _chainlinkFeed, uint256 _heartbeat) BaseChainlinkAdapter(_chainlinkFeed, _heartbeat) {}\n\n\t/**\n\t * @notice Returns USD price in quote token.\n\t * @dev supports 18 decimal token\n\t * @return price of token in decimal 8\n\t */\n\tfunction latestAnswer() external view override returns (uint256 price) {\n\t\t(, int256 answer, , , ) = chainlinkFeed.latestRoundData();\n\t\treturn uint256(answer);\n\t}\n}\n"
    },
    "contracts/prime/oracles/chainlink/ValidatedChainlinkAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {AggregatorV3Interface} from \"../../../interfaces/AggregatorV3Interface.sol\";\nimport {BaseChainlinkAdapter} from \"./BaseChainlinkAdapter.sol\";\n\n/// @title ChainlinkAdapter Contract\n/// @author Prime\ncontract ValidatedChainlinkAdapter is BaseChainlinkAdapter {\n\tconstructor(address _chainlinkFeed, uint256 _heartbeat) BaseChainlinkAdapter(_chainlinkFeed, _heartbeat) {}\n\n\t/**\n\t * @notice Returns USD price in quote token.\n\t * @dev supports 18 decimal token\n\t * @return price of token in decimal 8\n\t */\n\tfunction latestAnswer() external view override returns (uint256 price) {\n\t\t(, int256 answer, , uint256 updatedAt, ) = chainlinkFeed.latestRoundData();\n\t\tvalidate(answer, updatedAt);\n\t\treturn uint256(answer);\n\t}\n}\n"
    },
    "contracts/prime/oracles/chainlink/ValidatedChainlinkAdapterWithSequencer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {AggregatorV3Interface} from \"../../../interfaces/AggregatorV3Interface.sol\";\nimport {BaseChainlinkAdapter} from \"./BaseChainlinkAdapter.sol\";\n\n/// @title ChainlinkAdapter Contract\n/// @author Prime\ncontract ValidatedChainlinkAdapterWithSequencer is BaseChainlinkAdapter {\n\tAggregatorV3Interface public constant ARBITRUM_SEQUENCER_UPTIME_FEED =\n\t\tAggregatorV3Interface(0xFdB631F5EE196F0ed6FAa767959853A9F217697D);\n\tuint256 public constant GRACE_PERIOD_TIME = 3600;\n\tuint256 public constant UPDATE_PERIOD = 86400;\n\n\terror SequencerDown();\n\terror GracePeriodNotOver();\n\n\tconstructor(address _chainlinkFeed, uint256 _heartbeat) BaseChainlinkAdapter(_chainlinkFeed, _heartbeat) {}\n\n\t/**\n\t * @notice Check the sequencer status for the Arbitrum mainnet.\n\t */\n\tfunction checkSequencerFeed() public view {\n\t\t(, int256 answer, uint256 startedAt, , ) = ARBITRUM_SEQUENCER_UPTIME_FEED.latestRoundData();\n\t\t// Answer == 0: Sequencer is up\n\t\t// Answer == 1: Sequencer is down\n\t\tbool isSequencerUp = answer == 0;\n\t\tif (!isSequencerUp) {\n\t\t\trevert SequencerDown();\n\t\t}\n\n\t\t// Make sure the grace period has passed after the sequencer is back up.\n\t\tuint256 timeSinceUp = block.timestamp - startedAt;\n\t\tif (timeSinceUp <= GRACE_PERIOD_TIME) {\n\t\t\trevert GracePeriodNotOver();\n\t\t}\n\t}\n\n\t/**\n\t * @notice Returns USD price in quote token.\n\t * @dev supports 18 decimal token\n\t * @return price of token in decimal 8\n\t */\n\tfunction latestAnswer() external view override returns (uint256 price) {\n\t\tcheckSequencerFeed();\n\t\t(, int256 answer, , uint256 updatedAt, ) = chainlinkFeed.latestRoundData();\n\t\tvalidate(answer, updatedAt);\n\t\treturn uint256(answer);\n\t}\n}\n"
    },
    "contracts/prime/oracles/PriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\nimport {IBaseOracle} from \"../../interfaces/IBaseOracle.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IPoolHelper} from \"../../interfaces/IPoolHelper.sol\";\nimport {IChainlinkAdapter} from \"../../interfaces/IChainlinkAdapter.sol\";\n\n/// @title PriceProvider Contract\n/// @author Prime\ncontract PriceProvider is Initializable, OwnableUpgradeable {\n\t/// @notice Chainlink aggregator for USD price of base token\n\tIChainlinkAdapter public baseAssetChainlinkAdapter;\n\n\t/// @notice Pool helper contract - Uniswap/Balancer\n\tIPoolHelper public poolHelper;\n\n\t/// @notice Selected PRNT Oracle\n\tIBaseOracle public oracle;\n\n\tbool private usePool;\n\n\terror AddressZero();\n\n\terror InvalidOracle();\n\n\t/********************** Events ***********************/\n\n\tevent OracleUpdated(address indexed _newOracle);\n\n\tevent PoolHelperUpdated(address indexed _poolHelper);\n\n\tevent AggregatorUpdated(address indexed _baseTokenPriceInUsdProxyAggregator);\n\n\tevent UsePoolUpdated(bool indexed _usePool);\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Initializer\n\t * @param _baseAssetChainlinkAdapter Chainlink aggregator for USD price of base token\n\t * @param _poolHelper Pool helper contract - Uniswap/Balancer\n\t */\n\tfunction initialize(IChainlinkAdapter _baseAssetChainlinkAdapter, IPoolHelper _poolHelper) public initializer {\n\t\tif (address(_baseAssetChainlinkAdapter) == (address(0))) revert AddressZero();\n\t\tif (address(_poolHelper) == (address(0))) revert AddressZero();\n\t\t__Ownable_init();\n\n\t\tpoolHelper = _poolHelper;\n\t\tbaseAssetChainlinkAdapter = IChainlinkAdapter(_baseAssetChainlinkAdapter);\n\t\tusePool = true;\n\t}\n\n\t/**\n\t * @notice Update oracles.\n\t */\n\tfunction update() public {\n\t\tif (address(oracle) != address(0) && oracle.canUpdate()) {\n\t\t\toracle.update();\n\t\t}\n\t}\n\n\t/**\n\t * @notice Returns the latest price in eth.\n\t */\n\tfunction getTokenPrice() public view returns (uint256 priceInEth) {\n\t\tif (usePool) {\n\t\t\t// use sparingly, TWAP/CL otherwise\n\t\t\tpriceInEth = poolHelper.getPrice();\n\t\t} else {\n\t\t\tpriceInEth = oracle.latestAnswerInEth();\n\t\t}\n\t}\n\n\t/**\n\t * @notice Returns the latest price in USD.\n\t */\n\tfunction getTokenPriceUsd() public view returns (uint256 price) {\n\t\t// use sparingly, TWAP/CL otherwise\n\t\tif (usePool) {\n\t\t\tuint256 ethPrice = baseAssetChainlinkAdapter.latestAnswer();\n\t\t\tuint256 priceInEth = poolHelper.getPrice();\n\t\t\tprice = (priceInEth * uint256(ethPrice)) / (10 ** 8);\n\t\t} else {\n\t\t\tprice = oracle.latestAnswer();\n\t\t}\n\t}\n\n\t/**\n\t * @notice Returns lp token price in ETH.\n\t */\n\tfunction getLpTokenPrice() public view returns (uint256) {\n\t\t// decis 8\n\t\tuint256 prntPriceInEth = getTokenPrice();\n\t\treturn poolHelper.getLpPrice(prntPriceInEth);\n\t}\n\n\t/**\n\t * @notice Returns lp token price in USD.\n\t */\n\tfunction getLpTokenPriceUsd() public view returns (uint256 price) {\n\t\t// decimals 8\n\t\tuint256 lpPriceInEth = getLpTokenPrice();\n\t\t// decimals 8\n\t\tuint256 ethPrice = baseAssetChainlinkAdapter.latestAnswer();\n\t\tprice = (lpPriceInEth * uint256(ethPrice)) / (10 ** 8);\n\t}\n\n\t/**\n\t * @notice Returns lp token address.\n\t */\n\tfunction getLpTokenAddress() public view returns (address) {\n\t\treturn poolHelper.lpTokenAddr();\n\t}\n\n\t/**\n\t * @notice Sets new oracle.\n\t */\n\tfunction setOracle(address _newOracle) external onlyOwner {\n\t\tif (_newOracle == address(0)) revert AddressZero();\n\t\toracle = IBaseOracle(_newOracle);\n\t\temit OracleUpdated(_newOracle);\n\t}\n\n\t/**\n\t * @notice Sets pool helper contract.\n\t */\n\tfunction setPoolHelper(address _poolHelper) external onlyOwner {\n\t\tpoolHelper = IPoolHelper(_poolHelper);\n\t\tif (getLpTokenPrice() == 0) revert InvalidOracle();\n\t\temit PoolHelperUpdated(_poolHelper);\n\t}\n\n\t/**\n\t * @notice Sets base token price aggregator.\n\t */\n\tfunction setAggregator(address _baseAssetChainlinkAdapter) external onlyOwner {\n\t\tbaseAssetChainlinkAdapter = IChainlinkAdapter(_baseAssetChainlinkAdapter);\n\t\tif (getLpTokenPriceUsd() == 0) revert InvalidOracle();\n\t\temit AggregatorUpdated(_baseAssetChainlinkAdapter);\n\t}\n\n\t/**\n\t * @notice Sets option to use pool.\n\t */\n\tfunction setUsePool(bool _usePool) external onlyOwner {\n\t\tusePool = _usePool;\n\t\temit UsePoolUpdated(_usePool);\n\t}\n\n\t/**\n\t * @notice Returns decimals of price.\n\t */\n\tfunction decimals() public pure returns (uint256) {\n\t\treturn 8;\n\t}\n}\n"
    },
    "contracts/prime/oracles/PrimeChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {OwnableUpgradeable} from \"../../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\nimport {IChainlinkAdapter} from \"../../interfaces/IChainlinkAdapter.sol\";\nimport {IBaseOracle} from \"../../interfaces/IBaseOracle.sol\";\n\n/// @title PrimeChainlinkOracle Contract\n/// @author Prime\ncontract PrimeChainlinkOracle is IBaseOracle, OwnableUpgradeable {\n\t/// @notice Eth price feed\n\tIChainlinkAdapter public ethChainlinkAdapter;\n\t/// @notice Token price feed\n\tIChainlinkAdapter public prntChainlinkAdapter;\n\n\terror AddressZero();\n\n\t/**\n\t * @notice Initializer\n\t * @param _ethChainlinkAdapter Chainlink adapter for ETH.\n\t * @param _prntChainlinkAdapter Chainlink price feed for PRNT.\n\t */\n\tfunction initialize(address _ethChainlinkAdapter, address _prntChainlinkAdapter) external initializer {\n\t\tif (_ethChainlinkAdapter == address(0)) revert AddressZero();\n\t\tif (_prntChainlinkAdapter == address(0)) revert AddressZero();\n\t\tethChainlinkAdapter = IChainlinkAdapter(_ethChainlinkAdapter);\n\t\tprntChainlinkAdapter = IChainlinkAdapter(_prntChainlinkAdapter);\n\t\t__Ownable_init();\n\t}\n\n\t/**\n\t * @notice Returns USD price in quote token.\n\t * @dev supports 18 decimal token\n\t * @return price of token in decimal 8\n\t */\n\tfunction latestAnswer() public view returns (uint256 price) {\n\t\t// Chainlink param validations happens inside here\n\t\tprice = prntChainlinkAdapter.latestAnswer();\n\t}\n\n\t/**\n\t * @notice Returns price in ETH\n\t * @dev supports 18 decimal token\n\t * @return price of token in decimal 8.\n\t */\n\tfunction latestAnswerInEth() public view returns (uint256 price) {\n\t\tuint256 prntPrice = prntChainlinkAdapter.latestAnswer();\n\t\tuint256 ethPrice = ethChainlinkAdapter.latestAnswer();\n\t\tprice = (prntPrice * (10 ** 8)) / ethPrice;\n\t}\n\n\t/**\n\t * @dev Check if update() can be called instead of wasting gas calling it.\n\t */\n\tfunction canUpdate() public pure returns (bool) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * @dev this function only exists so that the contract is compatible with the IBaseOracle Interface\n\t */\n\tfunction update() public {}\n\n\t/**\n\t * @notice Returns current price.\n\t */\n\tfunction consult() public view returns (uint256 price) {\n\t\tprice = latestAnswer();\n\t}\n}\n"
    },
    "contracts/prime/oracles/UniV2TwapOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {BaseOracle} from \"./BaseOracle.sol\";\nimport {FixedPoint} from \"../../dependencies/uniswap/contracts/FixedPoint.sol\";\nimport {UniswapV2OracleLibrary, IUniswapV2Pair} from \"../../dependencies/uniswap/contracts/UniswapV2OracleLibrary.sol\";\n\n/// @title UniV2TwapOracle Contract\n/// @author Prime team\n/// @dev Fixed window oracle that recomputes the average price for the entire period once every period\n/// Note that the price average is only guaranteed to be over at least 1 period, but may be over a longer period\ncontract UniV2TwapOracle is BaseOracle {\n\tusing FixedPoint for *;\n\n\t/// @notice TWAP period\n\tuint256 public period;\n\n\t/// @notice Used for being able to consult past the period end\n\tuint256 public consultLeniency;\n\n\t/// @notice If false, consult() will fail if the TWAP is stale\n\tbool public allowStaleConsults;\n\n\t/// @notice Uniswap pair contract\n\tIUniswapV2Pair public pair;\n\n\t/// @notice First token of the pair\n\taddress public token0;\n\n\t/// @notice Second token of the pair\n\taddress public token1;\n\n\t/// @notice First token of the pair\n\tuint256 public price0CumulativeLast;\n\n\t/// @notice First token of the pair\n\tuint256 public price1CumulativeLast;\n\n\t/// @notice Last updated timestamp\n\tuint32 public blockTimestampLast;\n\n\t/// @notice Average price of token0\n\tFixedPoint.uq112x112 public price0Average;\n\n\t/// @notice Average price of token1\n\tFixedPoint.uq112x112 public price1Average;\n\n\t/// @notice Minimum TWAP time period\n\tuint256 public constant PERIOD_MIN = 10;\n\n\terror InvalidToken();\n\n\terror NoReserves();\n\n\terror PeriodBelowMin();\n\n\terror PeriodNotElapsed();\n\n\terror PriceIsStale();\n\n\t/********************** Events ***********************/\n\n\tevent PeriodUpdated(uint256 indexed _period);\n\n\tevent ConsultLeniencyUpdated(uint256 indexed _consultLeniency);\n\n\tevent AllowStaleConsultsUpdated(bool indexed _allowStaleConsults);\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Initializer\n\t * @param _pair Uniswap pair contract\n\t * @param _prnt PRNT token address.\n\t * @param _ethChainlinkFeed Chainlink price feed for ETH.\n\t * @param _period TWAP period.\n\t * @param _consultLeniency Used for being able to consult past the period end.\n\t * @param _allowStaleConsults Enable/Disable stale.\n\t */\n\tfunction initialize(\n\t\taddress _pair,\n\t\taddress _prnt,\n\t\taddress _ethChainlinkFeed,\n\t\tuint256 _period,\n\t\tuint256 _consultLeniency,\n\t\tbool _allowStaleConsults\n\t) external initializer {\n\t\tif (_pair == address(0)) revert AddressZero();\n\t\tif (_prnt == address(0)) revert AddressZero();\n\t\tif (_ethChainlinkFeed == address(0)) revert AddressZero();\n\n\t\tpair = IUniswapV2Pair(_pair);\n\t\ttoken0 = pair.token0();\n\t\ttoken1 = pair.token1();\n\n\t\tprice0CumulativeLast = pair.price0CumulativeLast(); // Fetch the current accumulated price value (1 / 0)\n\t\tprice1CumulativeLast = pair.price1CumulativeLast(); // Fetch the current accumulated price value (0 / 1)\n\t\tuint112 reserve0;\n\t\tuint112 reserve1;\n\t\t(reserve0, reserve1, blockTimestampLast) = pair.getReserves();\n\n\t\tif (reserve0 == 0 || reserve1 == 0) revert NoReserves(); // Ensure that there's liquidity in the pair\n\t\tif (_period < PERIOD_MIN) revert PeriodBelowMin(); // Ensure period has a min time\n\n\t\tperiod = _period;\n\t\tconsultLeniency = _consultLeniency;\n\t\tallowStaleConsults = _allowStaleConsults;\n\n\t\t__BaseOracle_init(_prnt, _ethChainlinkFeed);\n\t}\n\n\t/**\n\t * @notice Sets new period.\n\t * @param _period TWAP period.\n\t */\n\tfunction setPeriod(uint256 _period) external onlyOwner {\n\t\tif (_period < PERIOD_MIN) revert PeriodBelowMin(); // Ensure period has a min time\n\t\tperiod = _period;\n\t\temit PeriodUpdated(_period);\n\t}\n\n\t/**\n\t * @notice Sets new consult leniency.\n\t * @param _consultLeniency new value.\n\t */\n\tfunction setConsultLeniency(uint256 _consultLeniency) external onlyOwner {\n\t\tconsultLeniency = _consultLeniency;\n\t\temit ConsultLeniencyUpdated(_consultLeniency);\n\t}\n\n\t/**\n\t * @notice Sets stale consult option.\n\t * @param _allowStaleConsults new value.\n\t */\n\tfunction setAllowStaleConsults(bool _allowStaleConsults) external onlyOwner {\n\t\tallowStaleConsults = _allowStaleConsults;\n\t\temit AllowStaleConsultsUpdated(_allowStaleConsults);\n\t}\n\n\t/**\n\t * @dev Check if update() can be called instead of wasting gas calling it.\n\t */\n\tfunction canUpdate() public view override returns (bool) {\n\t\tuint32 blockTimestamp = UniswapV2OracleLibrary.currentBlockTimestamp();\n\t\tuint32 timeElapsed;\n\t\tunchecked {\n\t\t\ttimeElapsed = blockTimestamp - blockTimestampLast; // Overflow is desired\n\t\t}\n\t\treturn (timeElapsed >= period);\n\t}\n\n\t/**\n\t * @notice Updates price\n\t */\n\tfunction update() external {\n\t\t(uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary\n\t\t\t.currentCumulativePrices(address(pair));\n\t\tuint32 timeElapsed;\n\t\tunchecked {\n\t\t\ttimeElapsed = blockTimestamp - blockTimestampLast; // Overflow is desired\n\t\t}\n\n\t\t// Ensure that at least one full period has passed since the last update\n\t\tif (timeElapsed < period) revert PeriodNotElapsed();\n\n\t\t// Overflow is desired, casting never truncates\n\t\t// Cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n\t\tunchecked {\n\t\t\tprice0Average = FixedPoint.uq112x112(uint224((price0Cumulative - price0CumulativeLast) / timeElapsed));\n\t\t\tprice1Average = FixedPoint.uq112x112(uint224((price1Cumulative - price1CumulativeLast) / timeElapsed));\n\t\t\tprice0CumulativeLast = price0Cumulative;\n\t\t\tprice1CumulativeLast = price1Cumulative;\n\t\t\tblockTimestampLast = blockTimestamp;\n\t\t}\n\t}\n\n\t/**\n\t * @dev This will always return 0 before update has been called successfully for the first time.\n\t */\n\tfunction _consult(address _token, uint256 _amountIn) internal view returns (uint256 amountOut) {\n\t\tuint32 blockTimestamp = UniswapV2OracleLibrary.currentBlockTimestamp();\n\t\tuint32 timeElapsed;\n\t\tunchecked {\n\t\t\ttimeElapsed = blockTimestamp - blockTimestampLast; // Overflow is desired\n\t\t}\n\n\t\t// Ensure that the price is not stale\n\t\tif ((timeElapsed >= (period + consultLeniency)) && !allowStaleConsults) revert PriceIsStale();\n\n\t\tif (_token == token0) {\n\t\t\tamountOut = price0Average.mul(_amountIn).decode144();\n\t\t} else {\n\t\t\tif (_token != token1) revert InvalidToken();\n\t\t\tamountOut = price1Average.mul(_amountIn).decode144();\n\t\t}\n\t}\n\n\t/**\n\t * @notice Returns current price.\n\t */\n\tfunction consult() public view override returns (uint256) {\n\t\tuint8 decimals = IERC20Metadata(token).decimals();\n\t\treturn _consult(token, 10 ** decimals);\n\t}\n}"
    },
    "contracts/prime/oracles/UniV3TwapOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {BaseOracle} from \"./BaseOracle.sol\";\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {OracleLibrary} from \"@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol\";\n\n/// @title UniV3TwapOracle Contract\n/// @author Prime\ncontract UniV3TwapOracle is BaseOracle {\n\t/// @notice Uniswap V3 pool address\n\tIUniswapV3Pool public pool;\n\n\t/// @notice First token of the pair\n\tIERC20Metadata public token0;\n\n\t/// @notice Second token of the pair\n\tIERC20Metadata public token1;\n\n\t/// @notice Decimal of token0\n\tuint8 public decimals0;\n\n\t/// @notice Decimal of token1\n\tuint8 public decimals1;\n\n\t/// @notice TWAP lookback period\n\tuint32 public lookbackSecs;\n\n\t/// @notice Can flip the order of the pricing\n\tbool public priceInToken0;\n\n\t/********************** Events ***********************/\n\n\tevent ObservationCardinalityIncreased(uint16 indexed numCardinals);\n\n\tevent TWAPLookbackSecUpdated(uint32 indexed _secs);\n\n\tevent TokenForPricingToggled();\n\n\terror InvalidLoopbackSecs();\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Initializer\n\t * @param _pair Uniswap pair contract\n\t * @param _prnt PRNT token address.\n\t * @param _ethChainlinkFeed Chainlink price feed for ETH.\n\t */\n\tfunction initialize(\n\t\taddress _pair,\n\t\taddress _prnt,\n\t\taddress _ethChainlinkFeed,\n\t\tuint32 _lookbackSecs\n\t) external initializer {\n\t\tif (_pair == address(0)) revert AddressZero();\n\t\tif (_prnt == address(0)) revert AddressZero();\n\t\tif (_ethChainlinkFeed == address(0)) revert AddressZero();\n\t\tif (_lookbackSecs == 0) revert InvalidLoopbackSecs();\n\n\t\tpool = IUniswapV3Pool(_pair);\n\t\ttoken0 = IERC20Metadata(pool.token0());\n\t\ttoken1 = IERC20Metadata(pool.token1());\n\n\t\tdecimals0 = token0.decimals();\n\t\tdecimals1 = token1.decimals();\n\n\t\tlookbackSecs = _lookbackSecs;\n\n\t\tpriceInToken0 = false;\n\t\t__BaseOracle_init(_prnt, _ethChainlinkFeed);\n\t}\n\n\t/* ========== RESTRICTED FUNCTIONS ========== */\n\n\t/**\n\t * @dev Convenience function\n\t */\n\tfunction increaseObservationCardinality(uint16 numCardinals) external onlyOwner {\n\t\tpool.increaseObservationCardinalityNext(numCardinals);\n\t\temit ObservationCardinalityIncreased(numCardinals);\n\t}\n\n\t/**\n\t * @notice Sets new TWAP lookback period\n\t * @param _secs Lookback period in seconds\n\t */\n\tfunction setTWAPLookbackSec(uint32 _secs) external onlyOwner {\n\t\tif (_secs == 0) revert InvalidLoopbackSecs();\n\t\tlookbackSecs = _secs;\n\t\temit TWAPLookbackSecUpdated(_secs);\n\t}\n\n\t/**\n\t * @notice Toggles price quote option.\n\t */\n\tfunction toggleTokenForPricing() external onlyOwner {\n\t\tpriceInToken0 = !priceInToken0;\n\t\temit TokenForPricingToggled();\n\t}\n\n\t/* ========== VIEWS ========== */\n\n\t/**\n\t * @notice Returns token symbols for base and pricing.\n\t * @return base token symbol\n\t * @return pricing token symbol\n\t */\n\tfunction tokenSymbols() external view returns (string memory base, string memory pricing) {\n\t\tif (priceInToken0) {\n\t\t\tbase = token1.symbol();\n\t\t\tpricing = token0.symbol();\n\t\t} else {\n\t\t\tbase = token0.symbol();\n\t\t\tpricing = token1.symbol();\n\t\t}\n\t}\n\n\t/**\n\t * @notice Returns price\n\t * @return amountOut Price in base token.\n\t */\n\tfunction getPrecisePrice() public view returns (uint256 amountOut) {\n\t\t// Get the average price tick first\n\t\t(int24 arithmeticMeanTick, ) = OracleLibrary.consult(address(pool), lookbackSecs);\n\n\t\t// Get the quote for selling 1 unit of a token. Assumes 1e18 for both.\n\t\tif (priceInToken0) {\n\t\t\tif (decimals0 <= 18) {\n\t\t\t\tamountOut =\n\t\t\t\t\tOracleLibrary.getQuoteAtTick(\n\t\t\t\t\t\tarithmeticMeanTick,\n\t\t\t\t\t\tuint128(10 ** decimals1),\n\t\t\t\t\t\taddress(token1),\n\t\t\t\t\t\taddress(token0)\n\t\t\t\t\t) *\n\t\t\t\t\t(10 ** (18 - decimals0));\n\t\t\t} else {\n\t\t\t\tamountOut =\n\t\t\t\t\tOracleLibrary.getQuoteAtTick(\n\t\t\t\t\t\tarithmeticMeanTick,\n\t\t\t\t\t\tuint128(10 ** decimals1),\n\t\t\t\t\t\taddress(token1),\n\t\t\t\t\t\taddress(token0)\n\t\t\t\t\t) /\n\t\t\t\t\t(10 ** (decimals0 - 18));\n\t\t\t}\n\t\t} else {\n\t\t\tif (decimals1 <= 18) {\n\t\t\t\tamountOut =\n\t\t\t\t\tOracleLibrary.getQuoteAtTick(\n\t\t\t\t\t\tarithmeticMeanTick,\n\t\t\t\t\t\tuint128(10 ** decimals0),\n\t\t\t\t\t\taddress(token0),\n\t\t\t\t\t\taddress(token1)\n\t\t\t\t\t) *\n\t\t\t\t\t(10 ** (18 - decimals1));\n\t\t\t} else {\n\t\t\t\tamountOut =\n\t\t\t\t\tOracleLibrary.getQuoteAtTick(\n\t\t\t\t\t\tarithmeticMeanTick,\n\t\t\t\t\t\tuint128(10 ** decimals0),\n\t\t\t\t\t\taddress(token0),\n\t\t\t\t\t\taddress(token1)\n\t\t\t\t\t) /\n\t\t\t\t\t(10 ** (decimals1 - 18));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Returns current price.\n\t */\n\tfunction consult() public view override returns (uint256) {\n\t\treturn getPrecisePrice();\n\t}\n\n\t/**\n\t * @dev AggregatorV3Interface / Chainlink compatibility.\n\t */\n\tfunction latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80) {\n\t\treturn (0, int256(getPrecisePrice()), 0, block.timestamp, 0);\n\t}\n}"
    },
    "contracts/prime/oracles/wstethOracle.sol": {
      "content": "// // SPDX-License-Identifier: MIT\n// pragma solidity 0.8.12;\n\n// import {OwnableUpgradeable} from \"../../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\n// import {AggregatorV3Interface} from \"../../interfaces/AggregatorV3Interface.sol\";\n// import {Chainlink} from \"../libraries/Oracle.sol\";\n\n// /// @notice Provides wstETH/USD price using stETH/USD Chainlink oracle and wstETH/stETH exchange rate provided by stETH smart contract\n// contract WSTETHOracle is OwnableUpgradeable {\n// \t/// @notice stETH/USD price feed\n// \tAggregatorV3Interface public stETHUSDOracle;\n// \t/// @notice wstETHRatio feed\n// \tAggregatorV3Interface public stEthPerWstETHOracle;\n\n// \terror AddressZero();\n\n// \t/**\n// \t * @notice Initializer\n// \t * @param _stETHUSDOracle stETH/USD price feed\n// \t * @param _stEthPerWstETHOracle wstETHRatio feed\n// \t */\n// \tfunction initialize(address _stETHUSDOracle, address _stEthPerWstETHOracle) public initializer {\n// \t\tif (_stETHUSDOracle == address(0)) revert AddressZero();\n// \t\tif (_stEthPerWstETHOracle == address(0)) revert AddressZero();\n\n// \t\tstETHUSDOracle = AggregatorV3Interface(_stETHUSDOracle); //8 decimals\n// \t\tstEthPerWstETHOracle = AggregatorV3Interface(_stEthPerWstETHOracle); //18 decimals\n// \t\t__Ownable_init();\n// \t}\n\n// \t/**\n// \t * @notice Returns decimals of oracle output\n// \t */\n// \tfunction decimals() external pure returns (uint8) {\n// \t\treturn 8;\n// \t}\n\n// \t/**\n// \t * @notice Returns description of the oracle\n// \t */\n// \tfunction description() external pure returns (string memory) {\n// \t\treturn \"WSTETH/USD\";\n// \t}\n\n// \t/**\n// \t * @notice Returns last updated timestamp of the oracle\n// \t */\n// \tfunction latestTimestamp() external view returns (uint256) {\n// \t\t(\n// \t\t\t,\n// \t\t\t,\n// \t\t\t,\n// \t\t\t//uint80 roundId\n// \t\t\t//int256 answer\n// \t\t\t//uint256 startedAt\n// \t\t\tuint256 updatedAt, //uint256 answeredInRound\n\n// \t\t) = stETHUSDOracle.latestRoundData();\n// \t\treturn updatedAt;\n// \t}\n\n// \t/// @notice Get wstETH/USD price. It does not check Chainlink oracle staleness! If staleness check needed, it's recommended to use latestTimestamp() function\n// \t/// @return answer wstETH/USD price or 0 if failure\n// \tfunction latestAnswer() external view returns (int256 answer) {\n// \t\tint256 stETHPrice = Oracle.getAnswer(stETHUSDOracle);\n// \t\tint256 wstETHRatio = Oracle.getAnswer(stEthPerWstETHOracle);\n\n// \t\tanswer = (stETHPrice * wstETHRatio) / 1 ether;\n// \t}\n\n// \t/**\n// \t * @notice Returns version of the oracle\n// \t */\n// \tfunction version() external pure returns (uint256) {\n// \t\treturn 1;\n// \t}\n// }\n"
    },
    "contracts/prime/staking/ChefIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {RecoverERC20} from \"../libraries/RecoverERC20.sol\";\nimport {IMultiFeeDistribution} from \"../../interfaces/IMultiFeeDistribution.sol\";\nimport {IEligibilityDataProvider} from \"../../interfaces/IEligibilityDataProvider.sol\";\nimport {ILeverager} from \"../../interfaces/ILeverager.sol\";\nimport {IOnwardIncentivesController} from \"../../interfaces/IOnwardIncentivesController.sol\";\nimport {IMiddleFeeDistribution} from \"../../interfaces/IMiddleFeeDistribution.sol\";\n\n/// @title ChefIncentivesController Contract\n/// @author Prime\n/// based on the Sushi MasterChef\n///\thttps://github.com/sushiswap/sushiswap/blob/master/contracts/MasterChef.sol\ncontract ChefIncentivesController is Initializable, PausableUpgradeable, OwnableUpgradeable, RecoverERC20 {\n\tusing SafeERC20 for IERC20;\n\n\t// Info of each user.\n\t// reward = user.`amount` * pool.`accRewardPerShare` - `rewardDebt`\n\tstruct UserInfo {\n\t\tuint256 amount;\n\t\tuint256 rewardDebt;\n\t\tuint256 lastClaimTime;\n\t}\n\n\t// Info of each pool.\n\tstruct PoolInfo {\n\t\tuint256 totalSupply;\n\t\tuint256 allocPoint; // How many allocation points assigned to this pool.\n\t\tuint256 lastRewardTime; // Last second that reward distribution occurs.\n\t\tuint256 accRewardPerShare; // Accumulated rewards per share, times ACC_REWARD_PRECISION. See below.\n\t\tIOnwardIncentivesController onwardIncentives;\n\t}\n\n\t// Info about token emissions for a given time period.\n\tstruct EmissionPoint {\n\t\tuint128 startTimeOffset;\n\t\tuint128 rewardsPerSecond;\n\t}\n\n\t// Info about ending time of reward emissions\n\tstruct EndingTime {\n\t\tuint256 estimatedTime;\n\t\tuint256 lastUpdatedTime;\n\t\tuint256 updateCadence;\n\t}\n\n\t/********************** Events ***********************/\n\t// Emitted when rewardPerSecond is updated\n\tevent RewardsPerSecondUpdated(uint256 indexed rewardsPerSecond, bool persist);\n\n\tevent BalanceUpdated(address indexed token, address indexed user, uint256 balance, uint256 totalSupply);\n\n\tevent EmissionScheduleAppended(uint256[] startTimeOffsets, uint256[] rewardsPerSeconds);\n\n\tevent ChefReserveLow(uint256 indexed _balance);\n\n\tevent Disqualified(address indexed user);\n\n\tevent OnwardIncentivesUpdated(address indexed _token, IOnwardIncentivesController _incentives);\n\n\tevent BountyManagerUpdated(address indexed _bountyManager);\n\n\tevent EligibilityEnabledUpdated(bool indexed _newVal);\n\n\tevent BatchAllocPointsUpdated(address[] _tokens, uint256[] _allocPoints);\n\n\tevent LeveragerUpdated(ILeverager _leverager);\n\n\tevent EndingTimeUpdateCadence(uint256 indexed _lapse);\n\n\tevent RewardDeposit(uint256 indexed _amount);\n\n\t/********************** Errors ***********************/\n\terror AddressZero();\n\n\terror UnknownPool();\n\n\terror PoolExists();\n\n\terror AlreadyStarted();\n\n\terror NotAllowed();\n\n\terror ArrayLengthMismatch();\n\n\terror NotAscending();\n\n\terror ExceedsMaxInt();\n\n\terror InvalidStart();\n\n\terror InvalidRToken();\n\n\terror InsufficientPermission();\n\n\terror NotMFD();\n\n\terror BountyOnly();\n\n\terror NotEligible();\n\n\terror CadenceTooLong();\n\n\terror NotRTokenOrMfd();\n\n\terror OutOfRewards();\n\n\terror NothingToVest();\n\n\terror DuplicateSchedule();\n\n\t// multiplier for reward calc\n\tuint256 private constant ACC_REWARD_PRECISION = 1e12;\n\n\t// Data about the future reward rates. emissionSchedule stored in chronological order,\n\t// whenever the duration since the start timestamp exceeds the next timestamp offset a new\n\t// reward rate is applied.\n\tEmissionPoint[] public emissionSchedule;\n\n\t// If true, keep this new reward rate indefinitely\n\t// If false, keep this reward rate until the next scheduled block offset, then return to the schedule.\n\tbool public persistRewardsPerSecond;\n\n\t/********************** Emission Info ***********************/\n\n\t// Array of tokens for reward\n\taddress[] public registeredTokens;\n\n\t// Current reward per second\n\tuint256 public rewardsPerSecond;\n\n\t// last RPS, used during refill after reserve empty\n\tuint256 public lastRPS;\n\n\t// Index in emission schedule which the last rewardsPerSeconds was used\n\t// only used for scheduled rewards\n\tuint256 public emissionScheduleIndex;\n\n\t// Info of each pool.\n\tmapping(address => PoolInfo) public poolInfo;\n\tmapping(address => bool) private validRTokens;\n\n\t// Total allocation points. Must be the sum of all allocation points in all pools.\n\tuint256 public totalAllocPoint;\n\n\t// token => user => Info of each user that stakes LP tokens.\n\tmapping(address => mapping(address => UserInfo)) public userInfo;\n\n\t// user => base claimable balance\n\tmapping(address => uint256) public userBaseClaimable;\n\n\t// MFD, bounties, AC, middlefee\n\tmapping(address => bool) public eligibilityExempt;\n\n\t// The block number when reward mining starts.\n\tuint256 public startTime;\n\n\t// Option for eligibility\n\tbool public eligibilityEnabled;\n\n\t// Address for PoolConfigurator\n\taddress public poolConfigurator;\n\n\t// Amount of deposited rewards\n\tuint256 public depositedRewards;\n\n\t// Amount of accumulated rewards\n\tuint256 public accountedRewards;\n\n\t// Timestamp when all pools updated\n\tuint256 public lastAllPoolUpdate;\n\n\t// Middle Fee Distribution contract\n\tIMiddleFeeDistribution public rewardMinter;\n\n\t// Eligiblity Data Provider contract\n\tIEligibilityDataProvider public eligibleDataProvider;\n\n\t// Bounty Manager contract\n\taddress public bountyManager;\n\n\t// Leverager contract\n\tILeverager public leverager;\n\n\t// Info of reward emission end time\n\tEndingTime public endingTime;\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Initializer\n\t * @param _poolConfigurator Pool configurator address\n\t * @param _eligibleDataProvider Eligibility Data provider address\n\t * @param _rewardMinter Middle fee distribution contract\n\t * @param _rewardsPerSecond RPS\n\t */\n\tfunction initialize(\n\t\taddress _poolConfigurator,\n\t\tIEligibilityDataProvider _eligibleDataProvider,\n\t\tIMiddleFeeDistribution _rewardMinter,\n\t\tuint256 _rewardsPerSecond\n\t) public initializer {\n\t\tif (_poolConfigurator == address(0)) revert AddressZero();\n\t\tif (address(_eligibleDataProvider) == address(0)) revert AddressZero();\n\t\tif (address(_rewardMinter) == address(0)) revert AddressZero();\n\n\t\t__Ownable_init();\n\t\t__Pausable_init();\n\n\t\tpoolConfigurator = _poolConfigurator;\n\t\teligibleDataProvider = _eligibleDataProvider;\n\t\trewardMinter = _rewardMinter;\n\t\trewardsPerSecond = _rewardsPerSecond;\n\t\tpersistRewardsPerSecond = true;\n\n\t\teligibilityEnabled = true;\n\t}\n\n\t/**\n\t * @dev Returns length of reward pools.\n\t */\n\tfunction poolLength() public view returns (uint256) {\n\t\treturn registeredTokens.length;\n\t}\n\n\t/**\n\t * @dev Returns address of MFD.\n\t * @return mfd contract address\n\t */\n\tfunction _getMfd() internal view returns (IMultiFeeDistribution mfd) {\n\t\taddress multiFeeDistribution = rewardMinter.getMultiFeeDistributionAddress();\n\t\tmfd = IMultiFeeDistribution(multiFeeDistribution);\n\t}\n\n\t/**\n\t * @notice Sets incentive controllers for custom token.\n\t * @param _token for reward pool\n\t * @param _incentives incentives contract address\n\t */\n\tfunction setOnwardIncentives(address _token, IOnwardIncentivesController _incentives) external onlyOwner {\n\t\tPoolInfo storage pool = poolInfo[_token];\n\t\tif (pool.lastRewardTime == 0) revert UnknownPool();\n\t\tpool.onwardIncentives = _incentives;\n\t\temit OnwardIncentivesUpdated(_token, _incentives);\n\t}\n\n\t/**\n\t * @dev Updates bounty manager contract.\n\t * @param _bountyManager Bounty Manager contract.\n\t */\n\tfunction setBountyManager(address _bountyManager) external onlyOwner {\n\t\tbountyManager = _bountyManager;\n\t\temit BountyManagerUpdated(_bountyManager);\n\t}\n\n\t/**\n\t * @dev Enable/Disable eligibility\n\t * @param _newVal New value.\n\t */\n\tfunction setEligibilityEnabled(bool _newVal) external onlyOwner {\n\t\teligibilityEnabled = _newVal;\n\t\temit EligibilityEnabledUpdated(_newVal);\n\t}\n\n\t/********************** Pool Setup + Admin ***********************/\n\n\t/**\n\t * @dev Starts PRNT emission.\n\t */\n\tfunction start() public onlyOwner {\n\t\tif (startTime != 0) revert AlreadyStarted();\n\t\tstartTime = block.timestamp;\n\t}\n\n\t/**\n\t * @dev Add a new lp to the pool. Can only be called by the poolConfigurator.\n\t * @param _token for reward pool\n\t * @param _allocPoint allocation point of the pool\n\t */\n\tfunction addPool(address _token, uint256 _allocPoint) external {\n\t\tif (msg.sender != poolConfigurator) revert NotAllowed();\n\t\tif (poolInfo[_token].lastRewardTime != 0) revert PoolExists();\n\t\t_updateEmissions();\n\t\ttotalAllocPoint = totalAllocPoint + _allocPoint;\n\t\tregisteredTokens.push(_token);\n\t\tPoolInfo storage pool = poolInfo[_token];\n\t\tpool.allocPoint = _allocPoint;\n\t\tpool.lastRewardTime = block.timestamp;\n\t\tpool.onwardIncentives = IOnwardIncentivesController(address(0));\n\t\tvalidRTokens[_token] = true;\n\t}\n\n\t/**\n\t * @dev Update the given pool's allocation point. Can only be called by the owner.\n\t * @param _tokens for reward pools\n\t * @param _allocPoints allocation points of the pools\n\t */\n\tfunction batchUpdateAllocPoint(address[] calldata _tokens, uint256[] calldata _allocPoints) external onlyOwner {\n\t\tif (_tokens.length != _allocPoints.length) revert ArrayLengthMismatch();\n\t\t_massUpdatePools();\n\t\tuint256 _totalAllocPoint = totalAllocPoint;\n\t\tuint256 length = _tokens.length;\n\t\tfor (uint256 i; i < length; ) {\n\t\t\tPoolInfo storage pool = poolInfo[_tokens[i]];\n\t\t\tif (pool.lastRewardTime == 0) revert UnknownPool();\n\t\t\t_totalAllocPoint = _totalAllocPoint - pool.allocPoint + _allocPoints[i];\n\t\t\tpool.allocPoint = _allocPoints[i];\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\ttotalAllocPoint = _totalAllocPoint;\n\t\temit BatchAllocPointsUpdated(_tokens, _allocPoints);\n\t}\n\n\t/**\n\t * @notice Sets the reward per second to be distributed. Can only be called by the owner.\n\t * @dev Its decimals count is ACC_REWARD_PRECISION\n\t * @param _rewardsPerSecond The amount of reward to be distributed per second.\n\t * @param _persist true if RPS is fixed, otherwise RPS is by emission schedule.\n\t */\n\tfunction setRewardsPerSecond(uint256 _rewardsPerSecond, bool _persist) external onlyOwner {\n\t\t_massUpdatePools();\n\t\trewardsPerSecond = _rewardsPerSecond;\n\t\tpersistRewardsPerSecond = _persist;\n\t\temit RewardsPerSecondUpdated(_rewardsPerSecond, _persist);\n\t}\n\n\t/**\n\t * @dev Updates RPS.\n\t */\n\tfunction setScheduledRewardsPerSecond() internal {\n\t\tif (!persistRewardsPerSecond) {\n\t\t\tuint256 length = emissionSchedule.length;\n\t\t\tuint256 i = emissionScheduleIndex;\n\t\t\tuint128 offset = uint128(block.timestamp - startTime);\n\t\t\tfor (; i < length && offset >= emissionSchedule[i].startTimeOffset; ) {\n\t\t\t\tunchecked {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i > emissionScheduleIndex) {\n\t\t\t\temissionScheduleIndex = i;\n\t\t\t\t_massUpdatePools();\n\t\t\t\trewardsPerSecond = uint256(emissionSchedule[i - 1].rewardsPerSecond);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Ensure that the specified time offset hasn't been registered already.\n\t * @param _startTimeOffset time offset\n\t * @return true if the specified time offset is already registered\n\t */\n\tfunction _checkDuplicateSchedule(uint256 _startTimeOffset) internal view returns (bool) {\n\t\tuint256 length = emissionSchedule.length;\n\t\tfor (uint256 i = 0; i < length; ) {\n\t\t\tif (emissionSchedule[i].startTimeOffset == _startTimeOffset) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @notice Updates PRNT emission schedule.\n\t * @dev This appends the new offsets and RPS.\n\t * @param _startTimeOffsets Offsets array.\n\t * @param _rewardsPerSecond RPS array.\n\t */\n\tfunction setEmissionSchedule(\n\t\tuint256[] calldata _startTimeOffsets,\n\t\tuint256[] calldata _rewardsPerSecond\n\t) external onlyOwner {\n\t\tuint256 length = _startTimeOffsets.length;\n\t\tif (length <= 0 || length != _rewardsPerSecond.length) revert ArrayLengthMismatch();\n\n\t\tfor (uint256 i = 0; i < length; ) {\n\t\t\tif (i > 0) {\n\t\t\t\tif (_startTimeOffsets[i - 1] > _startTimeOffsets[i]) revert NotAscending();\n\t\t\t}\n\t\t\tif (_startTimeOffsets[i] > type(uint128).max) revert ExceedsMaxInt();\n\t\t\tif (_rewardsPerSecond[i] > type(uint128).max) revert ExceedsMaxInt();\n\t\t\tif (_checkDuplicateSchedule(_startTimeOffsets[i])) revert DuplicateSchedule();\n\n\t\t\tif (startTime > 0) {\n\t\t\t\tif (_startTimeOffsets[i] < block.timestamp - startTime) revert InvalidStart();\n\t\t\t}\n\t\t\temissionSchedule.push(\n\t\t\t\tEmissionPoint({\n\t\t\t\t\tstartTimeOffset: uint128(_startTimeOffsets[i]),\n\t\t\t\t\trewardsPerSecond: uint128(_rewardsPerSecond[i])\n\t\t\t\t})\n\t\t\t);\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\temit EmissionScheduleAppended(_startTimeOffsets, _rewardsPerSecond);\n\t}\n\n\t/**\n\t * @notice Recover tokens in this contract. Callable by owner.\n\t * @param tokenAddress Token address for recover\n\t * @param tokenAmount Amount to recover\n\t */\n\tfunction recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n\t\t_recoverERC20(tokenAddress, tokenAmount);\n\t}\n\n\t/********************** Pool State Changers ***********************/\n\n\t/**\n\t * @dev Update emission params of CIC.\n\t */\n\tfunction _updateEmissions() internal {\n\t\tif (block.timestamp > endRewardTime()) {\n\t\t\t_massUpdatePools();\n\t\t\tlastRPS = rewardsPerSecond;\n\t\t\trewardsPerSecond = 0;\n\t\t\treturn;\n\t\t}\n\t\tsetScheduledRewardsPerSecond();\n\t}\n\n\t/**\n\t * @dev Update reward variables for all pools.\n\t */\n\tfunction _massUpdatePools() internal {\n\t\tuint256 totalAP = totalAllocPoint;\n\t\tuint256 length = poolLength();\n\t\tfor (uint256 i; i < length; ) {\n\t\t\t_updatePool(poolInfo[registeredTokens[i]], totalAP);\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tlastAllPoolUpdate = block.timestamp;\n\t}\n\n\t/**\n\t * @dev Update reward variables of the given pool to be up-to-date.\n\t * @param pool pool info\n\t * @param _totalAllocPoint allocation point of the pool\n\t */\n\tfunction _updatePool(PoolInfo storage pool, uint256 _totalAllocPoint) internal {\n\t\tuint256 timestamp = block.timestamp;\n\t\tuint256 endReward = endRewardTime();\n\t\tif (endReward <= timestamp) {\n\t\t\ttimestamp = endReward;\n\t\t}\n\t\tif (timestamp <= pool.lastRewardTime) {\n\t\t\treturn;\n\t\t}\n\n\t\t(uint256 reward, uint256 newAccRewardPerShare) = _newRewards(pool, _totalAllocPoint);\n\t\taccountedRewards = accountedRewards + reward;\n\t\tpool.accRewardPerShare = pool.accRewardPerShare + newAccRewardPerShare;\n\t\tpool.lastRewardTime = timestamp;\n\t}\n\n\t/********************** Emission Calc + Transfer ***********************/\n\n\t/**\n\t * @notice Pending rewards of a user.\n\t * @param _user address for claim\n\t * @param _tokens array of reward-bearing tokens\n\t * @return claimable rewards array\n\t */\n\tfunction pendingRewards(address _user, address[] memory _tokens) public view returns (uint256[] memory) {\n\t\tuint256[] memory claimable = new uint256[](_tokens.length);\n\t\tuint256 length = _tokens.length;\n\t\tfor (uint256 i; i < length; ) {\n\t\t\taddress token = _tokens[i];\n\t\t\tPoolInfo storage pool = poolInfo[token];\n\t\t\tUserInfo storage user = userInfo[token][_user];\n\t\t\tuint256 accRewardPerShare = pool.accRewardPerShare;\n\t\t\tif (block.timestamp > pool.lastRewardTime) {\n\t\t\t\t(, uint256 newAccRewardPerShare) = _newRewards(pool, totalAllocPoint);\n\t\t\t\taccRewardPerShare = accRewardPerShare + newAccRewardPerShare;\n\t\t\t}\n\t\t\tclaimable[i] = (user.amount * accRewardPerShare) / ACC_REWARD_PRECISION - user.rewardDebt;\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn claimable;\n\t}\n\n\t/**\n\t * @notice Claim rewards. They are vested into MFD.\n\t * @param _user address for claim\n\t * @param _tokens array of reward-bearing tokens\n\t */\n\tfunction claim(address _user, address[] memory _tokens) public whenNotPaused {\n\t\tif (eligibilityEnabled) {\n\t\t\tcheckAndProcessEligibility(_user, true, true);\n\t\t}\n\n\t\t_updateEmissions();\n\n\t\tuint256 currentTimestamp = block.timestamp;\n\n\t\tuint256 pending = userBaseClaimable[_user];\n\t\tuserBaseClaimable[_user] = 0;\n\t\tuint256 _totalAllocPoint = totalAllocPoint;\n\t\tuint256 length = _tokens.length;\n\t\tfor (uint256 i; i < length; ) {\n\t\t\tif (!validRTokens[_tokens[i]]) revert InvalidRToken();\n\t\t\tPoolInfo storage pool = poolInfo[_tokens[i]];\n\t\t\tif (pool.lastRewardTime == 0) revert UnknownPool();\n\t\t\t_updatePool(pool, _totalAllocPoint);\n\t\t\tUserInfo storage user = userInfo[_tokens[i]][_user];\n\t\t\tuint256 rewardDebt = (user.amount * pool.accRewardPerShare) / ACC_REWARD_PRECISION;\n\t\t\tpending = pending + rewardDebt - user.rewardDebt;\n\t\t\tuser.rewardDebt = rewardDebt;\n\t\t\tuser.lastClaimTime = currentTimestamp;\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t_vestTokens(_user, pending);\n\n\t\teligibleDataProvider.updatePrice();\n\n\t\tif (endRewardTime() < currentTimestamp + 5 days) {\n\t\t\taddress prntToken = rewardMinter.getPrntTokenAddress();\n\t\t\temit ChefReserveLow(IERC20(prntToken).balanceOf(address(this)));\n\t\t}\n\t}\n\n\t/**\n\t * @notice Vest tokens to MFD.\n\t * @param _user address to receive\n\t * @param _amount to vest\n\t */\n\tfunction _vestTokens(address _user, uint256 _amount) internal {\n\t\tif (_amount == 0) revert NothingToVest();\n\t\tIMultiFeeDistribution mfd = _getMfd();\n\t\t_sendPrime(address(mfd), _amount);\n\t\tmfd.vestTokens(_user, _amount, true);\n\t}\n\n\t/**\n\t * @notice Exempt a contract from eligibility check.\n\t * @dev Can be called by owner or leverager contract\n\t * @param _contract address to exempt\n\t * @param _value flag for exempt\n\t */\n\tfunction setEligibilityExempt(address _contract, bool _value) public {\n\t\tif (msg.sender != owner() && msg.sender != address(leverager)) revert InsufficientPermission();\n\t\teligibilityExempt[_contract] = _value;\n\t}\n\n\t/**\n\t * @notice Updates leverager, only callable by owner.\n\t * @param _leverager contract\n\t */\n\tfunction setLeverager(ILeverager _leverager) external onlyOwner {\n\t\tleverager = _leverager;\n\t\temit LeveragerUpdated(_leverager);\n\t}\n\n\t/********************** Eligibility + Disqualification ***********************/\n\n\t/**\n\t * @notice `after` Hook for deposit and borrow update.\n\t * @dev important! eligible status can be updated here\n\t * @param _user address\n\t * @param _balance balance of token\n\t * @param _totalSupply total supply of the token\n\t */\n\tfunction handleActionAfter(address _user, uint256 _balance, uint256 _totalSupply) external {\n\t\tif (!validRTokens[msg.sender] && msg.sender != address(_getMfd())) revert NotRTokenOrMfd();\n\n\t\tif (_user == address(rewardMinter) || _user == address(_getMfd()) || eligibilityExempt[_user]) {\n\t\t\treturn;\n\t\t}\n\t\tif (eligibilityEnabled) {\n\t\t\tbool lastEligibleStatus = eligibleDataProvider.lastEligibleStatus(_user);\n\t\t\tbool isCurrentlyEligible = eligibleDataProvider.refresh(_user);\n\t\t\tif (isCurrentlyEligible) {\n\t\t\t\tif (lastEligibleStatus) {\n\t\t\t\t\t_handleActionAfterForToken(msg.sender, _user, _balance, _totalSupply);\n\t\t\t\t} else {\n\t\t\t\t\t_updateRegisteredBalance(_user);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_processEligibility(_user, isCurrentlyEligible, true);\n\t\t\t}\n\t\t} else {\n\t\t\t_handleActionAfterForToken(msg.sender, _user, _balance, _totalSupply);\n\t\t}\n\t}\n\n\t/**\n\t * @notice `after` Hook for deposit and borrow update.\n\t * @dev important! eligible status can be updated here\n\t * @param _token address\n\t * @param _user address\n\t * @param _balance new amount\n\t * @param _totalSupply total supply of the token\n\t */\n\tfunction _handleActionAfterForToken(\n\t\taddress _token,\n\t\taddress _user,\n\t\tuint256 _balance,\n\t\tuint256 _totalSupply\n\t) internal {\n\t\tPoolInfo storage pool = poolInfo[_token];\n\t\tif (pool.lastRewardTime == 0) revert UnknownPool();\n\t\t// Although we would want the pools to be as up to date as possible when users\n\t\t// transfer rTokens or dTokens, updating all pools on every r-/d-Token interaction would be too gas intensive.\n\t\t// _updateEmissions();\n\t\t_updatePool(pool, totalAllocPoint);\n\t\tUserInfo storage user = userInfo[_token][_user];\n\t\tuint256 amount = user.amount;\n\t\tuint256 accRewardPerShare = pool.accRewardPerShare;\n\t\tif (amount != 0) {\n\t\t\tuint256 pending = (amount * accRewardPerShare) / ACC_REWARD_PRECISION - user.rewardDebt;\n\t\t\tif (pending != 0) {\n\t\t\t\tuserBaseClaimable[_user] = userBaseClaimable[_user] + pending;\n\t\t\t}\n\t\t}\n\t\tpool.totalSupply = pool.totalSupply - user.amount;\n\t\tuser.amount = _balance;\n\t\tuser.rewardDebt = (_balance * accRewardPerShare) / ACC_REWARD_PRECISION;\n\t\tpool.totalSupply = pool.totalSupply + _balance;\n\t\tif (pool.onwardIncentives != IOnwardIncentivesController(address(0))) {\n\t\t\tpool.onwardIncentives.handleAction(_token, _user, _balance, _totalSupply);\n\t\t}\n\n\t\temit BalanceUpdated(_token, _user, _balance, _totalSupply);\n\t}\n\n\t/**\n\t * @notice `before` Hook for deposit and borrow update.\n\t * @param _user address\n\t */\n\tfunction handleActionBefore(address _user) external {}\n\n\t/**\n\t * @notice Hook for lock update.\n\t * @dev Called by the locking contracts before locking or unlocking happens\n\t * @param _user address\n\t */\n\tfunction beforeLockUpdate(address _user) external {}\n\n\t/**\n\t * @notice Hook for lock update.\n\t * @dev Called by the locking contracts after locking or unlocking happens\n\t * @param _user address\n\t */\n\tfunction afterLockUpdate(address _user) external {\n\t\tif (msg.sender != address(_getMfd())) revert NotMFD();\n\t\tif (eligibilityEnabled) {\n\t\t\tbool isCurrentlyEligible = eligibleDataProvider.refresh(_user);\n\t\t\tif (isCurrentlyEligible) {\n\t\t\t\t_updateRegisteredBalance(_user);\n\t\t\t} else {\n\t\t\t\t_processEligibility(_user, isCurrentlyEligible, true);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Update balance if there are any unregistered.\n\t * @param _user address of the user whose balances will be updated\n\t */\n\tfunction _updateRegisteredBalance(address _user) internal {\n\t\tuint256 length = poolLength();\n\t\tfor (uint256 i; i < length; ) {\n\t\t\tuint256 newBal = IERC20(registeredTokens[i]).balanceOf(_user);\n\t\t\tuint256 registeredBal = userInfo[registeredTokens[i]][_user].amount;\n\t\t\tif (newBal != 0 && newBal != registeredBal) {\n\t\t\t\t_handleActionAfterForToken(\n\t\t\t\t\tregisteredTokens[i],\n\t\t\t\t\t_user,\n\t\t\t\t\tnewBal,\n\t\t\t\t\tpoolInfo[registeredTokens[i]].totalSupply + newBal - registeredBal\n\t\t\t\t);\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/********************** Eligibility + Disqualification ***********************/\n\n\t/**\n\t * @dev Returns true if `_user` has some reward eligible tokens.\n\t * @param _user address of recipient\n\t */\n\tfunction hasEligibleDeposits(address _user) internal view returns (bool hasDeposits) {\n\t\tuint256 length = poolLength();\n\t\tfor (uint256 i; i < length; ) {\n\t\t\tif (userInfo[registeredTokens[i]][_user].amount != 0) {\n\t\t\t\thasDeposits = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @dev Stop emissions if there's any new DQ.\n\t * @param _user address of recipient\n\t * @param _isEligible user's eligible status\n\t * @param _execute true if it's actual execution\n\t * @return issueBaseBounty true for base bounty\n\t */\n\tfunction _processEligibility(\n\t\taddress _user,\n\t\tbool _isEligible,\n\t\tbool _execute\n\t) internal returns (bool issueBaseBounty) {\n\t\tbool hasEligDeposits = hasEligibleDeposits(_user);\n\t\tuint256 lastDqTime = eligibleDataProvider.getDqTime(_user);\n\t\tbool alreadyDqd = lastDqTime != 0;\n\n\t\tif (!_isEligible && hasEligDeposits && !alreadyDqd) {\n\t\t\tissueBaseBounty = true;\n\t\t}\n\t\tif (_execute && issueBaseBounty) {\n\t\t\tstopEmissionsFor(_user);\n\t\t\temit Disqualified(_user);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Check eligibility of the user\n\t * @dev Stop emissions if there's any DQ.\n\t * @param _user address of recipient\n\t * @param _execute true if it's actual execution\n\t * @param _refresh true if needs to refresh user's eligible status\n\t * @return issueBaseBounty true for base bounty\n\t */\n\tfunction checkAndProcessEligibility(\n\t\taddress _user,\n\t\tbool _execute,\n\t\tbool _refresh\n\t) internal returns (bool issueBaseBounty) {\n\t\tbool isEligible;\n\t\tif (_refresh && _execute) {\n\t\t\tisEligible = eligibleDataProvider.refresh(_user);\n\t\t} else {\n\t\t\tisEligible = eligibleDataProvider.isEligibleForRewards(_user);\n\t\t}\n\t\tissueBaseBounty = _processEligibility(_user, isEligible, _execute);\n\t}\n\n\t/**\n\t * @notice Claim bounty\n\t * @param _user address of recipient\n\t * @param _execute true if it's actual execution\n\t * @return issueBaseBounty true for base bounty\n\t */\n\tfunction claimBounty(address _user, bool _execute) public returns (bool issueBaseBounty) {\n\t\tif (msg.sender != address(bountyManager)) revert BountyOnly();\n\t\tissueBaseBounty = checkAndProcessEligibility(_user, _execute, true);\n\t}\n\n\t/**\n\t * @dev Stop PRNT emissions for specific users\n\t * @param _user address of recipient\n\t */\n\tfunction stopEmissionsFor(address _user) internal {\n\t\tif (!eligibilityEnabled) revert NotEligible();\n\t\t// lastEligibleStatus will be fresh from refresh before this call\n\t\tuint256 length = poolLength();\n\t\tfor (uint256 i; i < length; ) {\n\t\t\taddress token = registeredTokens[i];\n\t\t\tPoolInfo storage pool = poolInfo[token];\n\t\t\tUserInfo storage user = userInfo[token][_user];\n\n\t\t\tif (user.amount != 0) {\n\t\t\t\t_handleActionAfterForToken(token, _user, 0, pool.totalSupply - user.amount);\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\teligibleDataProvider.setDqTime(_user, block.timestamp);\n\t}\n\n\t/**\n\t * @dev Send RNDT rewards to user.\n\t * @param _user address of recipient\n\t * @param _amount of PRNT\n\t */\n\tfunction _sendPrime(address _user, uint256 _amount) internal {\n\t\tif (_amount == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\taddress prntToken = rewardMinter.getPrntTokenAddress();\n\t\tuint256 chefReserve = IERC20(prntToken).balanceOf(address(this));\n\t\tif (_amount > chefReserve) {\n\t\t\trevert OutOfRewards();\n\t\t} else {\n\t\t\tIERC20(prntToken).safeTransfer(_user, _amount);\n\t\t}\n\t}\n\n\t/********************** PRNT Reserve Management ***********************/\n\n\t/**\n\t * @notice Ending reward distribution time.\n\t */\n\tfunction endRewardTime() public returns (uint256) {\n\t\tuint256 unclaimedRewards = availableRewards();\n\t\tuint256 extra = 0;\n\t\tuint256 length = poolLength();\n\t\tfor (uint256 i; i < length; ) {\n\t\t\tPoolInfo storage pool = poolInfo[registeredTokens[i]];\n\n\t\t\tif (pool.lastRewardTime > lastAllPoolUpdate) {\n\t\t\t\textra +=\n\t\t\t\t\t((pool.lastRewardTime - lastAllPoolUpdate) * pool.allocPoint * rewardsPerSecond) /\n\t\t\t\t\ttotalAllocPoint;\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tendingTime.lastUpdatedTime = block.timestamp;\n\n\t\tif (rewardsPerSecond == 0) {\n\t\t\tendingTime.estimatedTime = type(uint256).max;\n\t\t} else {\n\t\t\tendingTime.estimatedTime = (unclaimedRewards + extra) / rewardsPerSecond + lastAllPoolUpdate;\n\t\t}\n\t\treturn endingTime.estimatedTime;\n\t}\n\n\t/**\n\t * @notice Updates cadence duration of ending time.\n\t * @dev Only callable by owner.\n\t * @param _lapse new cadence\n\t */\n\tfunction setEndingTimeUpdateCadence(uint256 _lapse) external onlyOwner {\n\t\tif (_lapse > 1 weeks) revert CadenceTooLong();\n\t\tendingTime.updateCadence = _lapse;\n\t\temit EndingTimeUpdateCadence(_lapse);\n\t}\n\n\t/**\n\t * @notice Add new rewards.\n\t * @dev Only callable by owner.\n\t * @param _amount new deposit amount\n\t */\n\tfunction registerRewardDeposit(uint256 _amount) external onlyOwner {\n\t\tdepositedRewards = depositedRewards + _amount;\n\t\t_massUpdatePools();\n\t\tif (rewardsPerSecond == 0 && lastRPS > 0) {\n\t\t\trewardsPerSecond = lastRPS;\n\t\t}\n\t\temit RewardDeposit(_amount);\n\t}\n\n\t/**\n\t * @notice Available reward amount for future distribution.\n\t * @dev This value is equal to `depositedRewards` - `accountedRewards`.\n\t * @return amount available\n\t */\n\tfunction availableRewards() internal view returns (uint256 amount) {\n\t\treturn depositedRewards - accountedRewards;\n\t}\n\n\t/**\n\t * @notice Claim rewards entitled to all registered tokens.\n\t * @param _user address of the user\n\t */\n\tfunction claimAll(address _user) external {\n\t\tclaim(_user, registeredTokens);\n\t}\n\n\t/**\n\t * @notice Sum of all pending PRNT rewards.\n\t * @param _user address of the user\n\t * @return pending reward amount\n\t */\n\tfunction allPendingRewards(address _user) public view returns (uint256 pending) {\n\t\tpending = userBaseClaimable[_user];\n\t\tuint256[] memory claimable = pendingRewards(_user, registeredTokens);\n\t\tuint256 length = claimable.length;\n\t\tfor (uint256 i; i < length; ) {\n\t\t\tpending += claimable[i];\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Pause the claim operations.\n\t */\n\tfunction pause() external onlyOwner {\n\t\t_pause();\n\t}\n\n\t/**\n\t * @notice Unpause the claim operations.\n\t */\n\tfunction unpause() external onlyOwner {\n\t\t_unpause();\n\t}\n\n\t/**\n\t * @dev Returns new rewards since last reward time.\n\t * @param pool pool info\n\t * @param _totalAllocPoint allocation point of the pool\n\t */\n\tfunction _newRewards(\n\t\tPoolInfo memory pool,\n\t\tuint256 _totalAllocPoint\n\t) internal view returns (uint256 newReward, uint256 newAccRewardPerShare) {\n\t\tuint256 lpSupply = pool.totalSupply;\n\t\tif (lpSupply > 0) {\n\t\t\tuint256 duration = block.timestamp - pool.lastRewardTime;\n\t\t\tuint256 rawReward = duration * rewardsPerSecond;\n\n\t\t\tuint256 rewards = availableRewards();\n\t\t\tif (rewards < rawReward) {\n\t\t\t\trawReward = rewards;\n\t\t\t}\n\t\t\tnewReward = (rawReward * pool.allocPoint) / _totalAllocPoint;\n\t\t\tnewAccRewardPerShare = (newReward * ACC_REWARD_PRECISION) / lpSupply;\n\t\t}\n\t}\n}\n"
    },
    "contracts/prime/staking/LockerList.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {AddressPagination} from \"../libraries/AddressPagination.sol\";\n\n/// @title Locker List Contract\n/// @author Prime\ncontract LockerList is Ownable {\n\tusing AddressPagination for address[];\n\n\t// Users list\n\taddress[] internal userList;\n\tmapping(address => uint256) internal indexOf;\n\tmapping(address => bool) internal inserted;\n\n\t/********************** Events ***********************/\n\n\tevent LockerAdded(address indexed locker);\n\tevent LockerRemoved(address indexed locker);\n\n\t/********************** Errors ***********************/\n\n\terror Ineligible();\n\n\t/********************** Lockers list ***********************/\n\n\t/**\n\t * @notice Return the number of users.\n\t * @return count The number of users\n\t */\n\tfunction lockersCount() external view returns (uint256 count) {\n\t\tcount = userList.length;\n\t}\n\n\t/**\n\t * @notice Return the list of users.\n\t * @dev This is a very gas intensive function to execute and thus should only by utilized by off-chain entities.\n\t * @param page The page number to retrieve\n\t * @param limit The number of entries per page\n\t * @return users A paginated list of users\n\t */\n\tfunction getUsers(uint256 page, uint256 limit) external view returns (address[] memory users) {\n\t\tusers = userList.paginate(page, limit);\n\t}\n\n\t/**\n\t * @notice Add a locker.\n\t * @dev This can be called only by the owner. Owner should be MFD contract.\n\t * @param user address to be added\n\t */\n\tfunction addToList(address user) external onlyOwner {\n\t\tif (inserted[user] == false) {\n\t\t\tinserted[user] = true;\n\t\t\tindexOf[user] = userList.length;\n\t\t\tuserList.push(user);\n\t\t}\n\n\t\temit LockerAdded(user);\n\t}\n\n\t/**\n\t * @notice Remove a locker.\n\t * @dev This can be called only by the owner. Owner should be MFD contract.\n\t * @param user address to remove\n\t */\n\tfunction removeFromList(address user) external onlyOwner {\n\t\tif (inserted[user] == false) revert Ineligible();\n\n\t\tdelete inserted[user];\n\n\t\tuint256 index = indexOf[user];\n\t\tuint256 lastIndex = userList.length - 1;\n\t\taddress lastUser = userList[lastIndex];\n\n\t\tindexOf[lastUser] = index;\n\t\tdelete indexOf[user];\n\n\t\tuserList[index] = lastUser;\n\t\tuserList.pop();\n\n\t\temit LockerRemoved(user);\n\t}\n}"
    },
    "contracts/prime/staking/MiddleFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {RecoverERC20} from \"../libraries/RecoverERC20.sol\";\nimport {IMiddleFeeDistribution} from \"../../interfaces/IMiddleFeeDistribution.sol\";\nimport {IMultiFeeDistribution} from \"../../interfaces/IMultiFeeDistribution.sol\";\nimport {IMintableToken} from \"../../interfaces/IMintableToken.sol\";\nimport {IAaveOracle} from \"../../interfaces/IAaveOracle.sol\";\nimport {IAToken} from \"../../interfaces/IAToken.sol\";\nimport {IChainlinkAggregator} from \"../../interfaces/IChainlinkAggregator.sol\";\nimport {IAaveProtocolDataProvider} from \"../../interfaces/IAaveProtocolDataProvider.sol\";\nimport {IPriceProvider} from \"../../interfaces/IPriceProvider.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title Fee distributor inside\n/// @author Prime\ncontract MiddleFeeDistribution is IMiddleFeeDistribution, Initializable, OwnableUpgradeable, RecoverERC20 {\n\tusing SafeERC20 for IERC20;\n\n\t/// @notice PRNT token\n\tIMintableToken public prntToken;\n\n\t/// @notice Fee distributor contract for earnings and PRNT lockings\n\tIMultiFeeDistribution public multiFeeDistribution;\n\n\t/// @notice Reward ratio for operation expenses\n\tuint256 public operationExpenseRatio;\n\n\tuint256 public constant RATIO_DIVISOR = 10000;\n\n\tuint8 public constant DECIMALS = 18;\n\n\tmapping(address => bool) public isRewardToken;\n\n\t/// @notice Operation Expense account\n\taddress public operationExpenses;\n\n\t/// @notice Admin address\n\taddress public admin;\n\n\t// AAVE Oracle address\n\taddress internal _aaveOracle;\n\n\t// AAVE Protocol Data Provider address\n\tIAaveProtocolDataProvider public aaveProtocolDataProvider;\n\n\t/********************** Events ***********************/\n\n\t/// @notice Emitted when reward token is forwarded\n\tevent ForwardReward(address indexed token, uint256 amount);\n\n\t/// @notice Emitted when operation expenses is set\n\tevent OperationExpensesUpdated(address indexed _operationExpenses, uint256 _operationExpenseRatio);\n\n\tevent NewTransferAdded(address indexed asset, uint256 lpUsdValue);\n\n\tevent AdminUpdated(address indexed _configurator);\n\n\tevent RewardsUpdated(address indexed _rewardsToken);\n\n\tevent ProtocolDataProviderUpdated(address indexed _providerAddress);\n\n\t/********************** Errors ***********************/\n\n\terror ZeroAddress();\n\n\terror IncompatibleToken();\n\n\terror InvalidRatio();\n\n\terror NotMFD();\n\n\terror InsufficientPermission();\n\n\t/**\n\t * @dev Throws if called by any account other than the admin or owner.\n\t */\n\tmodifier onlyAdminOrOwner() {\n\t\tif (admin != _msgSender() && owner() != _msgSender()) revert InsufficientPermission();\n\t\t_;\n\t}\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Initializer\n\t * @param prntToken_ PRNT address\n\t * @param aaveOracle_ Aave oracle address\n\t * @param multiFeeDistribution_ Multi fee distribution contract\n\t */\n\tfunction initialize(\n\t\tIMintableToken prntToken_,\n\t\taddress aaveOracle_,\n\t\tIMultiFeeDistribution multiFeeDistribution_,\n\t\tIAaveProtocolDataProvider aaveProtocolDataProvider_\n\t) public initializer {\n\t\tif (aaveOracle_ == address(0)) revert ZeroAddress();\n\t\tif (address(prntToken_) == address(0)) revert ZeroAddress();\n\t\tif (address(multiFeeDistribution_) == address(0)) revert ZeroAddress();\n\t\tif (address(aaveProtocolDataProvider_) == address(0)) revert ZeroAddress();\n\n\t\t__Ownable_init();\n\n\t\tprntToken = prntToken_;\n\t\t_aaveOracle = aaveOracle_;\n\t\tmultiFeeDistribution = multiFeeDistribution_;\n\t\taaveProtocolDataProvider = aaveProtocolDataProvider_;\n\n\t\tadmin = msg.sender;\n\t}\n\n\t/**\n\t * @notice Set operation expenses account\n\t * @param _operationExpenses Address to receive operation expenses\n\t * @param _operationExpenseRatio Proportion of operation expense\n\t */\n\tfunction setOperationExpenses(address _operationExpenses, uint256 _operationExpenseRatio) external onlyOwner {\n\t\tif (_operationExpenseRatio > RATIO_DIVISOR) revert InvalidRatio();\n\t\tif (_operationExpenses == address(0)) revert ZeroAddress();\n\t\toperationExpenses = _operationExpenses;\n\t\toperationExpenseRatio = _operationExpenseRatio;\n\t\temit OperationExpensesUpdated(_operationExpenses, _operationExpenseRatio);\n\t}\n\n\t/**\n\t * @notice Sets pool configurator as admin.\n\t * @param _configurator Configurator address\n\t */\n\tfunction setAdmin(address _configurator) external onlyOwner {\n\t\tif (_configurator == address(0)) revert ZeroAddress();\n\t\tadmin = _configurator;\n\t\temit AdminUpdated(_configurator);\n\t}\n\n\t/**\n\t * @notice Set the Protocol Data Provider address\n\t * @param _providerAddress The address of the protocol data provider contract\n\t */\n\tfunction setProtocolDataProvider(IAaveProtocolDataProvider _providerAddress) external onlyOwner {\n\t\tif (address(_providerAddress) == address(0)) revert ZeroAddress();\n\t\taaveProtocolDataProvider = _providerAddress;\n\t\temit ProtocolDataProviderUpdated(address(_providerAddress));\n\t}\n\n\t/**\n\t * @notice Add a new reward token to be distributed to stakers\n\t * @param _rewardsToken address of the reward token\n\t */\n\tfunction addReward(address _rewardsToken) external onlyAdminOrOwner {\n\t\tif (msg.sender != admin) {\n\t\t\ttry IAToken(_rewardsToken).UNDERLYING_ASSET_ADDRESS() returns (address underlying) {\n\t\t\t\t(address aTokenAddress, , ) = aaveProtocolDataProvider.getReserveTokensAddresses(underlying);\n\t\t\t\tif (aTokenAddress == address(0)) revert IncompatibleToken();\n\t\t\t} catch {\n\t\t\t\t// _rewardsToken is not an rToken, do nothing\n\t\t\t}\n\t\t}\n\t\tmultiFeeDistribution.addReward(_rewardsToken);\n\t\tisRewardToken[_rewardsToken] = true;\n\t\temit RewardsUpdated(_rewardsToken);\n\t}\n\n\t/**\n\t * @notice Remove an existing reward token\n\t */\n\tfunction removeReward(address _rewardsToken) external onlyAdminOrOwner {\n\t\tif (_rewardsToken == address(0)) revert ZeroAddress();\n\t\tmultiFeeDistribution.removeReward(_rewardsToken);\n\t\tisRewardToken[_rewardsToken] = false;\n\t\temit RewardsUpdated(_rewardsToken);\n\t}\n\n\t/**\n\t * @notice Run by MFD to pull pending platform revenue\n\t * @param _rewardTokens an array of reward token addresses\n\t */\n\tfunction forwardReward(address[] memory _rewardTokens) external {\n\t\tif (msg.sender != address(multiFeeDistribution)) revert NotMFD();\n\n\t\tuint256 length = _rewardTokens.length;\n\t\tfor (uint256 i = 0; i < length; ) {\n\t\t\taddress rewardToken = _rewardTokens[i];\n\t\t\tuint256 total = IERC20(rewardToken).balanceOf(address(this));\n\n\t\t\tif (operationExpenses != address(0) && operationExpenseRatio != 0) {\n\t\t\t\tuint256 opExAmount = (total * operationExpenseRatio) / RATIO_DIVISOR;\n\t\t\t\tif (opExAmount != 0) {\n\t\t\t\t\tIERC20(rewardToken).safeTransfer(operationExpenses, opExAmount);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttotal = IERC20(rewardToken).balanceOf(address(this));\n\t\t\tIERC20(rewardToken).safeTransfer(address(multiFeeDistribution), total);\n\n\t\t\tif (rewardToken == address(prntToken)) {\n\t\t\t\tmultiFeeDistribution.vestTokens(address(multiFeeDistribution), total, false);\n\t\t\t}\n\n\t\t\temit ForwardReward(rewardToken, total);\n\n\t\t\t_emitNewTransferAdded(rewardToken, total);\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Returns PRNT token address.\n\t * @return PRNT token address\n\t */\n\tfunction getPrntTokenAddress() external view returns (address) {\n\t\treturn address(prntToken);\n\t}\n\n\t/**\n\t * @notice Returns MFD address.\n\t * @return MFD address\n\t */\n\tfunction getMultiFeeDistributionAddress() external view returns (address) {\n\t\treturn address(multiFeeDistribution);\n\t}\n\n\t/**\n\t * @notice Emit event for new asset reward\n\t * @param asset address of transfer assset\n\t * @param lpReward amount of rewards\n\t */\n\tfunction _emitNewTransferAdded(address asset, uint256 lpReward) internal {\n\t\tuint256 lpUsdValue;\n\t\tif (asset != address(prntToken)) {\n\t\t\ttry IAToken(asset).UNDERLYING_ASSET_ADDRESS() returns (address underlyingAddress) {\n\t\t\t\tif (underlyingAddress != address(prntToken)) {\n\t\t\t\t\tuint256 assetPrice = IAaveOracle(_aaveOracle).getAssetPrice(underlyingAddress);\n\t\t\t\t\taddress sourceOfAsset = IAaveOracle(_aaveOracle).getSourceOfAsset(underlyingAddress);\n\t\t\t\t\tuint8 priceDecimal = IChainlinkAggregator(sourceOfAsset).decimals();\n\t\t\t\t\tuint8 assetDecimals = IERC20Metadata(asset).decimals();\n\t\t\t\t\tlpUsdValue = (assetPrice * lpReward * (10 ** DECIMALS)) / (10 ** priceDecimal) / (10 ** assetDecimals);\n\t\t\t\t} else {\n\t\t\t\t\tuint256 assetPrice = IPriceProvider(IMintableToken(prntToken).priceProvider()).getTokenPriceUsd();\n\t\t\t\t\tuint256 priceDecimal = IPriceProvider(IMintableToken(prntToken).priceProvider()).decimals();\n\t\t\t\t\tuint8 assetDecimals = IERC20Metadata(asset).decimals();\n\t\t\t\t\tlpUsdValue = (assetPrice * lpReward * (10 ** DECIMALS)) / (10 ** priceDecimal) / (10 ** assetDecimals);\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\tuint256 assetPrice = IAaveOracle(_aaveOracle).getAssetPrice(asset);\n\t\t\t\taddress sourceOfAsset = IAaveOracle(_aaveOracle).getSourceOfAsset(asset);\n\t\t\t\tuint8 priceDecimal = IChainlinkAggregator(sourceOfAsset).decimals();\n\t\t\t\tuint8 assetDecimals = IERC20Metadata(asset).decimals();\n\t\t\t\tlpUsdValue = (assetPrice * lpReward * (10 ** DECIMALS)) / (10 ** priceDecimal) / (10 ** assetDecimals);\n\t\t\t}\n\t\t\temit NewTransferAdded(asset, lpUsdValue);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Added to support recovering any ERC20 tokens inside the contract\n\t * @param tokenAddress address of erc20 token to recover\n\t * @param tokenAmount amount to recover\n\t */\n\tfunction recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n\t\t_recoverERC20(tokenAddress, tokenAmount);\n\t}\n}\n"
    },
    "contracts/prime/staking/MultiFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {RecoverERC20} from \"../libraries/RecoverERC20.sol\";\nimport {IChefIncentivesController} from \"../../interfaces/IChefIncentivesController.sol\";\nimport {IMiddleFeeDistribution} from \"../../interfaces/IMiddleFeeDistribution.sol\";\nimport {IBountyManager} from \"../../interfaces/IBountyManager.sol\";\nimport {IMultiFeeDistribution, IFeeDistribution} from \"../../interfaces/IMultiFeeDistribution.sol\";\nimport {IMintableToken} from \"../../interfaces/IMintableToken.sol\";\nimport {LockedBalance, Balances, Reward, EarnedBalance} from \"../../interfaces/LockedBalance.sol\";\nimport {IPriceProvider} from \"../../interfaces/IPriceProvider.sol\";\n\n/// @title Multi Fee Distribution Contract\n/// @author Prime\ncontract MultiFeeDistribution is\n\tIMultiFeeDistribution,\n\tInitializable,\n\tPausableUpgradeable,\n\tOwnableUpgradeable,\n\tRecoverERC20\n{\n\tusing SafeERC20 for IERC20;\n\tusing SafeERC20 for IMintableToken;\n\n\taddress private _priceProvider;\n\n\t/********************** Constants ***********************/\n\n\tuint256 public constant QUART = 25000; //  25%\n\tuint256 public constant HALF = 65000; //  65%\n\tuint256 public constant WHOLE = 100000; // 100%\n\n\t// Maximum slippage allowed to be set by users (used for compounding).\n\tuint256 public constant MAX_SLIPPAGE = 9500; //5%\n\tuint256 public constant PERCENT_DIVISOR = 10000; //100%\n\n\t/// @notice Proportion of burn amount\n\tuint256 public burn;\n\n\t/// @notice Duration that rewards are streamed over\n\tuint256 public rewardsDuration;\n\n\t/// @notice Duration that rewards loop back\n\tuint256 public rewardsLookback;\n\n\t/// @notice Default lock index\n\tuint256 public constant DEFAULT_LOCK_INDEX = 1;\n\n\t/// @notice Duration of lock/earned penalty period, used for earnings\n\tuint256 public defaultLockDuration;\n\n\t/// @notice Duration of vesting PRNT\n\tuint256 public vestDuration;\n\n\t/// @notice Returns reward converter\n\taddress public rewardConverter;\n\n\t/********************** Contract Addresses ***********************/\n\n\t/// @notice Address of Middle Fee Distribution Contract\n\tIMiddleFeeDistribution public middleFeeDistribution;\n\n\t/// @notice Address of CIC contract\n\tIChefIncentivesController public incentivesController;\n\n\t/// @notice Address of PRNT\n\tIMintableToken public prntToken;\n\n\t/// @notice Address of LP token\n\taddress public stakingToken;\n\n\t// Address of Lock Zapper\n\taddress internal _lockZap;\n\n\t/********************** Lock & Earn Info ***********************/\n\n\t// Private mappings for balance data\n\tmapping(address => Balances) private _balances;\n\tmapping(address => LockedBalance[]) internal _userLocks;\n\tmapping(address => LockedBalance[]) private _userEarnings;\n\tmapping(address => bool) public autocompoundEnabled;\n\tmapping(address => uint256) public lastAutocompound;\n\n\t/// @notice Total locked value\n\tuint256 public lockedSupply;\n\n\t/// @notice Total locked value in multipliers\n\tuint256 public lockedSupplyWithMultiplier;\n\n\t// Time lengths\n\tuint256[] internal _lockPeriod;\n\n\t// Multipliers\n\tuint256[] internal _rewardMultipliers;\n\n\t/********************** Reward Info ***********************/\n\n\t/// @notice Reward tokens being distributed\n\taddress[] public rewardTokens;\n\n\t/// @notice Reward data per token\n\tmapping(address => Reward) public rewardData;\n\n\t/// @notice user -> reward token -> rpt; RPT for paid amount\n\tmapping(address => mapping(address => uint256)) public userRewardPerTokenPaid;\n\n\t/// @notice user -> reward token -> amount; used to store reward amount\n\tmapping(address => mapping(address => uint256)) public rewards;\n\n\t/********************** Other Info ***********************/\n\n\t/// @notice DAO wallet\n\taddress public daoTreasury;\n\n\t/// @notice treasury wallet\n\taddress public starfleetTreasury;\n\n\t/// @notice Addresses approved to call mint\n\tmapping(address => bool) public minters;\n\n\t// Addresses to relock\n\tmapping(address => bool) public autoRelockDisabled;\n\n\t// Default lock index for relock\n\tmapping(address => uint256) public defaultLockIndex;\n\n\t/// @notice Flag to prevent more minter addings\n\tbool public mintersAreSet;\n\n\t/// @notice Last claim time of the user\n\tmapping(address => uint256) public lastClaimTime;\n\n\t/// @notice Bounty manager contract\n\taddress public bountyManager;\n\n\t/// @notice Maximum slippage for each trade excepted by the individual user when performing compound trades\n\tmapping(address => uint256) public userSlippage;\n\n\t/********************** Events ***********************/\n\n\tevent Locked(address indexed user, uint256 amount, uint256 lockedBalance, uint256 indexed lockLength, bool isLP);\n\tevent Withdrawn(\n\t\taddress indexed user,\n\t\tuint256 receivedAmount,\n\t\tuint256 lockedBalance,\n\t\tuint256 penalty,\n\t\tuint256 burn,\n\t\tbool isLP\n\t);\n\tevent RewardPaid(address indexed user, address indexed rewardToken, uint256 reward);\n\tevent Relocked(address indexed user, uint256 amount, uint256 lockIndex);\n\tevent BountyManagerUpdated(address indexed _bounty);\n\tevent RewardConverterUpdated(address indexed _rewardConverter);\n\tevent LockTypeInfoUpdated(uint256[] lockPeriod, uint256[] rewardMultipliers);\n\tevent AddressesUpdated(\n\t\tIChefIncentivesController _controller,\n\t\tIMiddleFeeDistribution _middleFeeDistribution,\n\t\taddress indexed _treasury\n\t);\n\tevent LPTokenUpdated(address indexed _stakingToken);\n\tevent RewardAdded(address indexed _rewardToken);\n\tevent LockerAdded(address indexed locker);\n\tevent LockerRemoved(address indexed locker);\n\n\t/********************** Errors ***********************/\n\terror AddressZero();\n\terror AmountZero();\n\terror InvalidBurn();\n\terror InvalidLookback();\n\terror MintersSet();\n\terror InvalidLockPeriod();\n\terror InsufficientPermission();\n\terror AlreadyAdded();\n\terror AlreadySet();\n\terror InvalidType();\n\terror ActiveReward();\n\terror InvalidAmount();\n\terror InvalidEarned();\n\terror InvalidTime();\n\terror InvalidPeriod();\n\terror UnlockTimeNotFound();\n\terror InvalidAddress();\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @dev Initializer\n\t *  First reward MUST be the PRNT token or things will break\n\t *  related to the 50% penalty and distribution to locked balances.\n\t * @param prntToken_ PRNT token address\n\t * @param lockZap_ LockZap contract address\n\t * @param dao_ DAO address\n\t * @param priceProvider_ PriceProvider contract address\n\t * @param rewardsDuration_ Duration that rewards are streamed over\n\t * @param rewardsLookback_ Duration that rewards loop back\n\t * @param lockDuration_ lock duration\n\t * @param burnRatio_ Proportion of burn amount\n\t * @param vestDuration_ vest duration\n\t */\n\tfunction initialize(\n\t\taddress prntToken_,\n\t\taddress lockZap_,\n\t\taddress dao_,\n\t\taddress priceProvider_,\n\t\tuint256 rewardsDuration_,\n\t\tuint256 rewardsLookback_,\n\t\tuint256 lockDuration_,\n\t\tuint256 burnRatio_,\n\t\tuint256 vestDuration_\n\t) public initializer {\n\t\tif (prntToken_ == address(0)) revert AddressZero();\n\t\tif (lockZap_ == address(0)) revert AddressZero();\n\t\tif (dao_ == address(0)) revert AddressZero();\n\t\tif (priceProvider_ == address(0)) revert AddressZero();\n\t\tif (rewardsDuration_ == uint256(0)) revert AmountZero();\n\t\tif (rewardsLookback_ == uint256(0)) revert AmountZero();\n\t\tif (lockDuration_ == uint256(0)) revert AmountZero();\n\t\tif (vestDuration_ == uint256(0)) revert AmountZero();\n\t\tif (burnRatio_ > WHOLE) revert InvalidBurn();\n\t\tif (rewardsLookback_ > rewardsDuration_) revert InvalidLookback();\n\n\t\t__Pausable_init();\n\t\t__Ownable_init();\n\n\t\tprntToken = IMintableToken(prntToken_);\n\t\t_lockZap = lockZap_;\n\t\tdaoTreasury = dao_;\n\t\t_priceProvider = priceProvider_;\n\t\trewardTokens.push(prntToken_);\n\t\trewardData[prntToken_].lastUpdateTime = block.timestamp;\n\n\t\trewardsDuration = rewardsDuration_;\n\t\trewardsLookback = rewardsLookback_;\n\t\tdefaultLockDuration = lockDuration_;\n\t\tburn = burnRatio_;\n\t\tvestDuration = vestDuration_;\n\t}\n\n\t/********************** Setters ***********************/\n\n\t/**\n\t * @notice Set minters\n\t * @dev Can be called only once\n\t * @param minters_ array of address\n\t */\n\tfunction setMinters(address[] calldata minters_) external onlyOwner {\n\t\tif (mintersAreSet) revert MintersSet();\n\t\tuint256 length = minters_.length;\n\t\tfor (uint256 i; i < length; ) {\n\t\t\tif (minters_[i] == address(0)) revert AddressZero();\n\t\t\tminters[minters_[i]] = true;\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tmintersAreSet = true;\n\t}\n\n\t/**\n\t * @notice Sets bounty manager contract.\n\t * @param bounty contract address\n\t */\n\tfunction setBountyManager(address bounty) external onlyOwner {\n\t\tif (bounty == address(0)) revert AddressZero();\n\t\tbountyManager = bounty;\n\t\tminters[bounty] = true;\n\t\temit BountyManagerUpdated(bounty);\n\t}\n\n\t/**\n\t * @notice Sets reward converter contract.\n\t * @param rewardConverter_ contract address\n\t */\n\tfunction addRewardConverter(address rewardConverter_) external onlyOwner {\n\t\tif (rewardConverter_ == address(0)) revert AddressZero();\n\t\trewardConverter = rewardConverter_;\n\t\temit RewardConverterUpdated(rewardConverter_);\n\t}\n\n\t/**\n\t * @notice Sets lock period and reward multipliers.\n\t * @param lockPeriod_ lock period array\n\t * @param rewardMultipliers_ multipliers per lock period\n\t */\n\tfunction setLockTypeInfo(uint256[] calldata lockPeriod_, uint256[] calldata rewardMultipliers_) external onlyOwner {\n\t\tif (lockPeriod_.length != rewardMultipliers_.length) revert InvalidLockPeriod();\n\t\tdelete _lockPeriod;\n\t\tdelete _rewardMultipliers;\n\t\tuint256 length = lockPeriod_.length;\n\t\tfor (uint256 i; i < length; ) {\n\t\t\t_lockPeriod.push(lockPeriod_[i]);\n\t\t\t_rewardMultipliers.push(rewardMultipliers_[i]);\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\temit LockTypeInfoUpdated(lockPeriod_, rewardMultipliers_);\n\t}\n\n\t/**\n\t * @notice Set CIC, MFD and Treasury.\n\t * @param controller_ CIC address\n\t * @param middleFeeDistribution_ address\n\t * @param treasury_ address\n\t */\n\tfunction setAddresses(\n\t\tIChefIncentivesController controller_,\n\t\tIMiddleFeeDistribution middleFeeDistribution_,\n\t\taddress treasury_\n\t) external onlyOwner {\n\t\tif (address(controller_) == address(0)) revert AddressZero();\n\t\tif (address(middleFeeDistribution_) == address(0)) revert AddressZero();\n\t\tincentivesController = controller_;\n\t\tmiddleFeeDistribution = middleFeeDistribution_;\n\t\tstarfleetTreasury = treasury_;\n\t\temit AddressesUpdated(controller_, middleFeeDistribution_, treasury_);\n\t}\n\n\t/**\n\t * @notice Set LP token.\n\t * @param stakingToken_ LP token address\n\t */\n\tfunction setLPToken(address stakingToken_) external onlyOwner {\n\t\tif (stakingToken_ == address(0)) revert AddressZero();\n\t\tif (stakingToken != address(0)) revert AlreadySet();\n\t\tstakingToken = stakingToken_;\n\t\temit LPTokenUpdated(stakingToken_);\n\t}\n\n\t/**\n\t * @notice Add a new reward token to be distributed to stakers.\n\t * @param rewardToken address\n\t */\n\tfunction addReward(address rewardToken) external {\n\t\tif (rewardToken == address(0)) revert AddressZero();\n\t\tif (!minters[msg.sender]) revert InsufficientPermission();\n\t\tif (rewardData[rewardToken].lastUpdateTime != 0) revert AlreadyAdded();\n\t\trewardTokens.push(rewardToken);\n\n\t\tReward storage rd = rewardData[rewardToken];\n\t\trd.lastUpdateTime = block.timestamp;\n\t\trd.periodFinish = block.timestamp;\n\n\t\temit RewardAdded(rewardToken);\n\t}\n\n\t/**\n\t * @notice Remove an existing reward token.\n\t * @param _rewardToken address to be removed\n\t */\n\tfunction removeReward(address _rewardToken) external {\n\t\tif (!minters[msg.sender]) revert InsufficientPermission();\n\n\t\tbool isTokenFound;\n\t\tuint256 indexToRemove;\n\n\t\tuint256 length = rewardTokens.length;\n\t\tfor (uint256 i; i < length; i++) {\n\t\t\tif (rewardTokens[i] == _rewardToken) {\n\t\t\t\tisTokenFound = true;\n\t\t\t\tindexToRemove = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!isTokenFound) revert InvalidAddress();\n\n\t\t// Reward token order is changed, but that doesn't have an impact\n\t\tif (indexToRemove < length - 1) {\n\t\t\trewardTokens[indexToRemove] = rewardTokens[length - 1];\n\t\t}\n\n\t\trewardTokens.pop();\n\n\t\t// Scrub historical reward token data\n\t\tReward storage rd = rewardData[_rewardToken];\n\t\trd.lastUpdateTime = 0;\n\t\trd.periodFinish = 0;\n\t\trd.balance = 0;\n\t\trd.rewardPerSecond = 0;\n\t\trd.rewardPerTokenStored = 0;\n\t}\n\n\t/**\n\t * @notice Set default lock type index for user relock.\n\t * @param index of default lock length\n\t */\n\tfunction setDefaultRelockTypeIndex(uint256 index) external {\n\t\tif (index >= _lockPeriod.length) revert InvalidType();\n\t\tdefaultLockIndex[msg.sender] = index;\n\t}\n\n\t/**\n\t * @notice Sets option if auto compound is enabled.\n\t * @param status true if auto compounding is enabled.\n\t * @param slippage the maximum amount of slippage that the user will incur for each compounding trade\n\t */\n\tfunction setAutocompound(bool status, uint256 slippage) external {\n\t\tautocompoundEnabled[msg.sender] = status;\n\t\tif (slippage < MAX_SLIPPAGE || slippage >= PERCENT_DIVISOR) {\n\t\t\trevert InvalidAmount();\n\t\t}\n\t\tuserSlippage[msg.sender] = slippage;\n\t}\n\n\t/**\n\t * @notice Set relock status\n\t * @param status true if auto relock is enabled.\n\t */\n\tfunction setRelock(bool status) external virtual {\n\t\tautoRelockDisabled[msg.sender] = !status;\n\t}\n\n\t/**\n\t * @notice Sets the lookback period\n\t * @param lookback in seconds\n\t */\n\tfunction setLookback(uint256 lookback) external onlyOwner {\n\t\tif (lookback == uint256(0)) revert AmountZero();\n\t\tif (lookback > rewardsDuration) revert InvalidLookback();\n\n\t\trewardsLookback = lookback;\n\t}\n\n\t/********************** External functions ***********************/\n\n\t/**\n\t * @notice Stake tokens to receive rewards.\n\t * @dev Locked tokens cannot be withdrawn for defaultLockDuration and are eligible to receive rewards.\n\t * @param amount to stake.\n\t * @param onBehalfOf address for staking.\n\t * @param typeIndex lock type index.\n\t */\n\tfunction stake(uint256 amount, address onBehalfOf, uint256 typeIndex) external {\n\t\t_stake(amount, onBehalfOf, typeIndex, false);\n\t}\n\n\t/**\n\t * @notice Add to earnings\n\t * @dev Minted tokens receive rewards normally but incur a 50% penalty when\n\t *  withdrawn before vestDuration has passed.\n\t * @param user vesting owner.\n\t * @param amount to vest.\n\t * @param withPenalty does this bear penalty?\n\t */\n\tfunction vestTokens(address user, uint256 amount, bool withPenalty) external whenNotPaused {\n\t\tif (!minters[msg.sender]) revert InsufficientPermission();\n\t\tif (amount == 0) return;\n\n\t\tif (user == address(this)) {\n\t\t\t// minting to this contract adds the new tokens as incentives for lockers\n\t\t\t_notifyReward(address(prntToken), amount);\n\t\t\treturn;\n\t\t}\n\n\t\tBalances storage bal = _balances[user];\n\t\tbal.total = bal.total + amount;\n\t\tif (withPenalty) {\n\t\t\tbal.earned = bal.earned + amount;\n\t\t\tLockedBalance[] storage earnings = _userEarnings[user];\n\n\t\t\tuint256 currentDay = block.timestamp / 1 days;\n\t\t\tuint256 lastIndex = earnings.length > 0 ? earnings.length - 1 : 0;\n\t\t\tuint256 vestingDurationDays = vestDuration / 1 days;\n\n\t\t\t// We check if an entry for the current day already exists. If yes, add new amount to that entry\n\t\t\tif (earnings.length > 0 && (earnings[lastIndex].unlockTime / 1 days) == currentDay + vestingDurationDays) {\n\t\t\t\tearnings[lastIndex].amount = earnings[lastIndex].amount + amount;\n\t\t\t} else {\n\t\t\t\t// If there is no entry for the current day, create a new one\n\t\t\t\tuint256 unlockTime = block.timestamp + vestDuration;\n\t\t\t\tearnings.push(\n\t\t\t\t\tLockedBalance({amount: amount, unlockTime: unlockTime, multiplier: 1, duration: vestDuration})\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tbal.unlocked = bal.unlocked + amount;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Withdraw tokens from earnings and unlocked.\n\t * @dev First withdraws unlocked tokens, then earned tokens. Withdrawing earned tokens\n\t *  incurs a 50% penalty which is distributed based on locked balances.\n\t * @param amount for withdraw\n\t */\n\tfunction withdraw(uint256 amount) external {\n\t\taddress _address = msg.sender;\n\t\tif (amount == 0) revert AmountZero();\n\n\t\tuint256 penaltyAmount;\n\t\tuint256 burnAmount;\n\t\tBalances storage bal = _balances[_address];\n\n\t\tif (amount <= bal.unlocked) {\n\t\t\tbal.unlocked = bal.unlocked - amount;\n\t\t} else {\n\t\t\tuint256 remaining = amount - bal.unlocked;\n\t\t\tif (bal.earned < remaining) revert InvalidEarned();\n\t\t\tbal.unlocked = 0;\n\t\t\tuint256 sumEarned = bal.earned;\n\t\t\tuint256 i;\n\t\t\tfor (i = 0; ; ) {\n\t\t\t\tuint256 earnedAmount = _userEarnings[_address][i].amount;\n\t\t\t\tif (earnedAmount == 0) continue;\n\t\t\t\t(\n\t\t\t\t\tuint256 withdrawAmount,\n\t\t\t\t\tuint256 penaltyFactor,\n\t\t\t\t\tuint256 newPenaltyAmount,\n\t\t\t\t\tuint256 newBurnAmount\n\t\t\t\t) = _penaltyInfo(_userEarnings[_address][i]);\n\n\t\t\t\tuint256 requiredAmount = earnedAmount;\n\t\t\t\tif (remaining >= withdrawAmount) {\n\t\t\t\t\tremaining = remaining - withdrawAmount;\n\t\t\t\t\tif (remaining == 0) i++;\n\t\t\t\t} else {\n\t\t\t\t\trequiredAmount = (remaining * WHOLE) / (WHOLE - penaltyFactor);\n\t\t\t\t\t_userEarnings[_address][i].amount = earnedAmount - requiredAmount;\n\t\t\t\t\tremaining = 0;\n\n\t\t\t\t\tnewPenaltyAmount = (requiredAmount * penaltyFactor) / WHOLE;\n\t\t\t\t\tnewBurnAmount = (newPenaltyAmount * burn) / WHOLE;\n\t\t\t\t}\n\t\t\t\tsumEarned = sumEarned - requiredAmount;\n\n\t\t\t\tpenaltyAmount = penaltyAmount + newPenaltyAmount;\n\t\t\t\tburnAmount = burnAmount + newBurnAmount;\n\n\t\t\t\tif (remaining == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tif (sumEarned == 0) revert InvalidEarned();\n\t\t\t\t}\n\t\t\t\tunchecked {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i > 0) {\n\t\t\t\tuint256 length = _userEarnings[_address].length;\n\t\t\t\tfor (uint256 j = i; j < length; ) {\n\t\t\t\t\t_userEarnings[_address][j - i] = _userEarnings[_address][j];\n\t\t\t\t\tunchecked {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (uint256 j = 0; j < i; ) {\n\t\t\t\t\t_userEarnings[_address].pop();\n\t\t\t\t\tunchecked {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbal.earned = sumEarned;\n\t\t}\n\n\t\t// Update values\n\t\tbal.total = bal.total - amount - penaltyAmount;\n\n\t\t_withdrawTokens(_address, amount, penaltyAmount, burnAmount, false);\n\t}\n\n\t/**\n\t * @notice Withdraw individual unlocked balance and earnings, optionally claim pending rewards.\n\t * @param claimRewards true to claim rewards when exit\n\t * @param unlockTime of earning\n\t */\n\tfunction individualEarlyExit(bool claimRewards, uint256 unlockTime) external {\n\t\taddress onBehalfOf = msg.sender;\n\t\tif (unlockTime <= block.timestamp) revert InvalidTime();\n\t\t(uint256 amount, uint256 penaltyAmount, uint256 burnAmount, uint256 index) = _ieeWithdrawableBalance(\n\t\t\tonBehalfOf,\n\t\t\tunlockTime\n\t\t);\n\n\t\tuint256 length = _userEarnings[onBehalfOf].length;\n\t\tfor (uint256 i = index + 1; i < length; ) {\n\t\t\t_userEarnings[onBehalfOf][i - 1] = _userEarnings[onBehalfOf][i];\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\t_userEarnings[onBehalfOf].pop();\n\n\t\tBalances storage bal = _balances[onBehalfOf];\n\t\tbal.total = bal.total - amount - penaltyAmount;\n\t\tbal.earned = bal.earned - amount - penaltyAmount;\n\n\t\t_withdrawTokens(onBehalfOf, amount, penaltyAmount, burnAmount, claimRewards);\n\t}\n\n\t/**\n\t * @notice Withdraw full unlocked balance and earnings, optionally claim pending rewards.\n\t * @param claimRewards true to claim rewards when exit\n\t */\n\tfunction exit(bool claimRewards) external {\n\t\taddress onBehalfOf = msg.sender;\n\t\t(uint256 amount, uint256 penaltyAmount, uint256 burnAmount) = withdrawableBalance(onBehalfOf);\n\n\t\tdelete _userEarnings[onBehalfOf];\n\n\t\tBalances storage bal = _balances[onBehalfOf];\n\t\tbal.total = bal.total - bal.unlocked - bal.earned;\n\t\tbal.unlocked = 0;\n\t\tbal.earned = 0;\n\n\t\t_withdrawTokens(onBehalfOf, amount, penaltyAmount, burnAmount, claimRewards);\n\t}\n\n\t/**\n\t * @notice Claim all pending staking rewards.\n\t */\n\tfunction getAllRewards() external {\n\t\treturn getReward(rewardTokens);\n\t}\n\n\t/**\n\t * @notice Withdraw expired locks with options\n\t * @param address_ for withdraw\n\t * @param limit_ of lock length for withdraw\n\t * @param isRelockAction_ option to relock\n\t * @return withdraw amount\n\t */\n\tfunction withdrawExpiredLocksForWithOptions(\n\t\taddress address_,\n\t\tuint256 limit_,\n\t\tbool isRelockAction_\n\t) external returns (uint256) {\n\t\tif (limit_ == 0) limit_ = _userLocks[address_].length;\n\n\t\treturn _withdrawExpiredLocksFor(address_, isRelockAction_, true, limit_);\n\t}\n\n\t/**\n\t * @notice Zap vesting PRNT tokens to LP\n\t * @param user address\n\t * @return zapped amount\n\t */\n\tfunction zapVestingToLp(address user) external returns (uint256 zapped) {\n\t\tif (msg.sender != _lockZap) revert InsufficientPermission();\n\n\t\t_updateReward(user);\n\n\t\tuint256 currentTimestamp = block.timestamp;\n\t\tLockedBalance[] storage earnings = _userEarnings[user];\n\t\tfor (uint256 i = earnings.length; i > 0; ) {\n\t\t\tif (earnings[i - 1].unlockTime > currentTimestamp) {\n\t\t\t\tzapped = zapped + earnings[i - 1].amount;\n\t\t\t\tearnings.pop();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tprntToken.safeTransfer(_lockZap, zapped);\n\n\t\tBalances storage bal = _balances[user];\n\t\tbal.earned = bal.earned - zapped;\n\t\tbal.total = bal.total - zapped;\n\n\t\tIPriceProvider(_priceProvider).update();\n\n\t\treturn zapped;\n\t}\n\n\t/**\n\t * @notice Claim rewards by converter.\n\t * @dev Rewards are transfered to converter. In the Prime Capital protocol\n\t * \t\tthe role of the Converter is taken over by Compounder.sol.\n\t * @param onBehalf address to claim.\n\t */\n\tfunction claimFromConverter(address onBehalf) external whenNotPaused {\n\t\tif (msg.sender != rewardConverter) revert InsufficientPermission();\n\t\t_updateReward(onBehalf);\n\t\tmiddleFeeDistribution.forwardReward(rewardTokens);\n\t\tuint256 length = rewardTokens.length;\n\t\tfor (uint256 i; i < length; ) {\n\t\t\taddress token = rewardTokens[i];\n\t\t\tif (token != address(prntToken)) {\n\t\t\t\t_notifyUnseenReward(token);\n\t\t\t\tuint256 reward = rewards[onBehalf][token] / 1e12;\n\t\t\t\tif (reward > 0) {\n\t\t\t\t\trewards[onBehalf][token] = 0;\n\t\t\t\t\trewardData[token].balance = rewardData[token].balance - reward;\n\n\t\t\t\t\tIERC20(token).safeTransfer(rewardConverter, reward);\n\t\t\t\t\temit RewardPaid(onBehalf, token, reward);\n\t\t\t\t}\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tIPriceProvider(_priceProvider).update();\n\t\tlastClaimTime[onBehalf] = block.timestamp;\n\t}\n\n\t/**\n\t * @notice Withdraw and restake assets.\n\t */\n\tfunction relock() external virtual {\n\t\tuint256 amount = _withdrawExpiredLocksFor(msg.sender, true, true, _userLocks[msg.sender].length);\n\t\temit Relocked(msg.sender, amount, defaultLockIndex[msg.sender]);\n\t}\n\n\t/**\n\t * @notice Requalify user\n\t */\n\tfunction requalify() external {\n\t\trequalifyFor(msg.sender);\n\t}\n\n\t/**\n\t * @notice Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders.\n\t * @param tokenAddress to recover.\n\t * @param tokenAmount to recover.\n\t */\n\tfunction recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n\t\t_recoverERC20(tokenAddress, tokenAmount);\n\t}\n\n\t/********************** External View functions ***********************/\n\n\t/**\n\t * @notice Return lock duration.\n\t */\n\tfunction getLockDurations() external view returns (uint256[] memory) {\n\t\treturn _lockPeriod;\n\t}\n\n\t/**\n\t * @notice Return reward multipliers.\n\t */\n\tfunction getLockMultipliers() external view returns (uint256[] memory) {\n\t\treturn _rewardMultipliers;\n\t}\n\n\t/**\n\t * @notice Returns all locks of a user.\n\t * @param user address.\n\t * @return lockInfo of the user.\n\t */\n\tfunction lockInfo(address user) external view returns (LockedBalance[] memory) {\n\t\treturn _userLocks[user];\n\t}\n\n\t/**\n\t * @notice Total balance of an account, including unlocked, locked and earned tokens.\n\t * @param user address.\n\t */\n\tfunction totalBalance(address user) external view returns (uint256) {\n\t\tif (stakingToken == address(prntToken)) {\n\t\t\treturn _balances[user].total;\n\t\t}\n\t\treturn _balances[user].locked;\n\t}\n\n\t/**\n\t * @notice Returns price provider address\n\t */\n\tfunction getPriceProvider() external view returns (address) {\n\t\treturn _priceProvider;\n\t}\n\n\t/**\n\t * @notice Reward amount of the duration.\n\t * @param rewardToken for the reward\n\t * @return reward amount for duration\n\t */\n\tfunction getRewardForDuration(address rewardToken) external view returns (uint256) {\n\t\treturn (rewardData[rewardToken].rewardPerSecond * rewardsDuration) / 1e12;\n\t}\n\n\t/**\n\t * @notice Total balance of an account, including unlocked, locked and earned tokens.\n\t * @param user address of the user for which the balances are fetched\n\t */\n\tfunction getBalances(address user) external view returns (Balances memory) {\n\t\treturn _balances[user];\n\t}\n\n\t/********************** Public functions ***********************/\n\n\t/**\n\t * @notice Claims bounty.\n\t * @dev Remove expired locks\n\t * @param user address\n\t * @param execute true if this is actual execution\n\t * @return issueBaseBounty true if needs to issue base bounty\n\t */\n\tfunction claimBounty(address user, bool execute) public whenNotPaused returns (bool issueBaseBounty) {\n\t\tif (msg.sender != address(bountyManager)) revert InsufficientPermission();\n\n\t\t(, uint256 unlockable, , , ) = lockedBalances(user);\n\t\tif (unlockable == 0) {\n\t\t\treturn (false);\n\t\t} else {\n\t\t\tissueBaseBounty = true;\n\t\t}\n\n\t\tif (!execute) {\n\t\t\treturn (issueBaseBounty);\n\t\t}\n\t\t// Withdraw the user's expried locks\n\t\t_withdrawExpiredLocksFor(user, false, true, _userLocks[user].length);\n\t}\n\n\t/**\n\t * @notice Claim all pending staking rewards.\n\t * @param rewardTokens_ array of reward tokens\n\t */\n\tfunction getReward(address[] memory rewardTokens_) public {\n\t\t_updateReward(msg.sender);\n\t\t_getReward(msg.sender, rewardTokens_);\n\t\tIPriceProvider(_priceProvider).update();\n\t}\n\n\t/**\n\t * @notice Pause MFD functionalities\n\t */\n\tfunction pause() public onlyOwner {\n\t\t_pause();\n\t}\n\n\t/**\n\t * @notice Resume MFD functionalities\n\t */\n\tfunction unpause() public onlyOwner {\n\t\t_unpause();\n\t}\n\n\t/**\n\t * @notice Requalify user for reward elgibility\n\t * @param user address\n\t */\n\tfunction requalifyFor(address user) public {\n\t\tincentivesController.afterLockUpdate(user);\n\t}\n\n\t/**\n\t * @notice Information on a user's lockings\n\t * @return total balance of locks\n\t * @return unlockable balance\n\t * @return locked balance\n\t * @return lockedWithMultiplier\n\t * @return lockData which is an array of locks\n\t */\n\tfunction lockedBalances(\n\t\taddress user\n\t)\n\t\tpublic\n\t\tview\n\t\treturns (\n\t\t\tuint256 total,\n\t\t\tuint256 unlockable,\n\t\t\tuint256 locked,\n\t\t\tuint256 lockedWithMultiplier,\n\t\t\tLockedBalance[] memory lockData\n\t\t)\n\t{\n\t\tLockedBalance[] storage locks = _userLocks[user];\n\t\tuint256 idx;\n\t\tuint256 length = locks.length;\n\t\tfor (uint256 i; i < length; ) {\n\t\t\tif (locks[i].unlockTime > block.timestamp) {\n\t\t\t\tif (idx == 0) {\n\t\t\t\t\tlockData = new LockedBalance[](locks.length - i);\n\t\t\t\t}\n\t\t\t\tlockData[idx] = locks[i];\n\t\t\t\tidx++;\n\t\t\t\tlocked = locked + locks[i].amount;\n\t\t\t\tlockedWithMultiplier = lockedWithMultiplier + (locks[i].amount * locks[i].multiplier);\n\t\t\t} else {\n\t\t\t\tunlockable = unlockable + locks[i].amount;\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\ttotal = _balances[user].locked;\n\t}\n\n\t/**\n\t * @notice Reward locked amount of the user.\n\t * @param user address\n\t * @return locked amount\n\t */\n\tfunction lockedBalance(address user) public view returns (uint256 locked) {\n\t\tLockedBalance[] storage locks = _userLocks[user];\n\t\tuint256 length = locks.length;\n\t\tuint256 currentTimestamp = block.timestamp;\n\t\tfor (uint256 i; i < length; ) {\n\t\t\tif (locks[i].unlockTime > currentTimestamp) {\n\t\t\t\tlocked = locked + locks[i].amount;\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Earnings which are vesting, and earnings which have vested for full duration.\n\t * @dev Earned balances may be withdrawn immediately, but will incur a penalty between 25-90%, based on a linear schedule of elapsed time.\n\t * @return totalVesting sum of vesting tokens\n\t * @return unlocked earnings\n\t * @return earningsData which is an array of all infos\n\t */\n\tfunction earnedBalances(\n\t\taddress user\n\t) public view returns (uint256 totalVesting, uint256 unlocked, EarnedBalance[] memory earningsData) {\n\t\tunlocked = _balances[user].unlocked;\n\t\tLockedBalance[] storage earnings = _userEarnings[user];\n\t\tuint256 idx;\n\t\tuint256 length = earnings.length;\n\t\tuint256 currentTimestamp = block.timestamp;\n\t\tfor (uint256 i; i < length; ) {\n\t\t\tif (earnings[i].unlockTime > currentTimestamp) {\n\t\t\t\tif (idx == 0) {\n\t\t\t\t\tearningsData = new EarnedBalance[](earnings.length - i);\n\t\t\t\t}\n\t\t\t\t(, uint256 penaltyAmount, , ) = _ieeWithdrawableBalance(user, earnings[i].unlockTime);\n\t\t\t\tearningsData[idx].amount = earnings[i].amount;\n\t\t\t\tearningsData[idx].unlockTime = earnings[i].unlockTime;\n\t\t\t\tearningsData[idx].penalty = penaltyAmount;\n\t\t\t\tidx++;\n\t\t\t\ttotalVesting = totalVesting + earnings[i].amount;\n\t\t\t} else {\n\t\t\t\tunlocked = unlocked + earnings[i].amount;\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn (totalVesting, unlocked, earningsData);\n\t}\n\n\t/**\n\t * @notice Final balance received and penalty balance paid by user upon calling exit.\n\t * @dev This is earnings, not locks.\n\t * @param user address.\n\t * @return amount total withdrawable amount.\n\t * @return penaltyAmount penalty amount.\n\t * @return burnAmount amount to burn.\n\t */\n\tfunction withdrawableBalance(\n\t\taddress user\n\t) public view returns (uint256 amount, uint256 penaltyAmount, uint256 burnAmount) {\n\t\tuint256 earned = _balances[user].earned;\n\t\tif (earned > 0) {\n\t\t\tuint256 length = _userEarnings[user].length;\n\t\t\tfor (uint256 i; i < length; ) {\n\t\t\t\tuint256 earnedAmount = _userEarnings[user][i].amount;\n\t\t\t\tif (earnedAmount == 0) continue;\n\t\t\t\t(, , uint256 newPenaltyAmount, uint256 newBurnAmount) = _penaltyInfo(_userEarnings[user][i]);\n\t\t\t\tpenaltyAmount = penaltyAmount + newPenaltyAmount;\n\t\t\t\tburnAmount = burnAmount + newBurnAmount;\n\t\t\t\tunchecked {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tamount = _balances[user].unlocked + earned - penaltyAmount;\n\t\treturn (amount, penaltyAmount, burnAmount);\n\t}\n\n\t/**\n\t * @notice Returns reward applicable timestamp.\n\t * @param rewardToken for the reward\n\t * @return end time of reward period\n\t */\n\tfunction lastTimeRewardApplicable(address rewardToken) public view returns (uint256) {\n\t\tuint256 periodFinish = rewardData[rewardToken].periodFinish;\n\t\treturn block.timestamp < periodFinish ? block.timestamp : periodFinish;\n\t}\n\n\t/**\n\t * @notice Reward amount per token\n\t * @dev Reward is distributed only for locks.\n\t * @param rewardToken for reward\n\t * @return rptStored current RPT with accumulated rewards\n\t */\n\tfunction rewardPerToken(address rewardToken) public view returns (uint256 rptStored) {\n\t\trptStored = rewardData[rewardToken].rewardPerTokenStored;\n\t\tif (lockedSupplyWithMultiplier > 0) {\n\t\t\tuint256 newReward = (lastTimeRewardApplicable(rewardToken) - rewardData[rewardToken].lastUpdateTime) *\n\t\t\t\trewardData[rewardToken].rewardPerSecond;\n\t\t\trptStored = rptStored + ((newReward * 1e18) / lockedSupplyWithMultiplier);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Address and claimable amount of all reward tokens for the given account.\n\t * @param account for rewards\n\t * @return rewardsData array of rewards\n\t */\n\tfunction claimableRewards(address account) public view returns (IFeeDistribution.RewardData[] memory rewardsData) {\n\t\trewardsData = new IFeeDistribution.RewardData[](rewardTokens.length);\n\n\t\tuint256 length = rewardTokens.length;\n\t\tfor (uint256 i; i < length; ) {\n\t\t\trewardsData[i].token = rewardTokens[i];\n\t\t\trewardsData[i].amount =\n\t\t\t\t_earned(\n\t\t\t\t\taccount,\n\t\t\t\t\trewardsData[i].token,\n\t\t\t\t\t_balances[account].lockedWithMultiplier,\n\t\t\t\t\trewardPerToken(rewardsData[i].token)\n\t\t\t\t) /\n\t\t\t\t1e12;\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn rewardsData;\n\t}\n\n\t/********************** Internal functions ***********************/\n\n\t/**\n\t * @notice Stake tokens to receive rewards.\n\t * @dev Locked tokens cannot be withdrawn for defaultLockDuration and are eligible to receive rewards.\n\t * @param amount to stake.\n\t * @param onBehalfOf address for staking.\n\t * @param typeIndex lock type index.\n\t * @param isRelock true if this is with relock enabled.\n\t */\n\tfunction _stake(uint256 amount, address onBehalfOf, uint256 typeIndex, bool isRelock) internal whenNotPaused {\n\t\tif (amount == 0) return;\n\t\tif (bountyManager != address(0)) {\n\t\t\tif (amount < IBountyManager(bountyManager).minDLPBalance()) revert InvalidAmount();\n\t\t}\n\t\tif (typeIndex >= _lockPeriod.length) revert InvalidType();\n\n\t\t_updateReward(onBehalfOf);\n\n\t\tLockedBalance[] memory userLocks = _userLocks[onBehalfOf];\n\t\tuint256 userLocksLength = userLocks.length;\n\n\t\tBalances storage bal = _balances[onBehalfOf];\n\t\tbal.total = bal.total + amount;\n\n\t\tbal.locked = bal.locked + amount;\n\t\tlockedSupply = lockedSupply + amount;\n\n\t\tuint256 rewardMultiplier = _rewardMultipliers[typeIndex];\n\t\tbal.lockedWithMultiplier = bal.lockedWithMultiplier + (amount * rewardMultiplier);\n\t\tlockedSupplyWithMultiplier = lockedSupplyWithMultiplier + (amount * rewardMultiplier);\n\n\t\tuint256 lockDurationDays = _lockPeriod[typeIndex] / 1 days;\n\t\tuint256 unlockTime = block.timestamp + (lockDurationDays * 1 days);\n\t\tuint256 lastIndex = userLocksLength > 0 ? userLocksLength - 1 : 0;\n\t\tif (userLocksLength > 0) {\n\t\t\tLockedBalance memory lastUserLock = userLocks[lastIndex];\n\t\t\tif (\n\t\t\t\t(lastUserLock.unlockTime / 1 days == (block.timestamp / 1 days) + lockDurationDays) &&\n\t\t\t\tlastUserLock.multiplier == rewardMultiplier\n\t\t\t) {\n\t\t\t\t_userLocks[onBehalfOf][lastIndex].amount = lastUserLock.amount + amount;\n\t\t\t} else {\n\t\t\t\t_insertLock(\n\t\t\t\t\tonBehalfOf,\n\t\t\t\t\tLockedBalance({\n\t\t\t\t\t\tamount: amount,\n\t\t\t\t\t\tunlockTime: unlockTime,\n\t\t\t\t\t\tmultiplier: rewardMultiplier,\n\t\t\t\t\t\tduration: _lockPeriod[typeIndex]\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t\temit LockerAdded(onBehalfOf);\n\t\t\t}\n\t\t} else {\n\t\t\t_insertLock(\n\t\t\t\tonBehalfOf,\n\t\t\t\tLockedBalance({\n\t\t\t\t\tamount: amount,\n\t\t\t\t\tunlockTime: unlockTime,\n\t\t\t\t\tmultiplier: rewardMultiplier,\n\t\t\t\t\tduration: _lockPeriod[typeIndex]\n\t\t\t\t})\n\t\t\t);\n\t\t\temit LockerAdded(onBehalfOf);\n\t\t}\n\n\t\tif (!isRelock) {\n\t\t\tIERC20(stakingToken).safeTransferFrom(msg.sender, address(this), amount);\n\t\t}\n\n\t\tincentivesController.afterLockUpdate(onBehalfOf);\n\t\temit Locked(\n\t\t\tonBehalfOf,\n\t\t\tamount,\n\t\t\t_balances[onBehalfOf].locked,\n\t\t\t_lockPeriod[typeIndex],\n\t\t\tstakingToken != address(prntToken)\n\t\t);\n\t}\n\n\t/**\n\t * @notice Add new lockings\n\t * @dev We keep the array to be sorted by unlock time.\n\t * @param user address of locker.\n\t * @param newLock new lock info.\n\t */\n\tfunction _insertLock(address user, LockedBalance memory newLock) internal {\n\t\tLockedBalance[] storage locks = _userLocks[user];\n\t\tuint256 length = locks.length;\n\t\tuint256 i = _binarySearch(locks, length, newLock.unlockTime);\n\t\tlocks.push();\n\t\tfor (uint256 j = length; j > i; ) {\n\t\t\tlocks[j] = locks[j - 1];\n\t\t\tunchecked {\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\tlocks[i] = newLock;\n\t}\n\n\t/**\n\t * @notice Update user reward info.\n\t * @param account address\n\t */\n\tfunction _updateReward(address account) internal {\n\t\tuint256 balance = _balances[account].lockedWithMultiplier;\n\t\tuint256 length = rewardTokens.length;\n\t\tfor (uint256 i = 0; i < length; ) {\n\t\t\taddress token = rewardTokens[i];\n\t\t\tuint256 rpt = rewardPerToken(token);\n\n\t\t\tReward storage r = rewardData[token];\n\t\t\tr.rewardPerTokenStored = rpt;\n\t\t\tr.lastUpdateTime = lastTimeRewardApplicable(token);\n\n\t\t\tif (account != address(this)) {\n\t\t\t\trewards[account][token] = _earned(account, token, balance, rpt);\n\t\t\t\tuserRewardPerTokenPaid[account][token] = rpt;\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Add new reward.\n\t * @dev If prev reward period is not done, then it resets `rewardPerSecond` and restarts period\n\t * @param rewardToken address\n\t * @param reward amount\n\t */\n\tfunction _notifyReward(address rewardToken, uint256 reward) internal {\n\t\tReward storage r = rewardData[rewardToken];\n\t\tif (block.timestamp >= r.periodFinish) {\n\t\t\tr.rewardPerSecond = (reward * 1e12) / rewardsDuration;\n\t\t} else {\n\t\t\tuint256 remaining = r.periodFinish - block.timestamp;\n\t\t\tuint256 leftover = (remaining * r.rewardPerSecond) / 1e12;\n\t\t\tr.rewardPerSecond = ((reward + leftover) * 1e12) / rewardsDuration;\n\t\t}\n\n\t\tr.lastUpdateTime = block.timestamp;\n\t\tr.periodFinish = block.timestamp + rewardsDuration;\n\t\tr.balance = r.balance + reward;\n\t}\n\n\t/**\n\t * @notice Notify unseen rewards.\n\t * @dev for rewards other than PRNT token, every 24 hours we check if new\n\t *  rewards were sent to the contract or accrued via aToken interest.\n\t * @param token address\n\t */\n\tfunction _notifyUnseenReward(address token) internal {\n\t\tif (token == address(0)) revert AddressZero();\n\t\tif (token == address(prntToken)) {\n\t\t\treturn;\n\t\t}\n\t\tReward storage r = rewardData[token];\n\t\tuint256 periodFinish = r.periodFinish;\n\t\tif (periodFinish == 0) revert InvalidPeriod();\n\t\tif (periodFinish < block.timestamp + rewardsDuration - rewardsLookback) {\n\t\t\tuint256 unseen = IERC20(token).balanceOf(address(this)) - r.balance;\n\t\t\tif (unseen > 0) {\n\t\t\t\t_notifyReward(token, unseen);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice User gets reward\n\t * @param user address\n\t * @param rewardTokens_ array of reward tokens\n\t */\n\tfunction _getReward(address user, address[] memory rewardTokens_) internal whenNotPaused {\n\t\tmiddleFeeDistribution.forwardReward(rewardTokens_);\n\t\tuint256 length = rewardTokens_.length;\n\t\tfor (uint256 i; i < length; ) {\n\t\t\taddress token = rewardTokens_[i];\n\t\t\t_notifyUnseenReward(token);\n\t\t\tuint256 reward = rewards[user][token] / 1e12;\n\t\t\tif (reward > 0) {\n\t\t\t\trewards[user][token] = 0;\n\t\t\t\trewardData[token].balance = rewardData[token].balance - reward;\n\n\t\t\t\tIERC20(token).safeTransfer(user, reward);\n\t\t\t\temit RewardPaid(user, token, reward);\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Withdraw tokens from MFD\n\t * @param onBehalfOf address to withdraw\n\t * @param amount of withdraw\n\t * @param penaltyAmount penalty applied amount\n\t * @param burnAmount amount to burn\n\t * @param claimRewards option to claim rewards\n\t */\n\tfunction _withdrawTokens(\n\t\taddress onBehalfOf,\n\t\tuint256 amount,\n\t\tuint256 penaltyAmount,\n\t\tuint256 burnAmount,\n\t\tbool claimRewards\n\t) internal {\n\t\tif (onBehalfOf != msg.sender) revert InsufficientPermission();\n\t\t_updateReward(onBehalfOf);\n\n\t\tprntToken.safeTransfer(onBehalfOf, amount);\n\t\tif (penaltyAmount > 0) {\n\t\t\tif (burnAmount > 0) {\n\t\t\t\tprntToken.safeTransfer(starfleetTreasury, burnAmount);\n\t\t\t}\n\t\t\tprntToken.safeTransfer(daoTreasury, penaltyAmount - burnAmount);\n\t\t}\n\n\t\tif (claimRewards) {\n\t\t\t_getReward(onBehalfOf, rewardTokens);\n\t\t\tlastClaimTime[onBehalfOf] = block.timestamp;\n\t\t}\n\n\t\tIPriceProvider(_priceProvider).update();\n\n\t\temit Withdrawn(onBehalfOf, amount, _balances[onBehalfOf].locked, penaltyAmount, burnAmount, false);\n\t}\n\n\t/**\n\t * @notice Withdraw all lockings tokens where the unlock time has passed\n\t * @param user address\n\t * @param limit limit for looping operation\n\t * @return lockAmount withdrawable lock amount\n\t * @return lockAmountWithMultiplier withdraw amount with multiplier\n\t */\n\tfunction _cleanWithdrawableLocks(\n\t\taddress user,\n\t\tuint256 limit\n\t) internal returns (uint256 lockAmount, uint256 lockAmountWithMultiplier) {\n\t\tLockedBalance[] storage locks = _userLocks[user];\n\n\t\tif (locks.length != 0) {\n\t\t\tuint256 length = locks.length <= limit ? locks.length : limit;\n\t\t\tuint256 i;\n\t\t\twhile (i < length && locks[i].unlockTime <= block.timestamp) {\n\t\t\t\tlockAmount = lockAmount + locks[i].amount;\n\t\t\t\tlockAmountWithMultiplier = lockAmountWithMultiplier + (locks[i].amount * locks[i].multiplier);\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t\tuint256 locksLength = locks.length;\n\t\t\tfor (uint256 j = i; j < locksLength; ) {\n\t\t\t\tlocks[j - i] = locks[j];\n\t\t\t\tunchecked {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (uint256 j = 0; j < i; ) {\n\t\t\t\tlocks.pop();\n\t\t\t\tunchecked {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (locks.length == 0) {\n\t\t\t\temit LockerRemoved(user);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Withdraw all currently locked tokens where the unlock time has passed.\n\t * @param address_ of the user.\n\t * @param isRelockAction true if withdraw with relock\n\t * @param doTransfer true to transfer tokens to user\n\t * @param limit limit for looping operation\n\t * @return amount for withdraw\n\t */\n\tfunction _withdrawExpiredLocksFor(\n\t\taddress address_,\n\t\tbool isRelockAction,\n\t\tbool doTransfer,\n\t\tuint256 limit\n\t) internal whenNotPaused returns (uint256 amount) {\n\t\tif (isRelockAction && address_ != msg.sender && _lockZap != msg.sender) revert InsufficientPermission();\n\t\t_updateReward(address_);\n\n\t\tuint256 amountWithMultiplier;\n\t\tBalances storage bal = _balances[address_];\n\t\t(amount, amountWithMultiplier) = _cleanWithdrawableLocks(address_, limit);\n\t\tbal.locked = bal.locked - amount;\n\t\tbal.lockedWithMultiplier = bal.lockedWithMultiplier - amountWithMultiplier;\n\t\tbal.total = bal.total - amount;\n\t\tlockedSupply = lockedSupply - amount;\n\t\tlockedSupplyWithMultiplier = lockedSupplyWithMultiplier - amountWithMultiplier;\n\n\t\tif (isRelockAction || (address_ != msg.sender && !autoRelockDisabled[address_])) {\n\t\t\t_stake(amount, address_, defaultLockIndex[address_], true);\n\t\t} else {\n\t\t\tif (doTransfer) {\n\t\t\t\tIERC20(stakingToken).safeTransfer(address_, amount);\n\t\t\t\tincentivesController.afterLockUpdate(address_);\n\t\t\t\temit Withdrawn(address_, amount, _balances[address_].locked, 0, 0, stakingToken != address(prntToken));\n\t\t\t}\n\t\t}\n\t\treturn amount;\n\t}\n\n\t/********************** Internal View functions ***********************/\n\n\t/**\n\t * @notice Returns withdrawable balance at exact unlock time\n\t * @param user address for withdraw\n\t * @param unlockTime exact unlock time\n\t * @return amount total withdrawable amount\n\t * @return penaltyAmount penalty amount\n\t * @return burnAmount amount to burn\n\t * @return index of earning\n\t */\n\tfunction _ieeWithdrawableBalance(\n\t\taddress user,\n\t\tuint256 unlockTime\n\t) internal view returns (uint256 amount, uint256 penaltyAmount, uint256 burnAmount, uint256 index) {\n\t\tuint256 length = _userEarnings[user].length;\n\t\tfor (index; index < length; ) {\n\t\t\tif (_userEarnings[user][index].unlockTime == unlockTime) {\n\t\t\t\t(amount, , penaltyAmount, burnAmount) = _penaltyInfo(_userEarnings[user][index]);\n\t\t\t\treturn (amount, penaltyAmount, burnAmount, index);\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\trevert UnlockTimeNotFound();\n\t}\n\n\t/**\n\t * @notice Calculate earnings.\n\t * @param user address of earning owner\n\t * @param rewardToken address\n\t * @param balance of the user\n\t * @param currentRewardPerToken current RPT\n\t * @return earnings amount\n\t */\n\tfunction _earned(\n\t\taddress user,\n\t\taddress rewardToken,\n\t\tuint256 balance,\n\t\tuint256 currentRewardPerToken\n\t) internal view returns (uint256 earnings) {\n\t\tearnings = rewards[user][rewardToken];\n\t\tuint256 realRPT = currentRewardPerToken - userRewardPerTokenPaid[user][rewardToken];\n\t\tearnings = earnings + ((balance * realRPT) / 1e18);\n\t}\n\n\t/**\n\t * @notice Penalty information of individual earning\n\t * @param earning earning info.\n\t * @return amount of available earning.\n\t * @return penaltyFactor penalty rate.\n\t * @return penaltyAmount amount of penalty.\n\t * @return burnAmount amount to burn.\n\t */\n\tfunction _penaltyInfo(\n\t\tLockedBalance memory earning\n\t) internal view returns (uint256 amount, uint256 penaltyFactor, uint256 penaltyAmount, uint256 burnAmount) {\n\t\tif (earning.unlockTime > block.timestamp) {\n\t\t\t// 90% on day 1, decays to 25% on day 90\n\t\t\tpenaltyFactor = ((earning.unlockTime - block.timestamp) * HALF) / vestDuration + QUART; // 25% + timeLeft/vestDuration * 65%\n\t\t\tpenaltyAmount = (earning.amount * penaltyFactor) / WHOLE;\n\t\t\tburnAmount = (penaltyAmount * burn) / WHOLE;\n\t\t}\n\t\tamount = earning.amount - penaltyAmount;\n\t}\n\n\t/********************** Private functions ***********************/\n\n\tfunction _binarySearch(\n\t\tLockedBalance[] storage locks,\n\t\tuint256 length,\n\t\tuint256 unlockTime\n\t) private view returns (uint256) {\n\t\tuint256 low = 0;\n\t\tuint256 high = length;\n\t\twhile (low < high) {\n\t\t\tuint256 mid = (low + high) / 2;\n\t\t\tif (locks[mid].unlockTime < unlockTime) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else {\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\t\treturn low;\n\t}\n}\n"
    },
    "contracts/prime/token/Migration.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\n\n/// @title Migration contract from V1 to V2\n/// @author Prime team\ncontract Migration is Ownable, Pausable {\n\tusing SafeERC20 for ERC20;\n\n\t/// @notice V1 of PRNT\n\tERC20 public immutable tokenV1;\n\n\t/// @notice V2 of PRNT\n\tERC20 public immutable tokenV2;\n\n\t/// @notice emitted when migrate v1 token into v2\n\tevent Migrate(address indexed user, uint256 amount);\n\n\t/**\n\t * @notice constructor\n\t * @param _tokenV1 PRNT V1 token address\n\t * @param _tokenV2 PRNT V2 token address\n\t */\n\tconstructor(ERC20 _tokenV1, ERC20 _tokenV2) Ownable() {\n\t\ttokenV1 = _tokenV1;\n\t\ttokenV2 = _tokenV2;\n\t\t_pause();\n\t}\n\n\t/**\n\t * @notice Pause migrations.\n\t */\n\tfunction pause() public onlyOwner {\n\t\t_pause();\n\t}\n\n\t/**\n\t * @notice Unpause migration.\n\t */\n\tfunction unpause() public onlyOwner {\n\t\t_unpause();\n\t}\n\n\t/**\n\t * @notice Withdraw ERC20 token\n\t * @param _token address for withdraw\n\t * @param _amount to withdraw\n\t */\n\tfunction withdrawToken(ERC20 _token, uint256 _amount) external onlyOwner {\n\t\t_token.safeTransfer(owner(), _amount);\n\t}\n\n\t/**\n\t * @notice Migrate from V1 to V2\n\t * @param _amount of V1 token\n\t */\n\tfunction exchange(uint256 _amount) external whenNotPaused {\n\t\ttokenV1.safeTransferFrom(_msgSender(), address(this), _amount);\n\t\ttokenV2.safeTransfer(_msgSender(), _amount);\n\n\t\temit Migrate(_msgSender(), _amount);\n\t}\n}"
    },
    "contracts/prime/token/PrimeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {OFTV2} from \"@layerzerolabs/solidity-examples/contracts/token/oft/v2/OFTV2.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport {IPriceProvider} from \"../../interfaces/IPriceProvider.sol\";\n\n/// @title Radiant token contract with OFT integration\n/// @author Radiant Devs\ncontract PrimeToken is OFTV2, Pausable, ReentrancyGuard {\n\t/// @notice bridge fee reciever\n\taddress private treasury;\n\n\t/// @notice Fee ratio for bridging, in bips\n\tuint256 public feeRatio;\n\n\t/// @notice Divisor for fee ratio, 100%\n\tuint256 public constant FEE_DIVISOR = 10000;\n\n\t/// @notice Max reasonable fee, 1%\n\tuint256 public constant MAX_REASONABLE_FEE = 100;\n\n\t/// @notice PriceProvider, for RDNT price in native fee calc\n\tIPriceProvider public priceProvider;\n\n\t/// @notice Decimals for OFTV2\n\tuint8 public constant SHARED_DECIMALS = 8;\n\n\t/// @notice Emitted when fee ratio is updated\n\tevent FeeRatioUpdated(uint256 indexed fee);\n\n\t/// @notice Emitted when PriceProvider is updated\n\tevent PriceProviderUpdated(IPriceProvider indexed priceProvider);\n\n\t/// @notice Emitted when Treasury is updated\n\tevent TreasuryUpdated(address indexed treasury);\n\n\terror AmountTooSmall();\n\n\t/// @notice Error message emitted when the provided ETH does not cover the bridge fee\n\terror InsufficientETHForFee();\n\n\t/// @notice Emitted when null address is set\n\terror AddressZero();\n\n\t/// @notice Emitted when ratio is invalid\n\terror InvalidRatio();\n\n\t/**\n\t * @notice Create RadiantOFT\n\t * @param _tokenName token name\n\t * @param _symbol token symbol\n\t * @param _endpoint LZ endpoint for network\n\t * @param _dao DAO address, for initial mint\n\t * @param _treasury Treasury address, for fee recieve\n\t * @param _mintAmt Mint amount\n\t */\n\tconstructor(\n\t\tstring memory _tokenName,\n\t\tstring memory _symbol,\n\t\taddress _endpoint,\n\t\taddress _dao,\n\t\taddress _treasury,\n\t\tuint256 _mintAmt\n\t) OFTV2(_tokenName, _symbol, SHARED_DECIMALS, _endpoint) {\n\t\tif (_endpoint == address(0)) revert AddressZero();\n\t\tif (_dao == address(0)) revert AddressZero();\n\t\tif (_treasury == address(0)) revert AddressZero();\n\n\t\ttreasury = _treasury;\n\n\t\tif (_mintAmt != 0) {\n\t\t\t_mint(_dao, _mintAmt);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Burn tokens.\n\t * @param _amount to burn\n\t */\n\tfunction burn(uint256 _amount) public {\n\t\t_burn(_msgSender(), _amount);\n\t}\n\n\t/**\n\t * @notice Pause bridge operation.\n\t */\n\tfunction pause() public onlyOwner {\n\t\t_pause();\n\t}\n\n\t/**\n\t * @notice Unpause bridge operation.\n\t */\n\tfunction unpause() public onlyOwner {\n\t\t_unpause();\n\t}\n\n\t/**\n\t * @notice Returns LZ fee + Bridge fee\n\t * @dev overrides default OFT estimate fee function to add native fee\n\t * @param _dstChainId dest LZ chain id\n\t * @param _toAddress to addr on dst chain\n\t * @param _amount amount to bridge\n\t * @param _useZro use ZRO token, someday ;)\n\t * @param _adapterParams LZ adapter params\n\t */\n\tfunction estimateSendFee(\n\t\tuint16 _dstChainId,\n\t\tbytes32 _toAddress,\n\t\tuint256 _amount,\n\t\tbool _useZro,\n\t\tbytes calldata _adapterParams\n\t) public view override returns (uint256 nativeFee, uint256 zroFee) {\n\t\t(nativeFee, zroFee) = super.estimateSendFee(_dstChainId, _toAddress, _amount, _useZro, _adapterParams);\n\t\tnativeFee = nativeFee + getBridgeFee(_amount);\n\t}\n\n\tfunction _updatePrice() internal {\n\t\tif (address(priceProvider) != address(0)) {\n\t\t\tpriceProvider.update();\n\t\t}\n\t}\n\n\t/**\n\t * @notice Returns amount after dust\n\t * @dev overrides default OFT _send function to add native fee\n\t * @param _from from addr\n\t * @param _dstChainId dest LZ chain id\n\t * @param _toAddress to addr on dst chain\n\t * @param _amount amount to bridge\n\t * @param _refundAddress refund addr\n\t * @param _zroPaymentAddress use ZRO token, someday ;)\n\t * @param _adapterParams LZ adapter params\n\t */\n\tfunction _send(\n\t\taddress _from,\n\t\tuint16 _dstChainId,\n\t\tbytes32 _toAddress,\n\t\tuint256 _amount,\n\t\taddress payable _refundAddress,\n\t\taddress _zroPaymentAddress,\n\t\tbytes memory _adapterParams\n\t) internal override nonReentrant whenNotPaused returns (uint256 amount) {\n\t\t_updatePrice();\n\n\t\t(amount, ) = _removeDust(_amount);\n\t\tuint256 fee = getBridgeFee(amount);\n\t\tif (msg.value < fee) revert InsufficientETHForFee();\n\n\t\t_checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\n\n\t\tif (amount == 0) revert AmountTooSmall();\n\t\t_debitFrom(_from, _dstChainId, _toAddress, amount); // amount returned should not have dust\n\n\t\tbytes memory lzPayload = _encodeSendPayload(_toAddress, _ld2sd(amount));\n\t\t_lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value - fee);\n\n\t\tif (fee > 0) {\n\t\t\tAddress.sendValue(payable(treasury), fee);\n\t\t}\n\n\t\temit SendToChain(_dstChainId, _from, _toAddress, amount);\n\t}\n\n\t/**\n\t * @notice Bridge token and execute calldata on destination chain\n\t * @dev overrides default OFT _sendAndCall function to add native fee\n\t * @param _from from addr\n\t * @param _dstChainId dest LZ chain id\n\t * @param _toAddress to addr on dst chain\n\t * @param _amount amount to bridge\n\t * @param _payload calldata to execute on dst chain\n\t * @param _dstGasForCall amount of gas to use on dst chain\n\t * @param _refundAddress refund addr\n\t * @param _zroPaymentAddress use ZRO token, someday ;)\n\t * @param _adapterParams LZ adapter params\n\t */\n\tfunction _sendAndCall(\n\t\taddress _from,\n\t\tuint16 _dstChainId,\n\t\tbytes32 _toAddress,\n\t\tuint _amount,\n\t\tbytes memory _payload,\n\t\tuint64 _dstGasForCall,\n\t\taddress payable _refundAddress,\n\t\taddress _zroPaymentAddress,\n\t\tbytes memory _adapterParams\n\t) internal override nonReentrant whenNotPaused returns (uint amount) {\n\t\t_updatePrice();\n\n\t\t(amount, ) = _removeDust(_amount);\n\t\tuint256 fee = getBridgeFee(amount);\n\t\tif (msg.value < fee) revert InsufficientETHForFee();\n\n\t\t_checkAdapterParams(_dstChainId, PT_SEND_AND_CALL, _adapterParams, _dstGasForCall);\n\n\t\tif (amount == 0) revert AmountTooSmall();\n\t\t_debitFrom(_from, _dstChainId, _toAddress, amount);\n\n\t\t// encode the msg.sender into the payload instead of _from\n\t\tbytes memory lzPayload = _encodeSendAndCallPayload(\n\t\t\tmsg.sender,\n\t\t\t_toAddress,\n\t\t\t_ld2sd(amount),\n\t\t\t_payload,\n\t\t\t_dstGasForCall\n\t\t);\n\t\t_lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value - fee);\n\n\t\tif (fee > 0) {\n\t\t\tAddress.sendValue(payable(treasury), fee);\n\t\t}\n\n\t\temit SendToChain(_dstChainId, _from, _toAddress, amount);\n\t}\n\n\t/**\n\t * @notice overrides default OFT _debitFrom function to make pauseable\n\t * @param _from from addr\n\t * @param _dstChainId dest LZ chain id\n\t * @param _toAddress to addr on dst chain\n\t * @param _amount amount to bridge\n\t */\n\tfunction _debitFrom(\n\t\taddress _from,\n\t\tuint16 _dstChainId,\n\t\tbytes32 _toAddress,\n\t\tuint256 _amount\n\t) internal override whenNotPaused returns (uint256) {\n\t\treturn super._debitFrom(_from, _dstChainId, _toAddress, _amount);\n\t}\n\n\t/**\n\t * @notice Bridge fee amount\n\t * @param _rdntAmount amount for bridge\n\t * @return bridgeFee calculated bridge fee\n\t */\n\tfunction getBridgeFee(uint256 _rdntAmount) public view returns (uint256 bridgeFee) {\n\t\tif (address(priceProvider) == address(0)) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 priceInEth = priceProvider.getTokenPrice();\n\t\tuint256 priceDecimals = priceProvider.decimals();\n\t\tuint256 rdntInEth = _rdntAmount * priceInEth * (10 ** 18) / (10 ** priceDecimals) / (10 ** decimals());\n\t\tbridgeFee = (rdntInEth * feeRatio) / FEE_DIVISOR;\n\t}\n\n\t/**\n\t * @notice Set fee info\n\t * @param _feeRatio ratio\n\t */\n\tfunction setFeeRatio(uint256 _feeRatio) external onlyOwner {\n\t\tif (_feeRatio > MAX_REASONABLE_FEE) revert InvalidRatio();\n\t\tfeeRatio = _feeRatio;\n\t\temit FeeRatioUpdated(_feeRatio);\n\t}\n\n\t/**\n\t * @notice Set price provider\n\t * @param _priceProvider address\n\t */\n\tfunction setPriceProvider(IPriceProvider _priceProvider) external onlyOwner {\n\t\tif (address(_priceProvider) == address(0)) revert AddressZero();\n\t\tpriceProvider = _priceProvider;\n\t\temit PriceProviderUpdated(_priceProvider);\n\t}\n\n\t/**\n\t * @notice Set Treasury\n\t * @param _treasury address\n\t */\n\tfunction setTreasury(address _treasury) external onlyOwner {\n\t\tif (_treasury == address(0)) revert AddressZero();\n\t\ttreasury = _treasury;\n\t\temit TreasuryUpdated(_treasury);\n\t}\n}"
    },
    "contracts/prime/zap/helpers/BalancerPoolHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {DustRefunder} from \"./DustRefunder.sol\";\nimport {BNum} from \"../../../dependencies/math/BNum.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {IBalancerPoolHelper} from \"../../../interfaces/IPoolHelper.sol\";\nimport {IWETH} from \"../../../interfaces/IWETH.sol\";\nimport {IWeightedPoolFactory, IWeightedPool, IAsset, IVault, IBalancerQueries} from \"../../../interfaces/balancer/IWeightedPoolFactory.sol\";\nimport {VaultReentrancyLib} from \"../../libraries/balancer-reentrancy/VaultReentrancyLib.sol\";\n\n/// @title Balance Pool Helper Contract\n/// @author Prime\ncontract BalancerPoolHelper is IBalancerPoolHelper, Initializable, OwnableUpgradeable, BNum, DustRefunder {\n\tusing SafeERC20 for IERC20;\n\n\terror AddressZero();\n\terror PoolExists();\n\terror InsufficientPermission();\n\terror IdenticalAddresses();\n\terror ZeroAmount();\n\terror QuoteFail();\n\n\taddress public inTokenAddr;\n\taddress public outTokenAddr;\n\taddress public wethAddr;\n\taddress public lpTokenAddr;\n\taddress public vaultAddr;\n\tbytes32 public poolId;\n\taddress public lockZap;\n\tIWeightedPoolFactory public poolFactory;\n\tuint256 public constant PRNT_WEIGHT = 800000000000000000;\n\tuint256 public constant WETH_WEIGHT = 200000000000000000;\n\tuint256 public constant INITIAL_SWAP_FEE_PERCENTAGE = 1000000000000000;\n\n\t/// @notice In 80/20 pool, PRNT Weight is 4x of WETH weight\n\tuint256 public constant POOL_WEIGHT = 4;\n\n\tbytes32 public constant WBTC_WETH_USDC_POOL_ID = 0x64541216bafffeec8ea535bb71fbc927831d0595000100000000000000000002;\n\tbytes32 public constant DAI_USDT_USDC_POOL_ID = 0x1533a3278f3f9141d5f820a184ea4b017fce2382000000000000000000000016;\n\taddress public constant REAL_WETH_ADDR = address(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);\n\n\taddress public constant BALANCER_QUERIES = 0xE39B5e3B6D74016b2F6A9673D7d7493B6DF549d5;\n\n\taddress public constant USDT_ADDRESS = address(0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9);\n\taddress public constant DAI_ADDRESS = address(0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1);\n\taddress public constant USDC_ADDRESS = address(0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8);\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Initializer\n\t * @param _inTokenAddr input token of the pool\n\t * @param _outTokenAddr output token of the pool\n\t * @param _wethAddr WETH address\n\t * @param _vault Balancer Vault\n\t * @param _poolFactory Balancer pool factory address\n\t */\n\tfunction initialize(\n\t\taddress _inTokenAddr,\n\t\taddress _outTokenAddr,\n\t\taddress _wethAddr,\n\t\taddress _vault,\n\t\tIWeightedPoolFactory _poolFactory\n\t) external initializer {\n\t\tif (_inTokenAddr == address(0)) revert AddressZero();\n\t\tif (_outTokenAddr == address(0)) revert AddressZero();\n\t\tif (_wethAddr == address(0)) revert AddressZero();\n\t\tif (_vault == address(0)) revert AddressZero();\n\t\tif (address(_poolFactory) == address(0)) revert AddressZero();\n\n\t\t__Ownable_init();\n\t\tinTokenAddr = _inTokenAddr;\n\t\toutTokenAddr = _outTokenAddr;\n\t\twethAddr = _wethAddr;\n\t\tvaultAddr = _vault;\n\t\tpoolFactory = _poolFactory;\n\t}\n\n\t/**\n\t * @notice Initialize a new pool.\n\t * @param _tokenName Token name of lp token\n\t * @param _tokenSymbol Token symbol of lp token\n\t */\n\tfunction initializePool(string calldata _tokenName, string calldata _tokenSymbol) public onlyOwner {\n\t\tif (lpTokenAddr != address(0)) revert PoolExists();\n\n\t\t(address token0, address token1) = _sortTokens(inTokenAddr, outTokenAddr);\n\n\t\tIERC20[] memory tokens = new IERC20[](2);\n\t\ttokens[0] = IERC20(token0);\n\t\ttokens[1] = IERC20(token1);\n\n\t\taddress[] memory rateProviders = new address[](2);\n\t\trateProviders[0] = 0x0000000000000000000000000000000000000000;\n\t\trateProviders[1] = 0x0000000000000000000000000000000000000000;\n\n\t\tuint256[] memory weights = new uint256[](2);\n\n\t\tif (token0 == outTokenAddr) {\n\t\t\tweights[0] = PRNT_WEIGHT;\n\t\t\tweights[1] = WETH_WEIGHT;\n\t\t} else {\n\t\t\tweights[0] = WETH_WEIGHT;\n\t\t\tweights[1] = PRNT_WEIGHT;\n\t\t}\n\n\t\tlpTokenAddr = poolFactory.create(\n\t\t\t_tokenName,\n\t\t\t_tokenSymbol,\n\t\t\ttokens,\n\t\t\tweights,\n\t\t\trateProviders,\n\t\t\tINITIAL_SWAP_FEE_PERCENTAGE,\n\t\t\taddress(this)\n\t\t);\n\n\t\tpoolId = IWeightedPool(lpTokenAddr).getPoolId();\n\n\t\tIERC20 outToken = IERC20(outTokenAddr);\n\t\tIERC20 inToken = IERC20(inTokenAddr);\n\t\tIERC20 lp = IERC20(lpTokenAddr);\n\t\tIERC20 weth = IERC20(wethAddr);\n\n\t\toutToken.forceApprove(vaultAddr, type(uint256).max);\n\t\tinToken.forceApprove(vaultAddr, type(uint256).max);\n\t\tweth.approve(vaultAddr, type(uint256).max);\n\n\t\tIAsset[] memory assets = new IAsset[](2);\n\t\tassets[0] = IAsset(token0);\n\t\tassets[1] = IAsset(token1);\n\n\t\tuint256 inTokenAmt = inToken.balanceOf(address(this));\n\t\tuint256 outTokenAmt = outToken.balanceOf(address(this));\n\n\t\tuint256[] memory maxAmountsIn = new uint256[](2);\n\t\tif (token0 == inTokenAddr) {\n\t\t\tmaxAmountsIn[0] = inTokenAmt;\n\t\t\tmaxAmountsIn[1] = outTokenAmt;\n\t\t} else {\n\t\t\tmaxAmountsIn[0] = outTokenAmt;\n\t\t\tmaxAmountsIn[1] = inTokenAmt;\n\t\t}\n\n\t\tIVault.JoinPoolRequest memory inRequest = IVault.JoinPoolRequest(\n\t\t\tassets,\n\t\t\tmaxAmountsIn,\n\t\t\tabi.encode(0, maxAmountsIn),\n\t\t\tfalse\n\t\t);\n\t\tIVault(vaultAddr).joinPool(poolId, address(this), address(this), inRequest);\n\t\tuint256 liquidity = lp.balanceOf(address(this));\n\t\tlp.safeTransfer(msg.sender, liquidity);\n\t}\n\n\t/// @dev Return fair reserve amounts given spot reserves, weights, and fair prices.\n\t/// @param resA Reserve of the first asset\n\t/// @param resB Reserve of the second asset\n\t/// @param wA Weight of the first asset\n\t/// @param wB Weight of the second asset\n\t/// @param pxA Fair price of the first asset\n\t/// @param pxB Fair price of the second asset\n\tfunction _computeFairReserves(\n\t\tuint256 resA,\n\t\tuint256 resB,\n\t\tuint256 wA,\n\t\tuint256 wB,\n\t\tuint256 pxA,\n\t\tuint256 pxB\n\t) internal pure returns (uint256 fairResA, uint256 fairResB) {\n\t\t// NOTE: wA + wB = 1 (normalize weights)\n\t\t// constant product = resA^wA * resB^wB\n\t\t// constraints:\n\t\t// - fairResA^wA * fairResB^wB = constant product\n\t\t// - fairResA * pxA / wA = fairResB * pxB / wB\n\t\t// Solving equations:\n\t\t// --> fairResA^wA * (fairResA * (pxA * wB) / (wA * pxB))^wB = constant product\n\t\t// --> fairResA / r1^wB = constant product\n\t\t// --> fairResA = resA^wA * resB^wB * r1^wB\n\t\t// --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n\t\tuint256 r0 = bdiv(resA, resB);\n\t\tuint256 r1 = bdiv(bmul(wA, pxB), bmul(wB, pxA));\n\t\t// fairResA = resA * (r1 / r0) ^ wB\n\t\t// fairResB = resB * (r0 / r1) ^ wA\n\t\tif (r0 > r1) {\n\t\t\tuint256 ratio = bdiv(r1, r0);\n\t\t\tfairResA = bmul(resA, bpow(ratio, wB));\n\t\t\tfairResB = bdiv(resB, bpow(ratio, wA));\n\t\t} else {\n\t\t\tuint256 ratio = bdiv(r0, r1);\n\t\t\tfairResA = bdiv(resA, bpow(ratio, wB));\n\t\t\tfairResB = bmul(resB, bpow(ratio, wA));\n\t\t}\n\t}\n\n\t/**\n\t * @notice Calculates LP price\n\t * @dev Return value decimal is 8\n\t * @param prntPriceInEth PRNT price in ETH\n\t * @return priceInEth LP price in ETH\n\t */\n\tfunction getLpPrice(uint256 prntPriceInEth) public view returns (uint256 priceInEth) {\n\t\tIWeightedPool pool = IWeightedPool(lpTokenAddr);\n\t\t(address token0, ) = _sortTokens(inTokenAddr, outTokenAddr);\n\t\t(uint256 prntBalance, uint256 wethBalance, ) = getReserves();\n\t\tuint256[] memory weights = pool.getNormalizedWeights();\n\n\t\tuint256 prntWeight;\n\t\tuint256 wethWeight;\n\n\t\tif (token0 == outTokenAddr) {\n\t\t\tprntWeight = weights[0];\n\t\t\twethWeight = weights[1];\n\t\t} else {\n\t\t\tprntWeight = weights[1];\n\t\t\twethWeight = weights[0];\n\t\t}\n\n\t\t// PRNT in eth, 8 decis\n\t\tuint256 pxA = prntPriceInEth;\n\t\t// ETH in eth, 8 decis\n\t\tuint256 pxB = 100000000;\n\n\t\t(uint256 fairResA, uint256 fairResB) = _computeFairReserves(\n\t\t\tprntBalance,\n\t\t\twethBalance,\n\t\t\tprntWeight,\n\t\t\twethWeight,\n\t\t\tpxA,\n\t\t\tpxB\n\t\t);\n\t\t// use fairReserveA and fairReserveB to compute LP token price\n\t\t// LP price = (fairResA * pxA + fairResB * pxB) / totalLPSupply\n\t\tpriceInEth = (fairResA * pxA + fairResB * pxB) / pool.totalSupply();\n\t}\n\n\t/**\n\t * @notice Returns PRNT price in WETH\n\t * @return PRNT price\n\t */\n\tfunction getPrice() public view returns (uint256) {\n\t\taddress vaultAddress = vaultAddr;\n\t\tVaultReentrancyLib.ensureNotInVaultContext(IVault(vaultAddress));\n\t\t(IERC20[] memory tokens, uint256[] memory balances, ) = IVault(vaultAddress).getPoolTokens(poolId);\n\t\tuint256 prntBalance = address(tokens[0]) == outTokenAddr ? balances[0] : balances[1];\n\t\tuint256 wethBalance = address(tokens[0]) == outTokenAddr ? balances[1] : balances[0];\n\n\t\treturn (wethBalance * 1e8) / (prntBalance / POOL_WEIGHT);\n\t}\n\n\t/**\n\t * @notice Returns reserve information.\n\t * @return prnt PRNT amount\n\t * @return weth WETH amount\n\t * @return lpTokenSupply LP token supply\n\t */\n\tfunction getReserves() public view returns (uint256 prnt, uint256 weth, uint256 lpTokenSupply) {\n\t\tIERC20 lpToken = IERC20(lpTokenAddr);\n\n\t\taddress vaultAddress = vaultAddr;\n\t\tVaultReentrancyLib.ensureNotInVaultContext(IVault(vaultAddress));\n\t\t(IERC20[] memory tokens, uint256[] memory balances, ) = IVault(vaultAddress).getPoolTokens(poolId);\n\n\t\tprnt = address(tokens[0]) == outTokenAddr ? balances[0] : balances[1];\n\t\tweth = address(tokens[0]) == outTokenAddr ? balances[1] : balances[0];\n\n\t\tlpTokenSupply = lpToken.totalSupply();\n\t}\n\n\t/**\n\t * @notice Add liquidity\n\t * @param _wethAmt WETH amount\n\t * @param _prntAmt PRNT amount\n\t * @return liquidity amount of LP token\n\t */\n\tfunction _joinPool(uint256 _wethAmt, uint256 _prntAmt) internal returns (uint256 liquidity) {\n\t\t(address token0, address token1) = _sortTokens(outTokenAddr, inTokenAddr);\n\t\tIAsset[] memory assets = new IAsset[](2);\n\t\tassets[0] = IAsset(token0);\n\t\tassets[1] = IAsset(token1);\n\n\t\tuint256[] memory maxAmountsIn = new uint256[](2);\n\t\tif (token0 == inTokenAddr) {\n\t\t\tmaxAmountsIn[0] = _wethAmt;\n\t\t\tmaxAmountsIn[1] = _prntAmt;\n\t\t} else {\n\t\t\tmaxAmountsIn[0] = _prntAmt;\n\t\t\tmaxAmountsIn[1] = _wethAmt;\n\t\t}\n\n\t\tbytes memory userDataEncoded = abi.encode(IWeightedPool.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT, maxAmountsIn, 0);\n\t\tIVault.JoinPoolRequest memory inRequest = IVault.JoinPoolRequest(assets, maxAmountsIn, userDataEncoded, false);\n\t\tIVault(vaultAddr).joinPool(poolId, address(this), address(this), inRequest);\n\n\t\tIERC20 lp = IERC20(lpTokenAddr);\n\t\tliquidity = lp.balanceOf(address(this));\n\t}\n\n\t/**\n\t * @notice Gets needed WETH for adding LP\n\t * @param lpAmount LP amount\n\t * @return wethAmount WETH amount\n\t */\n\tfunction quoteWETH(uint256 lpAmount) public override view returns (uint256 wethAmount) {\n\t\t(address token0, address token1) = _sortTokens(outTokenAddr, inTokenAddr);\n\t\tIAsset[] memory assets = new IAsset[](2);\n\t\tassets[0] = IAsset(token0);\n\t\tassets[1] = IAsset(token1);\n\n\t\tuint256[] memory maxAmountsIn = new uint256[](2);\n\t\tuint256 enterTokenIndex;\n\t\tif (token0 == inTokenAddr) {\n\t\t\tenterTokenIndex = 0;\n\t\t\tmaxAmountsIn[0] = type(uint256).max;\n\t\t\tmaxAmountsIn[1] = 0;\n\t\t} else {\n\t\t\tenterTokenIndex = 1;\n\t\t\tmaxAmountsIn[0] = 0;\n\t\t\tmaxAmountsIn[1] = type(uint256).max;\n\t\t}\n\n\t\tbytes memory userDataEncoded = abi.encode(IWeightedPool.JoinKind.TOKEN_IN_FOR_EXACT_BPT_OUT, lpAmount, enterTokenIndex);\n\t\tIVault.JoinPoolRequest memory inRequest = IVault.JoinPoolRequest(assets, maxAmountsIn, userDataEncoded, false);\n\n\t\t(bool success, bytes memory data) = BALANCER_QUERIES.staticcall(\n\t\t\tabi.encodeCall(IBalancerQueries.queryJoin, (poolId, address(this), address(this), inRequest))\n\t\t);\n\t\tif (!success) revert QuoteFail();\n\t\t(, uint256[] memory amountsIn) = abi.decode(data, (uint256, uint256[]));\n\t\treturn amountsIn[enterTokenIndex];\n\t}\n\n\t/**\n\t * @notice Zap WETH\n\t * @param amount to zap\n\t * @return liquidity token amount\n\t */\n\tfunction zapWETH(uint256 amount) public returns (uint256 liquidity) {\n\t\tif (msg.sender != lockZap) revert InsufficientPermission();\n\t\tIWETH(wethAddr).transferFrom(msg.sender, address(this), amount);\n\t\tliquidity = _joinPool(amount, 0);\n\t\tIERC20 lp = IERC20(lpTokenAddr);\n\t\tlp.safeTransfer(msg.sender, liquidity);\n\t\t_refundDust(outTokenAddr, wethAddr, msg.sender);\n\t}\n\n\t/**\n\t * @notice Zap WETH and PRNT\n\t * @param _wethAmt WETH amount\n\t * @param _prntAmt PRNT amount\n\t * @return liquidity token amount\n\t */\n\tfunction zapTokens(uint256 _wethAmt, uint256 _prntAmt) public returns (uint256 liquidity) {\n\t\tif (msg.sender != lockZap) revert InsufficientPermission();\n\t\tIWETH(wethAddr).transferFrom(msg.sender, address(this), _wethAmt);\n\t\tIERC20(outTokenAddr).safeTransferFrom(msg.sender, address(this), _prntAmt);\n\n\t\tliquidity = _joinPool(_wethAmt, _prntAmt);\n\t\tIERC20 lp = IERC20(lpTokenAddr);\n\t\tlp.safeTransfer(msg.sender, liquidity);\n\n\t\t_refundDust(outTokenAddr, wethAddr, msg.sender);\n\t}\n\n\t/**\n\t * @notice Sort tokens\n\t */\n\tfunction _sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n\t\tif (tokenA == tokenB) revert IdenticalAddresses();\n\t\t(token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n\t\tif (token0 == address(0)) revert AddressZero();\n\t}\n\n\t/**\n\t * @notice Calculate quote in WETH from token\n\t * @param tokenAmount PRNT amount\n\t * @return optimalWETHAmount WETH amount\n\t */\n\tfunction quoteFromToken(uint256 tokenAmount) public view returns (uint256 optimalWETHAmount) {\n\t\tuint256 prntPriceInEth = getPrice();\n\t\tuint256 p1 = prntPriceInEth * 1e10;\n\t\tuint256 ethRequiredBeforeWeight = (tokenAmount * p1) / 1e18;\n\t\toptimalWETHAmount = ethRequiredBeforeWeight / POOL_WEIGHT;\n\t}\n\n\t/**\n\t * @notice Set lockzap contract\n\t */\n\tfunction setLockZap(address _lockZap) external onlyOwner {\n\t\tif (_lockZap == address(0)) revert AddressZero();\n\t\tlockZap = _lockZap;\n\t}\n\n\n\t/**\n\t * @notice Calculate tokenAmount from WETH\n\t * @param _inToken input token\n\t * @param _wethAmount WETH amount\n\t * @return tokenAmount token amount\n\t */\n\tfunction quoteSwap(address _inToken, uint256 _wethAmount) public override view returns (uint256 tokenAmount) {\n\t\tIVault.SingleSwap memory singleSwap;\n\t\tsingleSwap.poolId = poolId;\n\t\tsingleSwap.kind = IVault.SwapKind.GIVEN_OUT;\n\t\tsingleSwap.assetIn = IAsset(_inToken);\n\t\tsingleSwap.assetOut = IAsset(wethAddr);\n\t\tsingleSwap.amount = _wethAmount;\n\t\tsingleSwap.userData = abi.encode(0);\n\n\t\tIVault.FundManagement memory funds;\n\t\tfunds.sender = address(this);\n\t\tfunds.fromInternalBalance = false;\n\t\tfunds.recipient = payable(address(this));\n\t\tfunds.toInternalBalance = false;\n\n\t\t(bool success, bytes memory data) = BALANCER_QUERIES.staticcall(\n\t\t\tabi.encodeCall(IBalancerQueries.querySwap, (singleSwap, funds))\n\t\t);\n\t\tif (!success) revert QuoteFail();\n\t\tuint256 amountIn = abi.decode(data, (uint256));\n\t\treturn amountIn;\n\t}\n\n\t/**\n\t * @notice Swaps tokens like USDC, DAI, USDT, WBTC to WETH\n\t * @param _inToken address of the asset to swap\n\t * @param _amount the amount of asset to swap\n\t * @param _minAmountOut the minimum WETH amount to accept without reverting\n\t */\n\tfunction swapToWeth(address _inToken, uint256 _amount, uint256 _minAmountOut) external {\n\t\tif (msg.sender != lockZap) revert InsufficientPermission();\n\t\tif (_inToken == address(0)) revert AddressZero();\n\t\tif (_amount == 0) revert ZeroAmount();\n\t\tbool isSingleSwap = true;\n\t\tif (_inToken == USDT_ADDRESS || _inToken == DAI_ADDRESS) {\n\t\t\tisSingleSwap = false;\n\t\t}\n\n\t\tif (!isSingleSwap) {\n\t\t\tuint256 usdcBalanceBefore = IERC20(USDC_ADDRESS).balanceOf(address(this));\n\t\t\t_swap(_inToken, USDC_ADDRESS, _amount, 0, DAI_USDT_USDC_POOL_ID, address(this));\n\t\t\tuint256 usdcBalanceAfter = IERC20(USDC_ADDRESS).balanceOf(address(this));\n\t\t\t_inToken = USDC_ADDRESS;\n\t\t\t_amount = usdcBalanceAfter - usdcBalanceBefore;\n\t\t}\n\n\t\t_swap(_inToken, REAL_WETH_ADDR, _amount, _minAmountOut, WBTC_WETH_USDC_POOL_ID, msg.sender);\n\t}\n\n\t/**\n\t * @notice Swaps tokens using the Balancer swap function\n\t * @param _inToken address of the asset to swap\n\t * @param _outToken address of the asset to receieve\n\t * @param _amount the amount of asset to swap\n\t * @param _minAmountOut the minimum WETH amount to accept without reverting\n\t * @param _poolId The ID of the pool to use for swapping\n\t * @param _recipient the receiver of the outToken\n\t */\n\tfunction _swap(\n\t\taddress _inToken,\n\t\taddress _outToken,\n\t\tuint256 _amount,\n\t\tuint256 _minAmountOut,\n\t\tbytes32 _poolId,\n\t\taddress _recipient\n\t) internal {\n\t\tIVault.SingleSwap memory singleSwap;\n\t\tsingleSwap.poolId = _poolId;\n\t\tsingleSwap.kind = IVault.SwapKind.GIVEN_IN;\n\t\tsingleSwap.assetIn = IAsset(_inToken);\n\t\tsingleSwap.assetOut = IAsset(_outToken);\n\t\tsingleSwap.amount = _amount;\n\t\tsingleSwap.userData = abi.encode(0);\n\n\t\tIVault.FundManagement memory funds;\n\t\tfunds.sender = address(this);\n\t\tfunds.fromInternalBalance = false;\n\t\tfunds.recipient = payable(address(_recipient));\n\t\tfunds.toInternalBalance = false;\n\n\t\tuint256 currentAllowance = IERC20(_inToken).allowance(address(this), vaultAddr);\n\t\tif (_amount > currentAllowance) {\n\t\t\tIERC20(_inToken).forceApprove(vaultAddr, _amount);\n\t\t}\n\t\tIVault(vaultAddr).swap(singleSwap, funds, _minAmountOut, block.timestamp);\n\t}\n\n\t/**\n\t * @notice Get swap fee percentage\n\t */\n\tfunction getSwapFeePercentage() external view returns (uint256 fee) {\n\t\tIWeightedPool pool = IWeightedPool(lpTokenAddr);\n\t\tfee = pool.getSwapFeePercentage();\n\t}\n\n\t/**\n\t * @notice Set swap fee percentage\n\t */\n\tfunction setSwapFeePercentage(uint256 _fee) external onlyOwner {\n\t\tIWeightedPool pool = IWeightedPool(lpTokenAddr);\n\t\tpool.setSwapFeePercentage(_fee);\n\t}\n}\n"
    },
    "contracts/prime/zap/helpers/DustRefunder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IWETH} from \"../../../interfaces/IWETH.sol\";\n\n/// @title Dust Refunder Contract\n/// @dev Refunds dust tokens remaining from zapping.\n/// @author Prime\ncontract DustRefunder {\n\tusing SafeERC20 for IERC20;\n\n\t/**\n\t * @notice Refunds PRNT and WETH.\n\t * @param _prnt PRNT address\n\t * @param _weth WETH address\n\t * @param _refundAddress Address for refund\n\t */\n\tfunction _refundDust(address _prnt, address _weth, address _refundAddress) internal {\n\t\tIERC20 prnt = IERC20(_prnt);\n\t\tIWETH weth = IWETH(_weth);\n\n\t\tuint256 dustWETH = weth.balanceOf(address(this));\n\t\tif (dustWETH > 0) {\n\t\t\tweth.transfer(_refundAddress, dustWETH);\n\t\t}\n\t\tuint256 dustPrnt = prnt.balanceOf(address(this));\n\t\tif (dustPrnt > 0) {\n\t\t\tprnt.safeTransfer(_refundAddress, dustPrnt);\n\t\t}\n\t}\n}\n"
    },
    "contracts/prime/zap/helpers/LiquidityZap.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.12;\n\n//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\n//\n// LiquidityZAP takes ETH and converts to  liquidity tokens.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program.\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// Attribution: CORE / cvault.finance\n//  https://github.com/cVault-finance/CORE-periphery/blob/master/contracts/COREv1Router.sol\n//\n//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\n//----------------------------------------------------------------------------------\n//    I n s t a n t\n//\n//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.\n//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.\n//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:\n//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'\n//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'\n//\n//----------------------------------------------------------------------------------\n\nimport {IUniswapV2Pair} from \"@uniswap/lib/contracts/interfaces/IUniswapV2Pair.sol\";\nimport {UniswapV2Library} from \"@uniswap/lib/contracts/libraries/UniswapV2Library.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {DustRefunder} from \"./DustRefunder.sol\";\n\nimport {IWETH} from \"../../../interfaces/IWETH.sol\";\nimport {IPriceProvider} from \"../../../interfaces/IPriceProvider.sol\";\nimport {IChainlinkAdapter} from \"../../../interfaces/IChainlinkAdapter.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/// @title Prime token contract with OFT integration\n/// @author Prime Devs\ncontract LiquidityZap is Initializable, OwnableUpgradeable, DustRefunder {\n\tusing SafeERC20 for IERC20;\n\n\terror ZapExists();\n\terror InvalidETHAmount();\n\terror AddressZero();\n\terror InsufficientPermission();\n\terror TransferFailed();\n\terror InvalidRatio();\n\terror InvalidSlippage();\n\n\taddress public token;\n\taddress public tokenWETHPair;\n\tIWETH public weth;\n\tbool private initializedLiquidityZap;\n\taddress public poolHelper;\n\n\t/// @notice ratio Divisor\n\tuint256 public constant RATIO_DIVISOR = 10000;\n\n\t/// @notice Acceptable ratio\n\tuint256 public acceptableRatio;\n\n\t/// @notice Price provider contract\n\tIPriceProvider public priceProvider;\n\n\t/// @notice ETH oracle contract\n\tIChainlinkAdapter public ethOracle;\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Initialize\n\t */\n\tfunction initialize() external initializer {\n\t\t__Ownable_init();\n\t}\n\n\t/**\n\t * @notice Initialize liquidity zap param\n\t * @param token_ PRNT address\n\t * @param weth_ WETH address\n\t * @param tokenWethPair_ LP pair\n\t * @param helper_ Pool helper contract\n\t */\n\tfunction initLiquidityZap(\n\t\taddress token_,\n\t\taddress weth_,\n\t\taddress tokenWethPair_,\n\t\taddress helper_\n\t) external onlyOwner {\n\t\tif (initializedLiquidityZap) revert ZapExists();\n\t\ttoken = token_;\n\t\tweth = IWETH(weth_);\n\t\ttokenWETHPair = tokenWethPair_;\n\t\tinitializedLiquidityZap = true;\n\t\tpoolHelper = helper_;\n\t}\n\n\tfallback() external payable {\n\t\tif (msg.sender != address(weth)) {\n\t\t\taddLiquidityETHOnly(payable(msg.sender));\n\t\t}\n\t}\n\n\treceive() external payable {\n\t\tif (msg.sender != address(weth)) {\n\t\t\taddLiquidityETHOnly(payable(msg.sender));\n\t\t}\n\t}\n\n\t/**\n\t * @notice Set Price Provider.\n\t * @param _provider Price provider contract address.\n\t */\n\tfunction setPriceProvider(address _provider) external onlyOwner {\n\t\tif (address(_provider) == address(0)) revert AddressZero();\n\t\tpriceProvider = IPriceProvider(_provider);\n\t\tethOracle = IChainlinkAdapter(priceProvider.baseAssetChainlinkAdapter());\n\t}\n\n\t/**\n\t * @notice Set Acceptable Ratio.\n\t * @param _acceptableRatio Acceptable slippage ratio.\n\t */\n\tfunction setAcceptableRatio(uint256 _acceptableRatio) external onlyOwner {\n\t\tif (_acceptableRatio > RATIO_DIVISOR) revert InvalidRatio();\n\t\tacceptableRatio = _acceptableRatio;\n\t}\n\n\t/**\n\t * @notice Zap ethereum\n\t * @param _onBehalf of the user\n\t * @return liquidity lp amount\n\t */\n\tfunction zapETH(address payable _onBehalf) external payable returns (uint256) {\n\t\tif (msg.value == 0) revert InvalidETHAmount();\n\t\treturn addLiquidityETHOnly(_onBehalf);\n\t}\n\n\t/**\n\t * @notice Add liquidity with WETH\n\t * @param _amount of WETH\n\t * @param to address of lp token\n\t * @return liquidity lp amount\n\t */\n\tfunction addLiquidityWETHOnly(uint256 _amount, address payable to) public returns (uint256) {\n\t\tif (msg.sender != poolHelper) revert InsufficientPermission();\n\t\tif (to == address(0)) revert AddressZero();\n\t\tuint256 buyAmount = _amount / 2;\n\t\tif (buyAmount == 0) revert InvalidETHAmount();\n\n\t\t(uint256 reserveWeth, uint256 reserveTokens) = _getPairReserves();\n\t\tuint256 outTokens = UniswapV2Library.getAmountOut(buyAmount, reserveWeth, reserveTokens);\n\n\t\tweth.transfer(tokenWETHPair, buyAmount);\n\n\t\t(address token0, address token1) = UniswapV2Library.sortTokens(address(weth), token);\n\t\tIUniswapV2Pair(tokenWETHPair).swap(\n\t\t\ttoken == token0 ? outTokens : 0,\n\t\t\ttoken == token1 ? outTokens : 0,\n\t\t\taddress(this),\n\t\t\t\"\"\n\t\t);\n\n\t\treturn _addLiquidity(outTokens, buyAmount, to);\n\t}\n\n\t/**\n\t * @notice Add liquidity with ETH\n\t * @param to address of lp token\n\t * @return liquidity lp amount\n\t */\n\tfunction addLiquidityETHOnly(address payable to) public payable returns (uint256) {\n\t\tif (to == address(0)) revert AddressZero();\n\t\tuint256 buyAmount = msg.value / 2;\n\t\tif (buyAmount == 0) revert InvalidETHAmount();\n\t\tweth.deposit{value: msg.value}();\n\n\t\t(uint256 reserveWeth, uint256 reserveTokens) = _getPairReserves();\n\t\tuint256 outTokens = UniswapV2Library.getAmountOut(buyAmount, reserveWeth, reserveTokens);\n\n\t\tif (address(priceProvider) != address(0)) {\n\t\t\tuint256 slippage = _calcSlippage(buyAmount, outTokens);\n\t\t\tif (slippage < acceptableRatio) revert InvalidSlippage();\n\t\t}\n\n\t\tweth.transfer(tokenWETHPair, buyAmount);\n\n\t\t(address token0, address token1) = UniswapV2Library.sortTokens(address(weth), token);\n\t\tIUniswapV2Pair(tokenWETHPair).swap(\n\t\t\ttoken == token0 ? outTokens : 0,\n\t\t\ttoken == token1 ? outTokens : 0,\n\t\t\taddress(this),\n\t\t\t\"\"\n\t\t);\n\n\t\treturn _addLiquidity(outTokens, buyAmount, to);\n\t}\n\n\t/**\n\t * @notice Quote WETH amount from PRNT\n\t * @param tokenAmount PRNT amount\n\t * @return optimalWETHAmount Output WETH amount\n\t */\n\tfunction quoteFromToken(uint256 tokenAmount) public view returns (uint256 optimalWETHAmount) {\n\t\t(uint256 wethReserve, uint256 tokenReserve) = _getPairReserves();\n\t\toptimalWETHAmount = UniswapV2Library.quote(tokenAmount, tokenReserve, wethReserve);\n\t}\n\n\t/**\n\t * @notice Quote PRNT amount from WETH\n\t * @param wethAmount PRNT amount\n\t * @return optimalTokenAmount Output PRNT amount\n\t */\n\tfunction quote(uint256 wethAmount) public view returns (uint256 optimalTokenAmount) {\n\t\t(uint256 wethReserve, uint256 tokenReserve) = _getPairReserves();\n\t\toptimalTokenAmount = UniswapV2Library.quote(wethAmount, wethReserve, tokenReserve);\n\t}\n\n\t/**\n\t * @notice Add liquidity with PRNT and WETH\n\t * @dev use with quote\n\t * @param tokenAmount PRNT amount\n\t * @param _wethAmt WETH amount\n\t * @param to LP address to be transferred\n\t * @return liquidity LP amount\n\t */\n\tfunction standardAdd(uint256 tokenAmount, uint256 _wethAmt, address payable to) public returns (uint256) {\n\t\tif (to == address(0)) revert AddressZero();\n\t\tif (tokenAmount == 0 || _wethAmt == 0) revert InvalidETHAmount();\n\t\tIERC20(token).safeTransferFrom(msg.sender, address(this), tokenAmount);\n\t\tweth.transferFrom(msg.sender, address(this), _wethAmt);\n\t\treturn _addLiquidity(tokenAmount, _wethAmt, to);\n\t}\n\n\t/**\n\t * @notice Add liquidity with PRNT and WETH\n\t * @dev use with quote\n\t * @param tokenAmount PRNT amount\n\t * @param wethAmount WETH amount\n\t * @param to LP address to be transferred\n\t * @return liquidity LP amount\n\t */\n\tfunction _addLiquidity(\n\t\tuint256 tokenAmount,\n\t\tuint256 wethAmount,\n\t\taddress payable to\n\t) internal returns (uint256 liquidity) {\n\t\tuint256 optimalTokenAmount = quote(wethAmount);\n\n\t\tuint256 optimalWETHAmount;\n\t\tif (optimalTokenAmount > tokenAmount) {\n\t\t\toptimalWETHAmount = quoteFromToken(tokenAmount);\n\t\t\toptimalTokenAmount = tokenAmount;\n\t\t} else {\n\t\t\toptimalWETHAmount = wethAmount;\n\t\t}\n\n\t\tbool wethTransferSuccess = weth.transfer(tokenWETHPair, optimalWETHAmount);\n\t\tif (!wethTransferSuccess) revert TransferFailed();\n\t\tIERC20(token).safeTransfer(tokenWETHPair, optimalTokenAmount);\n\n\t\tliquidity = IUniswapV2Pair(tokenWETHPair).mint(to);\n\n\t\t//refund dust\n\t\t_refundDust(token, address(weth), to);\n\t}\n\n\t/**\n\t * @notice LP token amount entitled with ETH\n\t * @param ethAmt ETH amount\n\t * @return liquidity LP amount\n\t */\n\tfunction getLPTokenPerEthUnit(uint256 ethAmt) public view returns (uint256 liquidity) {\n\t\t(uint256 reserveWeth, uint256 reserveTokens) = _getPairReserves();\n\t\tuint256 outTokens = UniswapV2Library.getAmountOut(ethAmt / 2, reserveWeth, reserveTokens);\n\t\tuint256 _totalSupply = IUniswapV2Pair(tokenWETHPair).totalSupply();\n\n\t\t(address token0, ) = UniswapV2Library.sortTokens(address(weth), token);\n\t\t(uint256 amount0, uint256 amount1) = token0 == token ? (outTokens, ethAmt / 2) : (ethAmt / 2, outTokens);\n\t\t(uint256 _reserve0, uint256 _reserve1) = token0 == token\n\t\t\t? (reserveTokens, reserveWeth)\n\t\t\t: (reserveWeth, reserveTokens);\n\t\tliquidity = Math.min((amount0 * _totalSupply) / _reserve0, (amount1 * _totalSupply) / _reserve1);\n\t}\n\n\t/**\n\t * @notice Get amount of lp reserves\n\t * @return wethReserves WETH amount\n\t * @return tokenReserves PRNT amount\n\t */\n\tfunction _getPairReserves() internal view returns (uint256 wethReserves, uint256 tokenReserves) {\n\t\t(address token0, ) = UniswapV2Library.sortTokens(address(weth), token);\n\t\t(uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(tokenWETHPair).getReserves();\n\t\t(wethReserves, tokenReserves) = token0 == token ? (reserve1, reserve0) : (reserve0, reserve1);\n\t}\n\n\t/**\n\t * @notice Calculates slippage ratio from weth to PRNT\n\t * @param _ethAmt ETH amount\n\t * @param _tokens PRNT token amount\n\t */\n\tfunction _calcSlippage(uint256 _ethAmt, uint256 _tokens) internal returns (uint256 ratio) {\n\t\tpriceProvider.update();\n\t\tuint256 tokenAmtEth = (_tokens * priceProvider.getTokenPrice() * 1e18) / (10 ** priceProvider.decimals()); // price decimal is 8\n\t\tratio = (tokenAmtEth * RATIO_DIVISOR) / _ethAmt;\n\t\tratio = ratio / 1E18;\n\t}\n}\n"
    },
    "contracts/prime/zap/helpers/UniswapPoolHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {DustRefunder} from \"./DustRefunder.sol\";\nimport {UniswapV2Library} from \"@uniswap/lib/contracts/libraries/UniswapV2Library.sol\";\nimport {IUniswapV2Pair} from \"@uniswap/lib/contracts/interfaces/IUniswapV2Pair.sol\";\nimport {IUniswapV2Factory} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {HomoraMath} from \"../../../dependencies/math/HomoraMath.sol\";\nimport {IUniswapV2Router02} from \"../../../interfaces/uniswap/IUniswapV2Router02.sol\";\nimport {ILiquidityZap} from \"../../../interfaces/ILiquidityZap.sol\";\nimport {IWETH} from \"../../../interfaces/IWETH.sol\";\n\n/// @title Uniswap Pool Helper Contract\n/// @author Prime\ncontract UniswapPoolHelper is Initializable, OwnableUpgradeable, DustRefunder {\n\tusing SafeERC20 for IERC20;\n\tusing HomoraMath for uint256;\n\n\t/********************** Events ***********************/\n\tevent LiquidityZapUpdated(address indexed _liquidityZap);\n\n\tevent LockZapUpdated(address indexed _lockZap);\n\n\t/********************** Errors ***********************/\n\terror AddressZero();\n\terror InsufficientPermission();\n\n\taddress public lpTokenAddr;\n\taddress public prntAddr;\n\taddress public wethAddr;\n\n\tIUniswapV2Router02 public router;\n\tILiquidityZap public liquidityZap;\n\taddress public lockZap;\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Initializer\n\t * @param _prntAddr PRNT address\n\t * @param _wethAddr WETH address\n\t * @param _routerAddr Uniswap router address\n\t * @param _liquidityZap LiquidityZap addrress\n\t */\n\tfunction initialize(\n\t\taddress _prntAddr,\n\t\taddress _wethAddr,\n\t\taddress _routerAddr,\n\t\tILiquidityZap _liquidityZap\n\t) external initializer {\n\t\tif (_prntAddr == address(0)) revert AddressZero();\n\t\tif (_wethAddr == address(0)) revert AddressZero();\n\t\tif (_routerAddr == address(0)) revert AddressZero();\n\t\tif (address(_liquidityZap) == address(0)) revert AddressZero();\n\n\t\t__Ownable_init();\n\n\t\tprntAddr = _prntAddr;\n\t\twethAddr = _wethAddr;\n\n\t\trouter = IUniswapV2Router02(_routerAddr);\n\t\tliquidityZap = _liquidityZap;\n\t}\n\n\t/**\n\t * @notice Initialize PRNT/WETH pool and liquidity zap\n\t */\n\tfunction initializePool() public onlyOwner {\n\t\tlpTokenAddr = IUniswapV2Factory(router.factory()).createPair(prntAddr, wethAddr);\n\n\t\tIERC20 prnt = IERC20(prntAddr);\n\t\tprnt.forceApprove(address(router), type(uint256).max);\n\t\tprnt.forceApprove(address(liquidityZap), type(uint256).max);\n\t\tIERC20(wethAddr).approve(address(liquidityZap), type(uint256).max);\n\t\tIERC20(wethAddr).approve(address(router), type(uint256).max);\n\n\t\trouter.addLiquidity(\n\t\t\taddress(prnt),\n\t\t\twethAddr,\n\t\t\tprnt.balanceOf(address(this)),\n\t\t\tIERC20(wethAddr).balanceOf(address(this)),\n\t\t\t0,\n\t\t\t0,\n\t\t\taddress(this),\n\t\t\tblock.timestamp\n\t\t);\n\n\t\tIERC20 lp = IERC20(lpTokenAddr);\n\t\tlp.safeTransfer(msg.sender, lp.balanceOf(address(this)));\n\t}\n\n\t/**\n\t * @notice Gets needed WETH for adding LP\n\t * @param lpAmount LP amount\n\t * @return wethAmount WETH amount\n\t */\n\tfunction quoteWETH(uint256 lpAmount) public view returns (uint256 wethAmount) {\n\t\tIUniswapV2Pair lpToken = IUniswapV2Pair(lpTokenAddr);\n\n\t\t(uint256 reserve0, uint256 reserve1, ) = lpToken.getReserves();\n\t\tuint256 weth = lpToken.token0() != address(prntAddr) ? reserve0 : reserve1;\n\t\tuint256 prnt = lpToken.token0() == address(prntAddr) ? reserve0 : reserve1;\n\t\tuint256 lpTokenSupply = lpToken.totalSupply();\n\n\t\tuint256 neededPrnt = (prnt * lpAmount) / lpTokenSupply;\n\t\tuint256 neededWeth = (prnt * lpAmount) / lpTokenSupply;\n\n\t\tuint256 neededPrntInWeth = router.getAmountIn(neededPrnt, weth, prnt);\n\t\treturn neededWeth + neededPrntInWeth;\n\t}\n\n\t/**\n\t * @notice Zap WETH into LP\n\t * @param amount of WETH\n\t * @return liquidity LP token amount\n\t */\n\tfunction zapWETH(uint256 amount) public returns (uint256 liquidity) {\n\t\tif (msg.sender != lockZap) revert InsufficientPermission();\n\t\tIWETH weth = IWETH(wethAddr);\n\t\tweth.transferFrom(msg.sender, address(liquidityZap), amount);\n\t\tliquidityZap.addLiquidityWETHOnly(amount, payable(address(this)));\n\t\tIERC20 lp = IERC20(lpTokenAddr);\n\n\t\tliquidity = lp.balanceOf(address(this));\n\t\tlp.safeTransfer(msg.sender, liquidity);\n\t\t_refundDust(prntAddr, wethAddr, msg.sender);\n\t}\n\n\t/**\n\t * @notice Returns reserve information.\n\t * @return prnt PRNT amount\n\t * @return weth WETH amount\n\t * @return lpTokenSupply LP token supply\n\t */\n\tfunction getReserves() public view returns (uint256 prnt, uint256 weth, uint256 lpTokenSupply) {\n\t\tIUniswapV2Pair lpToken = IUniswapV2Pair(lpTokenAddr);\n\n\t\t(uint256 reserve0, uint256 reserve1, ) = lpToken.getReserves();\n\t\tweth = lpToken.token0() != address(prntAddr) ? reserve0 : reserve1;\n\t\tprnt = lpToken.token0() == address(prntAddr) ? reserve0 : reserve1;\n\n\t\tlpTokenSupply = lpToken.totalSupply();\n\t}\n\n\t// UniV2 / SLP LP Token Price\n\t// Alpha Homora Fair LP Pricing Method (flash loan resistant)\n\t// https://cmichel.io/pricing-lp-tokens/\n\t// https://blog.alphafinance.io/fair-lp-token-pricing/\n\t// https://github.com/AlphaFinanceLab/alpha-homora-v2-contract/blob/master/contracts/oracle/UniswapV2Oracle.sol\n\t/**\n\t * @notice Returns LP price\n\t * @param prntPriceInEth price of PRNT in ETH\n\t * @return priceInEth LP price in ETH\n\t */\n\tfunction getLpPrice(uint256 prntPriceInEth) public view returns (uint256 priceInEth) {\n\t\t(uint256 prntReserve, uint256 wethReserve, uint256 lpSupply) = getReserves();\n\n\t\tuint256 sqrtK = HomoraMath.sqrt(prntReserve * wethReserve).fdiv(lpSupply); // in 2**112\n\n\t\t// prnt in eth, decis 8\n\t\tuint256 px0 = prntPriceInEth * (2 ** 112); // in 2**112\n\t\t// eth in eth, decis 8\n\t\tuint256 px1 = uint256(100_000_000) * (2 ** 112); // in 2**112\n\n\t\t// fair token0 amt: sqrtK * sqrt(px1/px0)\n\t\t// fair token1 amt: sqrtK * sqrt(px0/px1)\n\t\t// fair lp price = 2 * sqrt(px0 * px1)\n\t\t// split into 2 sqrts multiplication to prevent uint256 overflow (note the 2**112)\n\t\tuint256 result = (((sqrtK * 2 * (HomoraMath.sqrt(px0))) / (2 ** 56)) * (HomoraMath.sqrt(px1))) / (2 ** 56);\n\t\tpriceInEth = result / (2 ** 112);\n\t}\n\n\t/**\n\t * @notice Zap WETH and RDNt into LP\n\t * @param _wethAmt amount of WETH\n\t * @param _prntAmt amount of PRNT\n\t * @return liquidity LP token amount\n\t */\n\tfunction zapTokens(uint256 _wethAmt, uint256 _prntAmt) public returns (uint256 liquidity) {\n\t\tif (msg.sender != lockZap) revert InsufficientPermission();\n\t\tIWETH weth = IWETH(wethAddr);\n\t\tweth.transferFrom(msg.sender, address(this), _wethAmt);\n\t\tIERC20(prntAddr).safeTransferFrom(msg.sender, address(this), _prntAmt);\n\t\tliquidityZap.standardAdd(_prntAmt, _wethAmt, address(this));\n\t\tIERC20 lp = IERC20(lpTokenAddr);\n\t\tliquidity = lp.balanceOf(address(this));\n\t\tlp.safeTransfer(msg.sender, liquidity);\n\t\t_refundDust(prntAddr, wethAddr, msg.sender);\n\t}\n\n\t/**\n\t * @notice Returns `quote` of PRNT in WETH\n\t * @param tokenAmount amount of PRNT\n\t * @return optimalWETHAmount WETH amount\n\t */\n\tfunction quoteFromToken(uint256 tokenAmount) public view returns (uint256 optimalWETHAmount) {\n\t\toptimalWETHAmount = liquidityZap.quoteFromToken(tokenAmount);\n\t}\n\n\t/**\n\t * @notice Returns LiquidityZap address\n\t */\n\tfunction getLiquidityZap() public view returns (address) {\n\t\treturn address(liquidityZap);\n\t}\n\n\t/**\n\t * @notice Sets new LiquidityZap address\n\t * @param _liquidityZap LiquidityZap address\n\t */\n\tfunction setLiquidityZap(address _liquidityZap) external onlyOwner {\n\t\tif (_liquidityZap == address(0)) revert AddressZero();\n\t\tliquidityZap = ILiquidityZap(_liquidityZap);\n\t\temit LiquidityZapUpdated(_liquidityZap);\n\t}\n\n\t/**\n\t * @notice Sets new LockZap address\n\t * @param _lockZap LockZap address\n\t */\n\tfunction setLockZap(address _lockZap) external onlyOwner {\n\t\tif (_lockZap == address(0)) revert AddressZero();\n\t\tlockZap = _lockZap;\n\t\temit LockZapUpdated(_lockZap);\n\t}\n\n\t/**\n\t * @notice Returns PRNT price in ETH\n\t * @return priceInEth price of PRNT\n\t */\n\tfunction getPrice() public view returns (uint256 priceInEth) {\n\t\t(uint256 prnt, uint256 weth, ) = getReserves();\n\t\tif (prnt > 0) {\n\t\t\tpriceInEth = (weth * (10 ** 8)) / prnt;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Calculate quote in WETH from token\n\t * @param _inToken input token\n\t * @param _wethAmount WETH amount\n\t * @return tokenAmount token amount\n\t */\n\tfunction quoteSwap(address _inToken, uint256 _wethAmount) public view returns (uint256 tokenAmount) {\n\t\taddress[] memory path = new address[](2);\n\t\tpath[0] = _inToken;\n\t\tpath[1] = wethAddr;\n\t\tuint256[] memory amountsIn = router.getAmountsIn(_wethAmount, path);\n\t\treturn amountsIn[0];\n\t}\n\n\t/**\n\t * @dev Helper function to swap a token to weth given an {_inToken} and swap {_amount}.\n\t * Will revert if the output is under the {_minAmountOut}\n\t * @param _inToken Input token for swap\n\t * @param _amount Amount of input tokens\n\t * @param _minAmountOut Minimum output amount\n\t */\n\tfunction swapToWeth(address _inToken, uint256 _amount, uint256 _minAmountOut) external {\n\t\tif (msg.sender != lockZap) revert InsufficientPermission();\n\t\taddress[] memory path = new address[](2);\n\t\tpath[0] = _inToken;\n\t\tpath[1] = wethAddr;\n\t\tIERC20(_inToken).forceApprove(address(router), _amount);\n\t\trouter.swapExactTokensForTokens(_amount, _minAmountOut, path, msg.sender, block.timestamp);\n\t}\n}\n"
    },
    "contracts/prime/zap/LockZap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {DustRefunder} from \"./helpers/DustRefunder.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {IMultiFeeDistribution} from \"../../interfaces/IMultiFeeDistribution.sol\";\nimport {ILendingPool, DataTypes} from \"../../interfaces/ILendingPool.sol\";\nimport {IPoolHelper} from \"../../interfaces/IPoolHelper.sol\";\nimport {IPriceProvider} from \"../../interfaces/IPriceProvider.sol\";\nimport {IAaveOracle} from \"../../interfaces/IAaveOracle.sol\";\nimport {IChainlinkAggregator} from \"../../interfaces/IChainlinkAggregator.sol\";\nimport {IWETH} from \"../../interfaces/IWETH.sol\";\nimport {IPriceOracle} from \"../../interfaces/IPriceOracle.sol\";\nimport {TransferHelper} from \"../libraries/TransferHelper.sol\";\nimport {UniV2Helper} from \"../libraries/UniV2Helper.sol\";\n\n/// @title LockZap contract\n/// @author Prime\ncontract LockZap is Initializable, OwnableUpgradeable, PausableUpgradeable, DustRefunder {\n\tusing SafeERC20 for IERC20;\n\n\t/// @notice The maximum amount of slippage that a user can set for the execution of Zaps\n\t/// @dev If the slippage limit of the LockZap contract is lower then that of the Compounder, transactions might fail unexpectedly.\n\t///      Therefore ensure that this slippage limit is equal to that of the Compounder contract.\n\tuint256 public constant MAX_SLIPPAGE = 8500; //15%\n\n\t/// @notice RATIO Divisor\n\tuint256 public constant RATIO_DIVISOR = 10000;\n\n\t/// @notice Base Percent\n\tuint256 public constant BASE_PERCENT = 100;\n\n\t/// @notice Borrow rate mode\n\tuint256 public constant VARIABLE_INTEREST_RATE_MODE = 2;\n\n\t/// @notice We don't utilize any specific referral code for borrows perfomed via zaps\n\tuint16 public constant REFERRAL_CODE = 0;\n\n\t/// @notice Wrapped ETH\n\tIWETH public weth;\n\n\t/// @notice PRNT token address\n\taddress public prntAddr;\n\n\t/// @notice Multi Fee distribution contract\n\tIMultiFeeDistribution public mfd;\n\n\t/// @notice Lending Pool contract\n\tILendingPool public lendingPool;\n\n\t/// @notice Pool helper contract used for PRNT-WETH swaps\n\tIPoolHelper public poolHelper;\n\n\t/// @notice Price provider contract\n\tIPriceProvider public priceProvider;\n\n\t/// @notice aave oracle contract\n\tIAaveOracle public aaveOracle;\n\n\t/// @notice parameter to set the ratio of ETH in the LP token, can be 2000 for an 80/20 bal lp\n\tuint256 public ethLPRatio;\n\n\t/// @notice AMM router used for all non PRNT-WETH swaps on Arbitrum\n\taddress public uniRouter;\n\n\t/********************** Events ***********************/\n\t/// @notice Emitted when zap is done\n\tevent Zapped(\n\t\tbool _borrow,\n\t\tuint256 _ethAmt,\n\t\tuint256 _prntAmt,\n\t\taddress indexed _from,\n\t\taddress indexed _onBehalf,\n\t\tuint256 _lockTypeIndex\n\t);\n\n\tevent PriceProviderUpdated(address indexed _provider);\n\n\tevent MfdUpdated(address indexed _mfdAddr);\n\n\tevent PoolHelperUpdated(address indexed _poolHelper);\n\n\tevent UniRouterUpdated(address indexed _uniRouter);\n\n\t/********************** Errors ***********************/\n\terror AddressZero();\n\n\terror InvalidRatio();\n\n\terror InvalidLockLength();\n\n\terror AmountZero();\n\n\terror SlippageTooHigh();\n\n\terror SpecifiedSlippageExceedLimit();\n\n\terror InvalidZapETHSource();\n\n\terror ReceivedETHOnAlternativeAssetZap();\n\n\terror InsufficientETH();\n\n\terror EthTransferFailed();\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Initializer\n\t * @param _rndtPoolHelper Pool helper address used for PRNT-WETH swaps\n\t * @param _uniRouter UniV2 router address used for all non PRNT-WETH swaps\n\t * @param _lendingPool Lending pool\n\t * @param _weth weth address\n\t * @param _prntAddr PRNT token address\n\t * @param _ethLPRatio ratio of ETH in the LP token, can be 2000 for an 80/20 bal lp\n\t * @param _aaveOracle Aave oracle address\n\t */\n\tfunction initialize(\n\t\tIPoolHelper _rndtPoolHelper,\n\t\taddress _uniRouter,\n\t\tILendingPool _lendingPool,\n\t\tIWETH _weth,\n\t\taddress _prntAddr,\n\t\tuint256 _ethLPRatio,\n\t\tIAaveOracle _aaveOracle\n\t) external initializer {\n\t\tif (address(_rndtPoolHelper) == address(0)) revert AddressZero();\n\t\tif (address(_uniRouter) == address(0)) revert AddressZero();\n\t\tif (address(_lendingPool) == address(0)) revert AddressZero();\n\t\tif (address(_weth) == address(0)) revert AddressZero();\n\t\tif (_prntAddr == address(0)) revert AddressZero();\n\t\tif (_ethLPRatio == 0 || _ethLPRatio >= RATIO_DIVISOR) revert InvalidRatio();\n\t\tif (address(_aaveOracle) == address(0)) revert AddressZero();\n\n\t\t__Ownable_init();\n\t\t__Pausable_init();\n\n\t\tlendingPool = _lendingPool;\n\t\tpoolHelper = _rndtPoolHelper;\n\t\tuniRouter = _uniRouter;\n\t\tweth = _weth;\n\t\tprntAddr = _prntAddr;\n\t\tethLPRatio = _ethLPRatio;\n\t\taaveOracle = _aaveOracle;\n\t}\n\n\treceive() external payable {}\n\n\t/**\n\t * @notice Set Price Provider.\n\t * @param _provider Price provider contract address.\n\t */\n\tfunction setPriceProvider(address _provider) external onlyOwner {\n\t\tif (_provider == address(0)) revert AddressZero();\n\t\tpriceProvider = IPriceProvider(_provider);\n\t\temit PriceProviderUpdated(_provider);\n\t}\n\n\t/**\n\t * @notice Set AAVE Oracle used to fetch asset prices in USD.\n\t * @param _aaveOracle oracle contract address.\n\t */\n\tfunction setAaveOracle(address _aaveOracle) external onlyOwner {\n\t\tif (_aaveOracle == address(0)) revert AddressZero();\n\t\taaveOracle = IAaveOracle(_aaveOracle);\n\t}\n\n\t/**\n\t * @notice Set Multi fee distribution contract.\n\t * @param _mfdAddr New contract address.\n\t */\n\tfunction setMfd(address _mfdAddr) external onlyOwner {\n\t\tif (_mfdAddr == address(0)) revert AddressZero();\n\t\tmfd = IMultiFeeDistribution(_mfdAddr);\n\t\temit MfdUpdated(_mfdAddr);\n\t}\n\n\t/**\n\t * @notice Set Pool Helper contract used fror WETH-PRNT swaps\n\t * @param _poolHelper New PoolHelper contract address.\n\t */\n\tfunction setPoolHelper(address _poolHelper) external onlyOwner {\n\t\tif (_poolHelper == address(0)) revert AddressZero();\n\t\tpoolHelper = IPoolHelper(_poolHelper);\n\t\temit PoolHelperUpdated(_poolHelper);\n\t}\n\n\t/**\n\t * @notice Set Univ2 style router contract address used for all non PRNT<>WETH swaps\n\t * @param _uniRouter New PoolHelper contract address.\n\t */\n\tfunction setUniRouter(address _uniRouter) external onlyOwner {\n\t\tif (_uniRouter == address(0)) revert AddressZero();\n\t\tuniRouter = _uniRouter;\n\t\temit UniRouterUpdated(_uniRouter);\n\t}\n\n\t/**\n\t * @notice Returns pool helper address used for PRNT-WETH swaps\n\t */\n\tfunction getPoolHelper() external view returns (address) {\n\t\treturn address(poolHelper);\n\t}\n\n\t/**\n\t * @notice Returns uni router address used for all non PRNT-WETH swaps\n\t */\n\tfunction getUniRouter() external view returns (address) {\n\t\treturn address(uniRouter);\n\t}\n\n\t/**\n\t * @notice Get Variable debt token address\n\t * @param _asset underlying.\n\t */\n\tfunction getVDebtToken(address _asset) external view returns (address) {\n\t\tDataTypes.ReserveData memory reserveData = lendingPool.getReserveData(_asset);\n\t\treturn reserveData.variableDebtTokenAddress;\n\t}\n\n\t/**\n\t * @notice Calculate amount of specified tokens received for selling PRNT\n\t * @dev this function is mainly used to calculate how much of the specified token is needed to match the provided PRNT amount when providing liquidity to an AMM\n\t * @param _token address of the token that would be received\n\t * @param _amount of PRNT to be sold\n\t * @return amount of _token received\n\t */\n\tfunction quoteFromToken(address _token, uint256 _amount) public view returns (uint256) {\n\t\taddress weth_ = address(weth);\n\t\tif (_token != weth_) {\n\t\t\tuint256 wethAmount = poolHelper.quoteFromToken(_amount);\n\t\t\treturn UniV2Helper._quoteSwap(uniRouter, weth_, _token, wethAmount);\n\t\t}\n\t\treturn poolHelper.quoteFromToken(_amount);\n\t}\n\n\t/**\n\t * @notice Zap tokens to stake LP\n\t * @param _borrow option to borrow ETH\n\t * @param _asset to be used for zapping\n\t * @param _assetAmt amount of weth.\n\t * @param _prntAmt amount of PRNT.\n\t * @param _lockTypeIndex lock length index.\n\t * @param _slippage maximum amount of slippage allowed for any occurring trades\n\t * @return LP amount\n\t */\n\tfunction zap(\n\t\tbool _borrow,\n\t\taddress _asset,\n\t\tuint256 _assetAmt,\n\t\tuint256 _prntAmt,\n\t\tuint256 _lockTypeIndex,\n\t\tuint256 _slippage\n\t) public payable whenNotPaused returns (uint256) {\n\t\treturn\n\t\t\t_zap(_borrow, _asset, _assetAmt, _prntAmt, msg.sender, msg.sender, _lockTypeIndex, msg.sender, _slippage);\n\t}\n\n\t/**\n\t * @notice Zap tokens to stake LP\n\t * @dev It will use default lock index\n\t * @param _borrow option to borrow ETH\n\t * @param _asset to be used for zapping\n\t * @param _assetAmt amount of weth.\n\t * @param _prntAmt amount of PRNT.\n\t * @param _onBehalf user address to be zapped.\n\t * @param _slippage maximum amount of slippage allowed for any occurring trades\n\t * @return LP amount\n\t */\n\tfunction zapOnBehalf(\n\t\tbool _borrow,\n\t\taddress _asset,\n\t\tuint256 _assetAmt,\n\t\tuint256 _prntAmt,\n\t\taddress _onBehalf,\n\t\tuint256 _slippage\n\t) public payable whenNotPaused returns (uint256) {\n\t\tuint256 duration = mfd.defaultLockIndex(_onBehalf);\n\t\treturn _zap(_borrow, _asset, _assetAmt, _prntAmt, msg.sender, _onBehalf, duration, _onBehalf, _slippage);\n\t}\n\n\t/**\n\t * @notice Zap tokens from vesting\n\t * @param _borrow option to borrow ETH\n\t * @param _asset to be used for zapping\n\t * @param _assetAmt amount of _asset tokens used to create dLP position\n\t * @param _lockTypeIndex lock length index. cannot be shortest option (index 0)\n\t * @param _slippage maximum amount of slippage allowed for any occurring trades\n\t * @return LP amount\n\t */\n\tfunction zapFromVesting(\n\t\tbool _borrow,\n\t\taddress _asset,\n\t\tuint256 _assetAmt,\n\t\tuint256 _lockTypeIndex,\n\t\tuint256 _slippage\n\t) public payable whenNotPaused returns (uint256) {\n\t\tif (_lockTypeIndex == 0) revert InvalidLockLength();\n\t\tuint256 prntAmt = mfd.zapVestingToLp(msg.sender);\n\n\t\treturn\n\t\t\t_zap(_borrow, _asset, _assetAmt, prntAmt, address(this), msg.sender, _lockTypeIndex, msg.sender, _slippage);\n\t}\n\n\t/**\n\t * @notice Calculates slippage ratio from usd value to LP\n\t * @param _assetValueUsd amount value in USD used to create LP pair\n\t * @param _liquidity LP token amount\n\t */\n\tfunction _calcSlippage(uint256 _assetValueUsd, uint256 _liquidity) internal returns (uint256 ratio) {\n\t\tpriceProvider.update();\n\t\tuint256 lpAmountValueUsd = (_liquidity * priceProvider.getLpTokenPriceUsd()) / 1E18;\n\t\tratio = (lpAmountValueUsd * (RATIO_DIVISOR)) / (_assetValueUsd);\n\t}\n\n\t/**\n\t * @notice Zap into LP\n\t * @param _borrow option to borrow ETH\n\t * @param _asset that will be used to zap.\n\t * @param _assetAmt amount of assets to be zapped\n\t * @param _prntAmt amount of PRNT.\n\t * @param _from src address of PRNT\n\t * @param _onBehalf of the user.\n\t * @param _lockTypeIndex lock length index.\n\t * @param _refundAddress dust is refunded to this address.\n\t * @param _slippage maximum amount of slippage allowed for any occurring trades\n\t * @return liquidity LP amount\n\t */\n\tfunction _zap(\n\t\tbool _borrow,\n\t\taddress _asset,\n\t\tuint256 _assetAmt,\n\t\tuint256 _prntAmt,\n\t\taddress _from,\n\t\taddress _onBehalf,\n\t\tuint256 _lockTypeIndex,\n\t\taddress _refundAddress,\n\t\tuint256 _slippage\n\t) internal returns (uint256 liquidity) {\n\t\tIWETH weth_ = weth;\n\t\tif (_asset == address(0)) {\n\t\t\t_asset = address(weth_);\n\t\t}\n\t\tif (_slippage == 0) {\n\t\t\t_slippage = MAX_SLIPPAGE;\n\t\t} else {\n\t\t\tif (MAX_SLIPPAGE > _slippage || _slippage > RATIO_DIVISOR) revert SpecifiedSlippageExceedLimit();\n\t\t}\n\t\tbool isAssetWeth = _asset == address(weth_);\n\n\t\t// Handle pure ETH\n\t\tif (msg.value > 0) {\n\t\t\tif (!isAssetWeth) revert ReceivedETHOnAlternativeAssetZap();\n\t\t\tif (_borrow) revert InvalidZapETHSource();\n\t\t\t_assetAmt = msg.value;\n\t\t\tweth_.deposit{value: _assetAmt}();\n\t\t}\n\t\tif (_assetAmt == 0) revert AmountZero();\n\t\tuint256 assetAmountValueUsd = (_assetAmt * aaveOracle.getAssetPrice(_asset)) /\n\t\t\t(10 ** IERC20Metadata(_asset).decimals());\n\n\t\t// Handle borrowing logic\n\t\tif (_borrow) {\n\t\t\t// Borrow the asset on the users behalf\n\t\t\tlendingPool.borrow(_asset, _assetAmt, VARIABLE_INTEREST_RATE_MODE, REFERRAL_CODE, msg.sender);\n\n\t\t\t// If asset isn't WETH, swap for WETH\n\t\t\tif (!isAssetWeth) {\n\t\t\t\t_assetAmt = UniV2Helper._swap(uniRouter, _asset, address(weth_), _assetAmt);\n\t\t\t}\n\t\t} else if (msg.value == 0) {\n\t\t\t// Transfer asset from user\n\t\t\tIERC20(_asset).transferFrom(msg.sender, address(this), _assetAmt);\n\t\t\tif (!isAssetWeth) {\n\t\t\t\t_assetAmt = UniV2Helper._swap(uniRouter, _asset, address(weth_), _assetAmt);\n\t\t\t}\n\t\t}\n\n\t\tweth_.approve(address(poolHelper), _assetAmt);\n\t\t//case where prnt is matched with provided ETH\n\t\tif (_prntAmt != 0) {\n\t\t\t// _from == this when zapping from vesting\n\t\t\tif (_from != address(this)) {\n\t\t\t\tIERC20(prntAddr).safeTransferFrom(msg.sender, address(this), _prntAmt);\n\t\t\t}\n\n\t\t\tIERC20(prntAddr).forceApprove(address(poolHelper), _prntAmt);\n\t\t\tliquidity = poolHelper.zapTokens(_assetAmt, _prntAmt);\n\t\t\tassetAmountValueUsd = (assetAmountValueUsd * RATIO_DIVISOR) / ethLPRatio;\n\t\t} else {\n\t\t\tliquidity = poolHelper.zapWETH(_assetAmt);\n\t\t}\n\n\t\tif (address(priceProvider) != address(0)) {\n\t\t\tif (_calcSlippage(assetAmountValueUsd, liquidity) < _slippage) revert SlippageTooHigh();\n\t\t}\n\n\t\tIERC20(poolHelper.lpTokenAddr()).forceApprove(address(mfd), liquidity);\n\t\tmfd.stake(liquidity, _onBehalf, _lockTypeIndex);\n\t\temit Zapped(_borrow, _assetAmt, _prntAmt, _from, _onBehalf, _lockTypeIndex);\n\n\t\t_refundDust(prntAddr, _asset, _refundAddress);\n\t}\n\n\t/**\n\t * @notice Pause zapping operation.\n\t */\n\tfunction pause() external onlyOwner {\n\t\t_pause();\n\t}\n\n\t/**\n\t * @notice Unpause zapping operation.\n\t */\n\tfunction unpause() external onlyOwner {\n\t\t_unpause();\n\t}\n\n\t/**\n\t * @notice Allows owner to recover ETH locked in this contract.\n\t * @param to ETH receiver\n\t * @param value ETH amount\n\t */\n\tfunction withdrawLockedETH(address to, uint256 value) external onlyOwner {\n\t\tTransferHelper.safeTransferETH(to, value);\n\t}\n}\n"
    },
    "contracts/test/CustomERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract CustomERC20 is ERC20 {\n\tconstructor(uint256 amount) ERC20(\"Custom\", \"Custom\") {\n\t\t_mint(msg.sender, amount);\n\t}\n\n\tfunction setMinter(address minter) external returns (bool) {}\n\n\tfunction mint(address receiver, uint256 amount) external returns (bool successful) {\n\t\t_mint(receiver, amount);\n\t\treturn true;\n\t}\n\n\tfunction burn(uint256 amount) external returns (bool successful) {\n\t\t_burn(msg.sender, amount);\n\t\treturn true;\n\t}\n}\n"
    },
    "contracts/test/lz/interfaces/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n\t// @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n\t// @param _dstChainId - the destination chain identifier\n\t// @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n\t// @param _payload - a custom bytes payload to send to the destination contract\n\t// @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n\t// @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n\t// @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n\tfunction send(\n\t\tuint16 _dstChainId,\n\t\tbytes calldata _destination,\n\t\tbytes calldata _payload,\n\t\taddress payable _refundAddress,\n\t\taddress _zroPaymentAddress,\n\t\tbytes calldata _adapterParams\n\t) external payable;\n\n\t// @notice used by the messaging library to publish verified payload\n\t// @param _srcChainId - the source chain identifier\n\t// @param _srcAddress - the source contract (as bytes) at the source chain\n\t// @param _dstAddress - the address on destination chain\n\t// @param _nonce - the unbound message ordering nonce\n\t// @param _gasLimit - the gas limit for external contract execution\n\t// @param _payload - verified payload to send to the destination contract\n\tfunction receivePayload(\n\t\tuint16 _srcChainId,\n\t\tbytes calldata _srcAddress,\n\t\taddress _dstAddress,\n\t\tuint64 _nonce,\n\t\tuint _gasLimit,\n\t\tbytes calldata _payload\n\t) external;\n\n\t// @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n\t// @param _srcChainId - the source chain identifier\n\t// @param _srcAddress - the source chain contract address\n\tfunction getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n\t// @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n\t// @param _srcAddress - the source chain contract address\n\tfunction getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n\t// @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n\t// @param _dstChainId - the destination chain identifier\n\t// @param _userApplication - the user app address on this EVM chain\n\t// @param _payload - the custom message to send over LayerZero\n\t// @param _payInZRO - if false, user app pays the protocol fee in native token\n\t// @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n\tfunction estimateFees(\n\t\tuint16 _dstChainId,\n\t\taddress _userApplication,\n\t\tbytes calldata _payload,\n\t\tbool _payInZRO,\n\t\tbytes calldata _adapterParam\n\t) external view returns (uint nativeFee, uint zroFee);\n\n\t// @notice get this Endpoint's immutable source identifier\n\tfunction getChainId() external view returns (uint16);\n\n\t// @notice the interface to retry failed message on this Endpoint destination\n\t// @param _srcChainId - the source chain identifier\n\t// @param _srcAddress - the source chain contract address\n\t// @param _payload - the payload to be retried\n\tfunction retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n\t// @notice query if any STORED payload (message blocking) at the endpoint.\n\t// @param _srcChainId - the source chain identifier\n\t// @param _srcAddress - the source chain contract address\n\tfunction hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n\t// @notice query if the _libraryAddress is valid for sending msgs.\n\t// @param _userApplication - the user app address on this EVM chain\n\tfunction getSendLibraryAddress(address _userApplication) external view returns (address);\n\n\t// @notice query if the _libraryAddress is valid for receiving msgs.\n\t// @param _userApplication - the user app address on this EVM chain\n\tfunction getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n\t// @notice query if the non-reentrancy guard for send() is on\n\t// @return true if the guard is on. false otherwise\n\tfunction isSendingPayload() external view returns (bool);\n\n\t// @notice query if the non-reentrancy guard for receive() is on\n\t// @return true if the guard is on. false otherwise\n\tfunction isReceivingPayload() external view returns (bool);\n\n\t// @notice get the configuration of the LayerZero messaging library of the specified version\n\t// @param _version - messaging library version\n\t// @param _chainId - the chainId for the pending config change\n\t// @param _userApplication - the contract address of the user application\n\t// @param _configType - type of configuration. every messaging library has its own convention.\n\tfunction getConfig(\n\t\tuint16 _version,\n\t\tuint16 _chainId,\n\t\taddress _userApplication,\n\t\tuint _configType\n\t) external view returns (bytes memory);\n\n\t// @notice get the send() LayerZero messaging library version\n\t// @param _userApplication - the contract address of the user application\n\tfunction getSendVersion(address _userApplication) external view returns (uint16);\n\n\t// @notice get the lzReceive() LayerZero messaging library version\n\t// @param _userApplication - the contract address of the user application\n\tfunction getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "contracts/test/lz/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroReceiver {\n\t// @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n\t// @param _srcChainId - the source endpoint identifier\n\t// @param _srcAddress - the source sending contract address from the source chain\n\t// @param _nonce - the ordered message nonce\n\t// @param _payload - the signed payload is the UA bytes has encoded to be sent\n\tfunction lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\n}\n"
    },
    "contracts/test/lz/interfaces/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroUserApplicationConfig {\n\t// @notice set the configuration of the LayerZero messaging library of the specified version\n\t// @param _version - messaging library version\n\t// @param _chainId - the chainId for the pending config change\n\t// @param _configType - type of configuration. every messaging library has its own convention.\n\t// @param _config - configuration in the bytes. can encode arbitrary content.\n\tfunction setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\n\n\t// @notice set the send() LayerZero messaging library version to _version\n\t// @param _version - new messaging library version\n\tfunction setSendVersion(uint16 _version) external;\n\n\t// @notice set the lzReceive() LayerZero messaging library version to _version\n\t// @param _version - new messaging library version\n\tfunction setReceiveVersion(uint16 _version) external;\n\n\t// @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n\t// @param _srcChainId - the chainId of the source chain\n\t// @param _srcAddress - the contract address of the source contract at the source chain\n\tfunction forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "contracts/test/lz/LZEndpointMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n\n/*\nmocking multi endpoint connection.\n- send() will short circuit to lzReceive() directly\n- no reentrancy guard. the real LayerZero endpoint on main net has a send and receive guard, respectively.\nif we run a ping-pong-like application, the recursive call might use all gas limit in the block.\n- not using any messaging library, hence all messaging library func, e.g. estimateFees, version, will not work\n*/\ncontract LZEndpointMock is ILayerZeroEndpoint {\n\tmapping(address => address) public lzEndpointLookup;\n\n\tuint16 public mockChainId;\n\taddress payable public mockOracle;\n\taddress payable public mockRelayer;\n\tuint public mockBlockConfirmations;\n\tuint16 public mockLibraryVersion;\n\tuint public mockStaticNativeFee;\n\tuint16 public mockLayerZeroVersion;\n\tuint public nativeFee;\n\tuint public zroFee;\n\tbool nextMsgBLocked;\n\n\tstruct StoredPayload {\n\t\tuint64 payloadLength;\n\t\taddress dstAddress;\n\t\tbytes32 payloadHash;\n\t}\n\n\tstruct QueuedPayload {\n\t\taddress dstAddress;\n\t\tuint64 nonce;\n\t\tbytes payload;\n\t}\n\n\t// inboundNonce = [srcChainId][srcAddress].\n\tmapping(uint16 => mapping(bytes => uint64)) public inboundNonce;\n\t// outboundNonce = [dstChainId][srcAddress].\n\tmapping(uint16 => mapping(address => uint64)) public outboundNonce;\n\t// storedPayload = [srcChainId][srcAddress]\n\tmapping(uint16 => mapping(bytes => StoredPayload)) public storedPayload;\n\t// msgToDeliver = [srcChainId][srcAddress]\n\tmapping(uint16 => mapping(bytes => QueuedPayload[])) public msgsToDeliver;\n\n\tevent UaForceResumeReceive(uint16 chainId, bytes srcAddress);\n\tevent PayloadCleared(uint16 srcChainId, bytes srcAddress, uint64 nonce, address dstAddress);\n\tevent PayloadStored(\n\t\tuint16 srcChainId,\n\t\tbytes srcAddress,\n\t\taddress dstAddress,\n\t\tuint64 nonce,\n\t\tbytes payload,\n\t\tbytes reason\n\t);\n\n\tconstructor(uint16 _chainId) {\n\t\tmockStaticNativeFee = 42;\n\t\tmockLayerZeroVersion = 1;\n\t\tmockChainId = _chainId;\n\t}\n\n\t// mock helper to set the value returned by `estimateNativeFees`\n\tfunction setEstimatedFees(uint _nativeFee, uint _zroFee) public {\n\t\tnativeFee = _nativeFee;\n\t\tzroFee = _zroFee;\n\t}\n\n\tfunction getChainId() external view override returns (uint16) {\n\t\treturn mockChainId;\n\t}\n\n\tfunction setDestLzEndpoint(address destAddr, address lzEndpointAddr) external {\n\t\tlzEndpointLookup[destAddr] = lzEndpointAddr;\n\t}\n\n\tfunction send(\n\t\tuint16 _chainId,\n\t\tbytes calldata _destination,\n\t\tbytes calldata _payload,\n\t\taddress payable, // _refundAddress\n\t\taddress, // _zroPaymentAddress\n\t\tbytes memory _adapterParams\n\t) external payable override {\n\t\taddress destAddr = packedBytesToAddr(_destination);\n\t\taddress lzEndpoint = lzEndpointLookup[destAddr];\n\n\t\trequire(lzEndpoint != address(0), \"LayerZeroMock: destination LayerZero Endpoint not found\");\n\n\t\trequire(msg.value >= nativeFee * _payload.length, \"LayerZeroMock: not enough native for fees\");\n\n\t\tuint64 nonce;\n\t\t{\n\t\t\tnonce = ++outboundNonce[_chainId][msg.sender];\n\t\t}\n\n\t\t// Mock the relayer paying the dstNativeAddr the amount of extra native token\n\t\t{\n\t\t\tuint extraGas;\n\t\t\tuint dstNative;\n\t\t\taddress dstNativeAddr;\n\t\t\tassembly {\n\t\t\t\textraGas := mload(add(_adapterParams, 34))\n\t\t\t\tdstNative := mload(add(_adapterParams, 66))\n\t\t\t\tdstNativeAddr := mload(add(_adapterParams, 86))\n\t\t\t}\n\n\t\t\t// to simulate actually sending the ether, add a transfer call and ensure the LZEndpointMock contract has an ether balance\n\t\t}\n\n\t\tbytes memory bytesSourceUserApplicationAddr = addrToPackedBytes(address(msg.sender)); // cast this address to bytes\n\n\t\t// not using the extra gas parameter because this is a single tx call, not split between different chains\n\t\t// LZEndpointMock(lzEndpoint).receivePayload(mockChainId, bytesSourceUserApplicationAddr, destAddr, nonce, extraGas, _payload);\n\t\tLZEndpointMock(lzEndpoint).receivePayload(\n\t\t\tmockChainId,\n\t\t\tbytesSourceUserApplicationAddr,\n\t\t\tdestAddr,\n\t\t\tnonce,\n\t\t\t0,\n\t\t\t_payload\n\t\t);\n\t}\n\n\tfunction receivePayload(\n\t\tuint16 _srcChainId,\n\t\tbytes calldata _srcAddress,\n\t\taddress _dstAddress,\n\t\tuint64 _nonce,\n\t\tuint /*_gasLimit*/,\n\t\tbytes calldata _payload\n\t) external override {\n\t\tStoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n\n\t\t// assert and increment the nonce. no message shuffling\n\t\trequire(_nonce == ++inboundNonce[_srcChainId][_srcAddress], \"LayerZero: wrong nonce\");\n\n\t\t// queue the following msgs inside of a stack to simulate a successful send on src, but not fully delivered on dst\n\t\tif (sp.payloadHash != bytes32(0)) {\n\t\t\tQueuedPayload[] storage msgs = msgsToDeliver[_srcChainId][_srcAddress];\n\t\t\tQueuedPayload memory newMsg = QueuedPayload(_dstAddress, _nonce, _payload);\n\n\t\t\t// warning, might run into gas issues trying to forward through a bunch of queued msgs\n\t\t\t// shift all the msgs over so we can treat this like a fifo via array.pop()\n\t\t\tif (msgs.length > 0) {\n\t\t\t\t// extend the array\n\t\t\t\tmsgs.push(newMsg);\n\n\t\t\t\t// shift all the indexes up for pop()\n\t\t\t\tfor (uint i = 0; i < msgs.length - 1; i++) {\n\t\t\t\t\tmsgs[i + 1] = msgs[i];\n\t\t\t\t}\n\n\t\t\t\t// put the newMsg at the bottom of the stack\n\t\t\t\tmsgs[0] = newMsg;\n\t\t\t} else {\n\t\t\t\tmsgs.push(newMsg);\n\t\t\t}\n\t\t} else if (nextMsgBLocked) {\n\t\t\tstoredPayload[_srcChainId][_srcAddress] = StoredPayload(\n\t\t\t\tuint64(_payload.length),\n\t\t\t\t_dstAddress,\n\t\t\t\tkeccak256(_payload)\n\t\t\t);\n\t\t\temit PayloadStored(_srcChainId, _srcAddress, _dstAddress, _nonce, _payload, bytes(\"\"));\n\t\t\t// ensure the next msgs that go through are no longer blocked\n\t\t\tnextMsgBLocked = false;\n\t\t} else {\n\t\t\t// we ignore the gas limit because this call is made in one tx due to being \"same chain\"\n\t\t\t// ILayerZeroReceiver(_dstAddress).lzReceive{gas: _gasLimit}(_srcChainId, _srcAddress, _nonce, _payload); // invoke lzReceive\n\t\t\tILayerZeroReceiver(_dstAddress).lzReceive(_srcChainId, _srcAddress, _nonce, _payload); // invoke lzReceive\n\t\t}\n\t}\n\n\t// used to simulate messages received get stored as a payload\n\tfunction blockNextMsg() external {\n\t\tnextMsgBLocked = true;\n\t}\n\n\tfunction getLengthOfQueue(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint) {\n\t\treturn msgsToDeliver[_srcChainId][_srcAddress].length;\n\t}\n\n\t// @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n\t// @param _dstChainId - the destination chain identifier\n\t// @param _userApplication - the user app address on this EVM chain\n\t// @param _payload - the custom message to send over LayerZero\n\t// @param _payInZRO - if false, user app pays the protocol fee in native token\n\t// @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n\tfunction estimateFees(\n\t\tuint16,\n\t\taddress,\n\t\tbytes memory _payload,\n\t\tbool,\n\t\tbytes memory\n\t) external view override returns (uint _nativeFee, uint _zroFee) {\n\t\t_nativeFee = nativeFee * _payload.length;\n\t\t_zroFee = zroFee;\n\t}\n\n\t// give 20 bytes, return the decoded address\n\tfunction packedBytesToAddr(bytes calldata _b) public pure returns (address) {\n\t\taddress addr;\n\t\tassembly {\n\t\t\tlet ptr := mload(0x40)\n\t\t\tcalldatacopy(ptr, sub(_b.offset, 2), add(_b.length, 2))\n\t\t\taddr := mload(sub(ptr, 10))\n\t\t}\n\t\treturn addr;\n\t}\n\n\t// given an address, return the 20 bytes\n\tfunction addrToPackedBytes(address _a) public pure returns (bytes memory) {\n\t\tbytes memory data = abi.encodePacked(_a);\n\t\treturn data;\n\t}\n\n\tfunction setConfig(\n\t\tuint16 /*_version*/,\n\t\tuint16 /*_chainId*/,\n\t\tuint /*_configType*/,\n\t\tbytes memory /*_config*/\n\t) external override {}\n\n\tfunction getConfig(\n\t\tuint16 /*_version*/,\n\t\tuint16 /*_chainId*/,\n\t\taddress /*_ua*/,\n\t\tuint /*_configType*/\n\t) external pure override returns (bytes memory) {\n\t\treturn \"\";\n\t}\n\n\tfunction setSendVersion(uint16 /*version*/) external override {}\n\n\tfunction setReceiveVersion(uint16 /*version*/) external override {}\n\n\tfunction getSendVersion(address /*_userApplication*/) external pure override returns (uint16) {\n\t\treturn 1;\n\t}\n\n\tfunction getReceiveVersion(address /*_userApplication*/) external pure override returns (uint16) {\n\t\treturn 1;\n\t}\n\n\tfunction getInboundNonce(uint16 _chainID, bytes calldata _srcAddress) external view override returns (uint64) {\n\t\treturn inboundNonce[_chainID][_srcAddress];\n\t}\n\n\tfunction getOutboundNonce(uint16 _chainID, address _srcAddress) external view override returns (uint64) {\n\t\treturn outboundNonce[_chainID][_srcAddress];\n\t}\n\n\t// simulates the relayer pushing through the rest of the msgs that got delayed due to the stored payload\n\tfunction _clearMsgQue(uint16 _srcChainId, bytes calldata _srcAddress) internal {\n\t\tQueuedPayload[] storage msgs = msgsToDeliver[_srcChainId][_srcAddress];\n\n\t\t// warning, might run into gas issues trying to forward through a bunch of queued msgs\n\t\twhile (msgs.length > 0) {\n\t\t\tQueuedPayload memory payload = msgs[msgs.length - 1];\n\t\t\tILayerZeroReceiver(payload.dstAddress).lzReceive(_srcChainId, _srcAddress, payload.nonce, payload.payload);\n\t\t\tmsgs.pop();\n\t\t}\n\t}\n\n\tfunction forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n\t\tStoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n\t\t// revert if no messages are cached. safeguard malicious UA behaviour\n\t\trequire(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n\t\trequire(sp.dstAddress == msg.sender, \"LayerZero: invalid caller\");\n\n\t\t// empty the storedPayload\n\t\tsp.payloadLength = 0;\n\t\tsp.dstAddress = address(0);\n\t\tsp.payloadHash = bytes32(0);\n\n\t\temit UaForceResumeReceive(_srcChainId, _srcAddress);\n\n\t\t// resume the receiving of msgs after we force clear the \"stuck\" msg\n\t\t_clearMsgQue(_srcChainId, _srcAddress);\n\t}\n\n\tfunction retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external override {\n\t\tStoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n\t\trequire(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n\t\trequire(\n\t\t\t_payload.length == sp.payloadLength && keccak256(_payload) == sp.payloadHash,\n\t\t\t\"LayerZero: invalid payload\"\n\t\t);\n\n\t\taddress dstAddress = sp.dstAddress;\n\t\t// empty the storedPayload\n\t\tsp.payloadLength = 0;\n\t\tsp.dstAddress = address(0);\n\t\tsp.payloadHash = bytes32(0);\n\n\t\tuint64 nonce = inboundNonce[_srcChainId][_srcAddress];\n\n\t\tILayerZeroReceiver(dstAddress).lzReceive(_srcChainId, _srcAddress, nonce, _payload);\n\t\temit PayloadCleared(_srcChainId, _srcAddress, nonce, dstAddress);\n\t}\n\n\tfunction hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (bool) {\n\t\tStoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n\t\treturn sp.payloadHash != bytes32(0);\n\t}\n\n\tfunction isSendingPayload() external pure override returns (bool) {\n\t\treturn false;\n\t}\n\n\tfunction isReceivingPayload() external pure override returns (bool) {\n\t\treturn false;\n\t}\n\n\tfunction getSendLibraryAddress(address) external view override returns (address) {\n\t\treturn address(this);\n\t}\n\n\tfunction getReceiveLibraryAddress(address) external view override returns (address) {\n\t\treturn address(this);\n\t}\n}\n"
    },
    "contracts/test/MockBountyManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\n/// @title MockBountyManager Contract\n/// @author Prime Devs\n/// @dev All function calls are currently implemented without side effects\ncontract MockBountyManager {\n\t/**\n\t * @notice Minimum locked lp balance\n\t */\n\tfunction minDLPBalance() public pure returns (uint256 min) {\n\t\tmin = 1000000;\n\t}\n}\n"
    },
    "contracts/test/MockChainlinkAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ncontract MockChainlinkAggregator {\n\tint256 price;\n\tuint256 newUpdatedAt = 1681179848;\n\n\tconstructor(int256 _price) {\n\t\tprice = _price;\n\t}\n\n\tfunction latestAnswer() external view returns (int256) {\n\t\treturn price;\n\t}\n\n\tfunction decimals() external pure returns (int256) {\n\t\treturn 8;\n\t}\n\n\tfunction setPrice(int256 _price) external {\n\t\tprice = _price;\n\t}\n\n\tfunction setUpdatedAt(uint256 _updatedAt) external {\n\t\tnewUpdatedAt = _updatedAt;\n\t}\n\n\tfunction latestRoundData()\n\t\tpublic\n\t\tview\n\t\treturns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n\t{\n\t\troundId = 18446744073709552278;\n\t\tanswer = price;\n\t\tstartedAt = 1681179848;\n\t\tupdatedAt = newUpdatedAt;\n\t\tansweredInRound = 18446744073709552278;\n\t}\n}\n"
    },
    "contracts/test/mockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface mockERC20 is IERC20 {\n\tfunction mint(uint256 amount) external;\n}\n"
    },
    "contracts/test/MockIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockIncentivesController {\n\tfunction beforeLockUpdate(address user) external {}\n\n\tfunction afterLockUpdate(address user) external {}\n\n\tfunction addPool(address _token, uint256 _allocPoint) external {}\n\n\tfunction claim(address _user, address[] calldata _tokens) external {}\n}\n"
    },
    "contracts/test/MockMFD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"../prime/staking/MultiFeeDistribution.sol\";\n\ncontract MockMFD is MultiFeeDistribution {\n\tfunction relock() external pure override {\n\t\treturn;\n\t}\n\n\t// solc-ignore-next-line unused-param\n\tfunction setRelock(bool _status) external override {\n\t\tautoRelockDisabled[msg.sender] = true;\n\t}\n}\n"
    },
    "contracts/test/MockMiddleFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockMiddleFeeDistribution {\n\tfunction forwardReward(address[] memory _rewardTokens) external {}\n}\n"
    },
    "contracts/test/MockNewChefIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"../prime/staking/ChefIncentivesController.sol\";\n\ncontract MockNewChefIncentivesController is ChefIncentivesController {\n\tfunction mockNewFunction() external pure returns (bool) {\n\t\treturn true;\n\t}\n}\n"
    },
    "contracts/test/MockNewMiddleFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"../prime/staking/MiddleFeeDistribution.sol\";\n\ncontract MockNewMiddleFeeDistribution is MiddleFeeDistribution {\n\tfunction mockNewFunction() external pure returns (bool) {\n\t\treturn true;\n\t}\n}\n"
    },
    "contracts/test/MockNewMultiFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"../prime/staking/MultiFeeDistribution.sol\";\n\ncontract MockNewMultiFeeDistribution is MultiFeeDistribution {\n\tfunction mockNewFunction() external pure returns (bool) {\n\t\treturn true;\n\t}\n}\n"
    },
    "contracts/test/MockNewPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"../prime/oracles/PriceProvider.sol\";\n\ncontract MockNewPriceProvider is PriceProvider {\n\tfunction mockNewFunction() external pure returns (bool) {\n\t\treturn true;\n\t}\n}\n"
    },
    "contracts/test/MockOFTReceiverV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ncontract MockOFTReceiverV2 {\n\t/**\n\t * @dev Called by the OFT contract when tokens are received from source chain.\n\t * @param _srcChainId The chain id of the source chain.\n\t * @param _srcAddress The address of the OFT token contract on the source chain.\n\t * @param _nonce The nonce of the transaction on the source chain.\n\t * @param _from The address of the account who calls the sendAndCall() on the source chain.\n\t * @param _amount The amount of tokens to transfer.\n\t * @param _payload Additional data with no specified format.\n\t */\n\tfunction onOFTReceived(\n\t\tuint16 _srcChainId,\n\t\tbytes calldata _srcAddress,\n\t\tuint64 _nonce,\n\t\tbytes32 _from,\n\t\tuint _amount,\n\t\tbytes calldata _payload\n\t) external {}\n}\n"
    },
    "contracts/test/MockOnwardIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"../prime/staking/ChefIncentivesController.sol\";\nimport \"../interfaces/IOnwardIncentivesController.sol\";\n\ncontract MockOnwardIncentivesController is IOnwardIncentivesController {\n\tfunction handleAction(address _token, address _user, uint256 _balance, uint256 _totalSupply) external override {}\n}\n"
    },
    "contracts/test/MockPoolHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockPoolHelper {\n\tfunction getLpPrice() external pure returns (uint256) {\n\t\treturn 42;\n\t}\n}\n"
    },
    "contracts/test/MockPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ncontract MockPriceProvider {\n\tfunction update() external {}\n\n\tfunction getTokenPrice() public pure returns (uint256) {\n\t\treturn 10000000; // Mock price\n\t}\n\n\tfunction decimals() public pure returns (uint256) {\n\t\treturn 8;\n\t}\n}\n"
    },
    "contracts/test/MockToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// this is a MOCK\ncontract MockToken is ERC20 {\n\tuint8 private decimals_;\n\n\tconstructor(string memory _name, string memory _symbol, uint8 _decimals) ERC20(_name, _symbol) {\n\t\tdecimals_ = _decimals;\n\t}\n\n\tfunction mint(address _to, uint256 _amount) public {\n\t\t_mint(_to, _amount);\n\t}\n\n\tfunction decimals() public view override returns (uint8) {\n\t\treturn decimals_;\n\t}\n}\n"
    },
    "contracts/test/oracle/LendingRateOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {ILendingRateOracle} from \"../../interfaces/ILendingRateOracle.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract LendingRateOracle is ILendingRateOracle, Ownable {\n\tmapping(address => uint256) borrowRates;\n\tmapping(address => uint256) liquidityRates;\n\n\tfunction getMarketBorrowRate(address _asset) external view override returns (uint256) {\n\t\treturn borrowRates[_asset];\n\t}\n\n\tfunction setMarketBorrowRate(address _asset, uint256 _rate) external override onlyOwner {\n\t\tborrowRates[_asset] = _rate;\n\t}\n\n\tfunction getMarketLiquidityRate(address _asset) external view returns (uint256) {\n\t\treturn liquidityRates[_asset];\n\t}\n\n\tfunction setMarketLiquidityRate(address _asset, uint256 _rate) external onlyOwner {\n\t\tliquidityRates[_asset] = _rate;\n\t}\n}\n"
    },
    "contracts/test/oracle/MockArbitrumSequencerUptimeFeed.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {ISequencerAggregator} from \"../../interfaces/ISequencerAggregator.sol\";\n\ncontract MockArbitrumSequencerUptimeFeed {\n\taddress public aliasedL1MessageSender;\n\tISequencerAggregator public sequencer = ISequencerAggregator(0xFdB631F5EE196F0ed6FAa767959853A9F217697D);\n\n\tconstructor() {\n\t\taliasedL1MessageSender = msg.sender;\n\t}\n\n\tfunction updateStatus(bool status, uint64 timestamp) external {\n\t\tsequencer.updateStatus(status, timestamp);\n\t}\n}\n"
    },
    "contracts/test/oracle/MockSequencerAggregator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract MockSequencerAggregator {\n\taddress public aggregator;\n\tuint80 private roundId;\n\tint256 private answer;\n\tuint256 private startedAt;\n\tuint256 private updatedAt;\n\tuint80 private answeredInRound;\n\n\terror AddressZero();\n\terror NotUptimeFeed();\n\n\tfunction init(address _aggregator) external {\n\t\taggregator = _aggregator;\n\t\troundId++;\n\t\tanswer = 0;\n\t\tstartedAt = block.timestamp;\n\t\tupdatedAt = block.timestamp;\n\t\tansweredInRound++;\n\t}\n\n\tfunction latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80) {\n\t\treturn (roundId, answer, startedAt, updatedAt, answeredInRound);\n\t}\n\n\tfunction updateStatus(bool status, uint64 timestamp) external {\n\t\tif (status) {\n\t\t\tanswer = 1;\n\t\t\troundId++;\n\t\t\tstartedAt = uint256(timestamp);\n\t\t\tupdatedAt = uint256(timestamp);\n\t\t\tansweredInRound++;\n\t\t} else {\n\t\t\tanswer = 0;\n\t\t\troundId++;\n\t\t\tstartedAt = uint256(timestamp);\n\t\t\tupdatedAt = uint256(timestamp);\n\t\t\tansweredInRound++;\n\t\t}\n\t}\n}\n"
    },
    "contracts/test/oracle/MockUniV2TwapOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\ncontract MockUniV2TwapOracle {\n\tfunction canUpdate() public pure returns (bool) {\n\t\treturn true;\n\t}\n\n\tfunction update() external {}\n\n\t// assumes 18 decimal token\n\t// returns USD price in decimal 8\n\tfunction latestAnswer() public pure returns (uint256 price) {\n\t\treturn 10 * 8;\n\t}\n\n\tfunction latestAnswerInEth() public pure returns (uint256 price) {\n\t\treturn 10 * 8;\n\t}\n}\n"
    },
    "contracts/test/stargate/IStargateRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.12;\n\ninterface IStargateRouter {\n\tstruct lzTxObj {\n\t\tuint256 dstGasForCall;\n\t\tuint256 dstNativeAmount;\n\t\tbytes dstNativeAddr;\n\t}\n\n\tfunction swap(\n\t\tuint16 _dstChainId,\n\t\tuint256 _srcPoolId,\n\t\tuint256 _dstPoolId,\n\t\taddress payable _refundAddress,\n\t\tuint256 _amountLD,\n\t\tuint256 _minAmountLD,\n\t\tlzTxObj memory _lzTxParams,\n\t\tbytes calldata _to,\n\t\tbytes calldata _payload\n\t) external payable;\n\n\tfunction quoteLayerZeroFee(\n\t\tuint16 _dstChainId,\n\t\tuint8 _functionType,\n\t\tbytes calldata _toAddress,\n\t\tbytes calldata _transferAndCallPayload,\n\t\tlzTxObj memory _lzTxParams\n\t) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/test/stargate/Router.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.12;\n\nimport \"./IStargateRouter.sol\";\n\ncontract MockRouter is IStargateRouter {\n\tconstructor() {}\n\n\tfunction swap(\n\t\tuint16 _dstChainId,\n\t\tuint256 _srcPoolId,\n\t\tuint256 _dstPoolId,\n\t\taddress payable _refundAddress,\n\t\tuint256 _amountLD,\n\t\tuint256 _minAmountLD,\n\t\tlzTxObj memory _lzTxParams,\n\t\tbytes calldata _to,\n\t\tbytes calldata _payload\n\t) external payable override {}\n\n\tfunction quoteLayerZeroFee(\n\t\tuint16,\n\t\tuint8,\n\t\tbytes calldata,\n\t\tbytes calldata,\n\t\tMockRouter.lzTxObj memory\n\t) external pure override returns (uint256, uint256) {\n\t\treturn (1, 2);\n\t}\n}\n"
    },
    "contracts/test/stargate/RouterETH.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.12;\n\ncontract MockRouterETH {\n\tconstructor() {}\n\n\tfunction swapETH(\n\t\tuint16 _dstChainId, // destination Stargate chainId\n\t\taddress payable _refundAddress, // refund additional messageFee to this address\n\t\tbytes calldata _toAddress, // the receiver of the destination ETH\n\t\tuint256 _amountLD, // the amount, in Local Decimals, to be swapped\n\t\tuint256 _minAmountLD // the minimum amount accepted out on destination\n\t) external payable {}\n}\n"
    },
    "contracts/test/StaticPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ncontract StaticPriceProvider {\n\tfunction update() external {}\n\n\tfunction getTokenPrice() public pure returns (uint256) {\n\t\treturn 100000;\n\t}\n\n\tfunction decimals() public pure returns (uint256) {\n\t\treturn 8;\n\t}\n}\n"
    },
    "contracts/test/TestAdminOperation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TestAdminOperation is Ownable {\n\tfunction test(uint256) external view onlyOwner returns (uint256) {\n\t\treturn 0x0000000000000000000000000000000000000000000000000000000000000054;\n\t}\n}\n"
    },
    "contracts/test/TestLockZap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"../prime/zap/LockZap.sol\";\nimport \"../interfaces/IPoolHelper.sol\";\n\ncontract TestnetLockZap is LockZap {\n\tfunction sell(uint256 _amount) public returns (uint256 ethOut) {\n\t\tIERC20(prntAddr).transferFrom(msg.sender, address(poolHelper), _amount);\n\t\treturn ITestPoolHelper(address(poolHelper)).sell(_amount);\n\t}\n}\n"
    },
    "contracts/test/TestUniswapPoolHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../prime/zap/helpers/UniswapPoolHelper.sol\";\n\ncontract TestUniswapPoolHelper is UniswapPoolHelper {\n\tusing SafeERC20 for IERC20;\n\n\tfunction swap(uint256 _amount, address, address, address) public returns (uint256 amountOut) {\n\t\tIUniswapV2Pair lpToken = IUniswapV2Pair(lpTokenAddr);\n\t\t(uint256 reserve0, uint256 reserve1, ) = lpToken.getReserves();\n\n\t\t(address token0, address token1) = UniswapV2Library.sortTokens(address(wethAddr), prntAddr);\n\n\t\tuint256 reserveWeth = token0 == address(wethAddr) ? reserve0 : reserve1;\n\t\tuint256 reserveTokens = token0 == address(wethAddr) ? reserve1 : reserve0;\n\n\t\tuint256 outETH = UniswapV2Library.getAmountOut(_amount, reserveTokens, reserveWeth);\n\n\t\tIERC20(prntAddr).safeTransfer(lpTokenAddr, _amount);\n\n\t\tIUniswapV2Pair(lpTokenAddr).swap(\n\t\t\taddress(wethAddr) == token0 ? outETH : 0,\n\t\t\taddress(wethAddr) == token1 ? outETH : 0,\n\t\t\taddress(this),\n\t\t\t\"\"\n\t\t);\n\n\t\tamountOut = IERC20(address(wethAddr)).balanceOf(address(this));\n\t}\n\n\tfunction sell(uint256 _amount) public returns (uint256 amountOut) {\n\t\treturn\n\t\t\tswap(\n\t\t\t\t_amount,\n\t\t\t\t0x0000000000000000000000000000000000000000,\n\t\t\t\t0x0000000000000000000000000000000000000000,\n\t\t\t\t0x0000000000000000000000000000000000000000\n\t\t\t);\n\t}\n}\n"
    },
    "contracts/test/uniswap/core/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n\tfunction feeTo() external view returns (address);\n\n\tfunction feeToSetter() external view returns (address);\n\n\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\n\n\tfunction allPairs(uint) external view returns (address pair);\n\n\tfunction allPairsLength() external view returns (uint);\n\n\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\n\n\tfunction setFeeTo(address) external;\n\n\tfunction setFeeToSetter(address) external;\n\n\tfunction getInitHash() external view returns (bytes32);\n}\n"
    },
    "contracts/test/uniswap/core/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n\t// credit for this implementation goes to\n\t// https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n\tfunction sqrt(uint256 x) internal pure returns (uint256) {\n\t\tif (x == 0) return 0;\n\t\t// this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n\t\t// however that code costs significantly more gas\n\t\tuint256 xx = x;\n\t\tuint256 r = 1;\n\t\tif (xx >= 0x100000000000000000000000000000000) {\n\t\t\txx >>= 128;\n\t\t\tr <<= 64;\n\t\t}\n\t\tif (xx >= 0x10000000000000000) {\n\t\t\txx >>= 64;\n\t\t\tr <<= 32;\n\t\t}\n\t\tif (xx >= 0x100000000) {\n\t\t\txx >>= 32;\n\t\t\tr <<= 16;\n\t\t}\n\t\tif (xx >= 0x10000) {\n\t\t\txx >>= 16;\n\t\t\tr <<= 8;\n\t\t}\n\t\tif (xx >= 0x100) {\n\t\t\txx >>= 8;\n\t\t\tr <<= 4;\n\t\t}\n\t\tif (xx >= 0x10) {\n\t\t\txx >>= 4;\n\t\t\tr <<= 2;\n\t\t}\n\t\tif (xx >= 0x8) {\n\t\t\tr <<= 1;\n\t\t}\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1; // Seven iterations should be enough\n\t\tuint256 r1 = x / r;\n\t\treturn (r < r1 ? r : r1);\n\t}\n}\n"
    },
    "contracts/test/uniswap/core/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\nlibrary BitMath {\n\t// returns the 0 indexed position of the most significant bit of the input x\n\t// s.t. x >= 2**msb and x < 2**(msb+1)\n\tfunction mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n\t\trequire(x > 0, \"BitMath::mostSignificantBit: zero\");\n\n\t\tif (x >= 0x100000000000000000000000000000000) {\n\t\t\tx >>= 128;\n\t\t\tr += 128;\n\t\t}\n\t\tif (x >= 0x10000000000000000) {\n\t\t\tx >>= 64;\n\t\t\tr += 64;\n\t\t}\n\t\tif (x >= 0x100000000) {\n\t\t\tx >>= 32;\n\t\t\tr += 32;\n\t\t}\n\t\tif (x >= 0x10000) {\n\t\t\tx >>= 16;\n\t\t\tr += 16;\n\t\t}\n\t\tif (x >= 0x100) {\n\t\t\tx >>= 8;\n\t\t\tr += 8;\n\t\t}\n\t\tif (x >= 0x10) {\n\t\t\tx >>= 4;\n\t\t\tr += 4;\n\t\t}\n\t\tif (x >= 0x4) {\n\t\t\tx >>= 2;\n\t\t\tr += 2;\n\t\t}\n\t\tif (x >= 0x2) r += 1;\n\t}\n\n\t// returns the 0 indexed position of the least significant bit of the input x\n\t// s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\n\t// i.e. the bit at the index is set and the mask of all lower bits is 0\n\tfunction leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n\t\trequire(x > 0, \"BitMath::leastSignificantBit: zero\");\n\n\t\tr = 255;\n\t\tif (x & uint128(int128(-1)) > 0) {\n\t\t\tr -= 128;\n\t\t} else {\n\t\t\tx >>= 128;\n\t\t}\n\t\tif (x & uint64(int64(-1)) > 0) {\n\t\t\tr -= 64;\n\t\t} else {\n\t\t\tx >>= 64;\n\t\t}\n\t\tif (x & uint32(int32(-1)) > 0) {\n\t\t\tr -= 32;\n\t\t} else {\n\t\t\tx >>= 32;\n\t\t}\n\t\tif (x & uint16(int16(-1)) > 0) {\n\t\t\tr -= 16;\n\t\t} else {\n\t\t\tx >>= 16;\n\t\t}\n\t\tif (x & uint8(int8(-1)) > 0) {\n\t\t\tr -= 8;\n\t\t} else {\n\t\t\tx >>= 8;\n\t\t}\n\t\tif (x & 0xf > 0) {\n\t\t\tr -= 4;\n\t\t} else {\n\t\t\tx >>= 4;\n\t\t}\n\t\tif (x & 0x3 > 0) {\n\t\t\tr -= 2;\n\t\t} else {\n\t\t\tx >>= 2;\n\t\t}\n\t\tif (x & 0x1 > 0) r -= 1;\n\t}\n}\n"
    },
    "contracts/test/uniswap/core/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.12;\n\nimport \"./FullMath.sol\";\nimport \"./Babylonian.sol\";\nimport \"./BitMath.sol\";\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n\t// range: [0, 2**112 - 1]\n\t// resolution: 1 / 2**112\n\tstruct uq112x112 {\n\t\tuint224 _x;\n\t}\n\n\t// range: [0, 2**144 - 1]\n\t// resolution: 1 / 2**112\n\tstruct uq144x112 {\n\t\tuint256 _x;\n\t}\n\n\tuint8 public constant RESOLUTION = 112;\n\tuint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112\n\tuint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224\n\tuint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n\t// encode a uint112 as a UQ112x112\n\tfunction encode(uint112 x) internal pure returns (uq112x112 memory) {\n\t\treturn uq112x112(uint224(x) << RESOLUTION);\n\t}\n\n\t// encodes a uint144 as a UQ144x112\n\tfunction encode144(uint144 x) internal pure returns (uq144x112 memory) {\n\t\treturn uq144x112(uint256(x) << RESOLUTION);\n\t}\n\n\t// decode a UQ112x112 into a uint112 by truncating after the radix point\n\tfunction decode(uq112x112 memory self) internal pure returns (uint112) {\n\t\treturn uint112(self._x >> RESOLUTION);\n\t}\n\n\t// decode a UQ144x112 into a uint144 by truncating after the radix point\n\tfunction decode144(uq144x112 memory self) internal pure returns (uint144) {\n\t\treturn uint144(self._x >> RESOLUTION);\n\t}\n\n\t// multiply a UQ112x112 by a uint, returning a UQ144x112\n\t// reverts on overflow\n\tfunction mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n\t\tuint256 z = 0;\n\t\trequire(y == 0 || (z = self._x * y) / y == self._x, \"FixedPoint::mul: overflow\");\n\t\treturn uq144x112(z);\n\t}\n\n\t// multiply a UQ112x112 by an int and decode, returning an int\n\t// reverts on overflow\n\tfunction muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\n\t\tuint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);\n\t\trequire(z < 2 ** 255, \"FixedPoint::muli: overflow\");\n\t\treturn y < 0 ? -int256(z) : int256(z);\n\t}\n\n\t// multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\n\t// lossy\n\tfunction muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n\t\tif (self._x == 0 || other._x == 0) {\n\t\t\treturn uq112x112(0);\n\t\t}\n\t\tuint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\n\t\tuint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\n\t\tuint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\n\t\tuint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\n\n\t\t// partial products\n\t\tuint224 upper = uint224(upper_self) * upper_other; // * 2^0\n\t\tuint224 lower = uint224(lower_self) * lower_other; // * 2^-224\n\t\tuint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\n\t\tuint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\n\n\t\t// so the bit shift does not overflow\n\t\trequire(upper <= type(uint112).max, \"FixedPoint::muluq: upper overflow\");\n\n\t\t// this cannot exceed 256 bits, all values are 224 bits\n\t\tuint256 sum = uint256(upper << RESOLUTION) + uppers_lowero + uppero_lowers + (lower >> RESOLUTION);\n\n\t\t// so the cast does not overflow\n\t\trequire(sum <= type(uint224).max, \"FixedPoint::muluq: sum overflow\");\n\n\t\treturn uq112x112(uint224(sum));\n\t}\n\n\t// divide a UQ112x112 by a UQ112x112, returning a UQ112x112\n\tfunction divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n\t\trequire(other._x > 0, \"FixedPoint::divuq: division by zero\");\n\t\tif (self._x == other._x) {\n\t\t\treturn uq112x112(uint224(Q112));\n\t\t}\n\t\tif (self._x <= type(uint144).max) {\n\t\t\tuint256 value = (uint256(self._x) << RESOLUTION) / other._x;\n\t\t\trequire(value <= type(uint224).max, \"FixedPoint::divuq: overflow\");\n\t\t\treturn uq112x112(uint224(value));\n\t\t}\n\n\t\tuint256 result = FullMath.mulDiv(Q112, self._x, other._x);\n\t\trequire(result <= type(uint224).max, \"FixedPoint::divuq: overflow\");\n\t\treturn uq112x112(uint224(result));\n\t}\n\n\t// returns a UQ112x112 which represents the ratio of the numerator to the denominator\n\t// can be lossy\n\tfunction fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n\t\trequire(denominator > 0, \"FixedPoint::fraction: division by zero\");\n\t\tif (numerator == 0) return FixedPoint.uq112x112(0);\n\n\t\tif (numerator <= type(uint144).max) {\n\t\t\tuint256 result = (numerator << RESOLUTION) / denominator;\n\t\t\trequire(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n\t\t\treturn uq112x112(uint224(result));\n\t\t} else {\n\t\t\tuint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n\t\t\trequire(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n\t\t\treturn uq112x112(uint224(result));\n\t\t}\n\t}\n\n\t// take the reciprocal of a UQ112x112\n\t// reverts on overflow\n\t// lossy\n\tfunction reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n\t\trequire(self._x != 0, \"FixedPoint::reciprocal: reciprocal of zero\");\n\t\trequire(self._x != 1, \"FixedPoint::reciprocal: overflow\");\n\t\treturn uq112x112(uint224(Q224 / self._x));\n\t}\n\n\t// square root of a UQ112x112\n\t// lossy between 0/1 and 40 bits\n\tfunction sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n\t\tif (self._x <= type(uint144).max) {\n\t\t\treturn uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\n\t\t}\n\n\t\tuint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\n\t\tsafeShiftBits -= safeShiftBits % 2;\n\t\treturn uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\n\t}\n}\n"
    },
    "contracts/test/uniswap/core/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n\t/// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n\t/// @param a The multiplicand\n\t/// @param b The multiplier\n\t/// @param denominator The divisor\n\t/// @return result The 256-bit result\n\t/// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n\tfunction mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n\t\tunchecked {\n\t\t\t// 512-bit multiply [prod1 prod0] = a * b\n\t\t\t// Compute the product mod 2**256 and mod 2**256 - 1\n\t\t\t// then use the Chinese Remainder Theorem to reconstruct\n\t\t\t// the 512 bit result. The result is stored in two 256\n\t\t\t// variables such that product = prod1 * 2**256 + prod0\n\t\t\tuint256 prod0; // Least significant 256 bits of the product\n\t\t\tuint256 prod1; // Most significant 256 bits of the product\n\t\t\tassembly {\n\t\t\t\tlet mm := mulmod(a, b, not(0))\n\t\t\t\tprod0 := mul(a, b)\n\t\t\t\tprod1 := sub(sub(mm, prod0), lt(mm, prod0))\n\t\t\t}\n\n\t\t\t// Handle non-overflow cases, 256 by 256 division\n\t\t\tif (prod1 == 0) {\n\t\t\t\trequire(denominator > 0);\n\t\t\t\tassembly {\n\t\t\t\t\tresult := div(prod0, denominator)\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// Make sure the result is less than 2**256.\n\t\t\t// Also prevents denominator == 0\n\t\t\trequire(denominator > prod1);\n\n\t\t\t///////////////////////////////////////////////\n\t\t\t// 512 by 256 division.\n\t\t\t///////////////////////////////////////////////\n\n\t\t\t// Make division exact by subtracting the remainder from [prod1 prod0]\n\t\t\t// Compute remainder using mulmod\n\t\t\tuint256 remainder;\n\t\t\tassembly {\n\t\t\t\tremainder := mulmod(a, b, denominator)\n\t\t\t}\n\t\t\t// Subtract 256 bit number from 512 bit number\n\t\t\tassembly {\n\t\t\t\tprod1 := sub(prod1, gt(remainder, prod0))\n\t\t\t\tprod0 := sub(prod0, remainder)\n\t\t\t}\n\n\t\t\t// Factor powers of two out of denominator\n\t\t\t// Compute largest power of two divisor of denominator.\n\t\t\t// Always >= 1.\n\t\t\tuint256 twos = (0 - denominator) & denominator;\n\t\t\t// Divide denominator by power of two\n\t\t\tassembly {\n\t\t\t\tdenominator := div(denominator, twos)\n\t\t\t}\n\n\t\t\t// Divide [prod1 prod0] by the factors of two\n\t\t\tassembly {\n\t\t\t\tprod0 := div(prod0, twos)\n\t\t\t}\n\t\t\t// Shift in bits from prod1 into prod0. For this we need\n\t\t\t// to flip `twos` such that it is 2**256 / twos.\n\t\t\t// If twos is zero, then it becomes one\n\t\t\tassembly {\n\t\t\t\ttwos := add(div(sub(0, twos), twos), 1)\n\t\t\t}\n\t\t\tprod0 |= prod1 * twos;\n\n\t\t\t// Invert denominator mod 2**256\n\t\t\t// Now that denominator is an odd number, it has an inverse\n\t\t\t// modulo 2**256 such that denominator * inv = 1 mod 2**256.\n\t\t\t// Compute the inverse by starting with a seed that is correct\n\t\t\t// correct for four bits. That is, denominator * inv = 1 mod 2**4\n\t\t\tuint256 inv = (3 * denominator) ^ 2;\n\t\t\t// Now use Newton-Raphson iteration to improve the precision.\n\t\t\t// Thanks to Hensel's lifting lemma, this also works in modular\n\t\t\t// arithmetic, doubling the correct bits in each step.\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**8\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**16\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**32\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**64\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**128\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**256\n\n\t\t\t// Because the division is now exact we can divide by multiplying\n\t\t\t// with the modular inverse of denominator. This will give us the\n\t\t\t// correct result modulo 2**256. Since the precoditions guarantee\n\t\t\t// that the outcome is less than 2**256, this is the final result.\n\t\t\t// We don't need to compute the high bits of the result and prod1\n\t\t\t// is no longer required.\n\t\t\tresult = prod0 * inv;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n\t/// @param a The multiplicand\n\t/// @param b The multiplier\n\t/// @param denominator The divisor\n\t/// @return result The 256-bit result\n\tfunction mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n\t\tunchecked {\n\t\t\tresult = mulDiv(a, b, denominator);\n\t\t\tif (mulmod(a, b, denominator) > 0) {\n\t\t\t\trequire(result < type(uint256).max);\n\t\t\t\tresult++;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "contracts/test/uniswap/periphery/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IERC20 {\n\tevent Approval(address indexed owner, address indexed spender, uint value);\n\tevent Transfer(address indexed from, address indexed to, uint value);\n\n\tfunction name() external view returns (string memory);\n\n\tfunction symbol() external view returns (string memory);\n\n\tfunction decimals() external view returns (uint8);\n\n\tfunction totalSupply() external view returns (uint);\n\n\tfunction balanceOf(address owner) external view returns (uint);\n\n\tfunction allowance(address owner, address spender) external view returns (uint);\n\n\tfunction approve(address spender, uint value) external returns (bool);\n\n\tfunction transfer(address to, uint value) external returns (bool);\n\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\n}\n"
    },
    "contracts/test/uniswap/periphery/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n\tfunction factory() external view returns (address);\n\n\tfunction WETH() external view returns (address);\n\n\tfunction addLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint amountADesired,\n\t\tuint amountBDesired,\n\t\tuint amountAMin,\n\t\tuint amountBMin,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint amountA, uint amountB, uint liquidity);\n\n\tfunction addLiquidityETH(\n\t\taddress token,\n\t\tuint amountTokenDesired,\n\t\tuint amountTokenMin,\n\t\tuint amountETHMin,\n\t\taddress to,\n\t\tuint deadline\n\t) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n\tfunction removeLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint liquidity,\n\t\tuint amountAMin,\n\t\tuint amountBMin,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint amountA, uint amountB);\n\n\tfunction removeLiquidityETH(\n\t\taddress token,\n\t\tuint liquidity,\n\t\tuint amountTokenMin,\n\t\tuint amountETHMin,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint amountToken, uint amountETH);\n\n\tfunction swapExactTokensForTokens(\n\t\tuint amountIn,\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint[] memory amounts);\n\n\tfunction swapTokensForExactTokens(\n\t\tuint amountOut,\n\t\tuint amountInMax,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint[] memory amounts);\n\n\tfunction swapExactETHForTokens(\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external payable returns (uint[] memory amounts);\n\n\tfunction swapTokensForExactETH(\n\t\tuint amountOut,\n\t\tuint amountInMax,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint[] memory amounts);\n\n\tfunction swapExactTokensForETH(\n\t\tuint amountIn,\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint[] memory amounts);\n\n\tfunction swapETHForExactTokens(\n\t\tuint amountOut,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external payable returns (uint[] memory amounts);\n\n\tfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n\n\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n\n\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n\n\tfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n\n\tfunction getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/test/uniswap/periphery/interfaces/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.6.2;\n\nimport \"./IUniswapV2Router01.sol\";\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {}\n"
    },
    "contracts/test/uniswap/periphery/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IWETH {\n\tfunction deposit() external payable;\n\n\tfunction transfer(address to, uint value) external returns (bool);\n\n\tfunction withdraw(uint) external;\n\n\tfunction balanceOf(address guy) external returns (uint);\n}\n"
    },
    "contracts/test/uniswap/periphery/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n\t// credit for this implementation goes to\n\t// https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n\tfunction sqrt(uint256 x) internal pure returns (uint256) {\n\t\tif (x == 0) return 0;\n\t\t// this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n\t\t// however that code costs significantly more gas\n\t\tuint256 xx = x;\n\t\tuint256 r = 1;\n\t\tif (xx >= 0x100000000000000000000000000000000) {\n\t\t\txx >>= 128;\n\t\t\tr <<= 64;\n\t\t}\n\t\tif (xx >= 0x10000000000000000) {\n\t\t\txx >>= 64;\n\t\t\tr <<= 32;\n\t\t}\n\t\tif (xx >= 0x100000000) {\n\t\t\txx >>= 32;\n\t\t\tr <<= 16;\n\t\t}\n\t\tif (xx >= 0x10000) {\n\t\t\txx >>= 16;\n\t\t\tr <<= 8;\n\t\t}\n\t\tif (xx >= 0x100) {\n\t\t\txx >>= 8;\n\t\t\tr <<= 4;\n\t\t}\n\t\tif (xx >= 0x10) {\n\t\t\txx >>= 4;\n\t\t\tr <<= 2;\n\t\t}\n\t\tif (xx >= 0x8) {\n\t\t\tr <<= 1;\n\t\t}\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1; // Seven iterations should be enough\n\t\tuint256 r1 = x / r;\n\t\treturn (r < r1 ? r : r1);\n\t}\n}\n"
    },
    "contracts/test/uniswap/periphery/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n\t/// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n\t/// @param a The multiplicand\n\t/// @param b The multiplier\n\t/// @param denominator The divisor\n\t/// @return result The 256-bit result\n\t/// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n\tfunction mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n\t\tunchecked {\n\t\t\t// 512-bit multiply [prod1 prod0] = a * b\n\t\t\t// Compute the product mod 2**256 and mod 2**256 - 1\n\t\t\t// then use the Chinese Remainder Theorem to reconstruct\n\t\t\t// the 512 bit result. The result is stored in two 256\n\t\t\t// variables such that product = prod1 * 2**256 + prod0\n\t\t\tuint256 prod0; // Least significant 256 bits of the product\n\t\t\tuint256 prod1; // Most significant 256 bits of the product\n\t\t\tassembly {\n\t\t\t\tlet mm := mulmod(a, b, not(0))\n\t\t\t\tprod0 := mul(a, b)\n\t\t\t\tprod1 := sub(sub(mm, prod0), lt(mm, prod0))\n\t\t\t}\n\n\t\t\t// Handle non-overflow cases, 256 by 256 division\n\t\t\tif (prod1 == 0) {\n\t\t\t\trequire(denominator > 0);\n\t\t\t\tassembly {\n\t\t\t\t\tresult := div(prod0, denominator)\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// Make sure the result is less than 2**256.\n\t\t\t// Also prevents denominator == 0\n\t\t\trequire(denominator > prod1);\n\n\t\t\t///////////////////////////////////////////////\n\t\t\t// 512 by 256 division.\n\t\t\t///////////////////////////////////////////////\n\n\t\t\t// Make division exact by subtracting the remainder from [prod1 prod0]\n\t\t\t// Compute remainder using mulmod\n\t\t\tuint256 remainder;\n\t\t\tassembly {\n\t\t\t\tremainder := mulmod(a, b, denominator)\n\t\t\t}\n\t\t\t// Subtract 256 bit number from 512 bit number\n\t\t\tassembly {\n\t\t\t\tprod1 := sub(prod1, gt(remainder, prod0))\n\t\t\t\tprod0 := sub(prod0, remainder)\n\t\t\t}\n\n\t\t\t// Factor powers of two out of denominator\n\t\t\t// Compute largest power of two divisor of denominator.\n\t\t\t// Always >= 1.\n\t\t\tuint256 twos = (0 - denominator) & denominator;\n\t\t\t// Divide denominator by power of two\n\t\t\tassembly {\n\t\t\t\tdenominator := div(denominator, twos)\n\t\t\t}\n\n\t\t\t// Divide [prod1 prod0] by the factors of two\n\t\t\tassembly {\n\t\t\t\tprod0 := div(prod0, twos)\n\t\t\t}\n\t\t\t// Shift in bits from prod1 into prod0. For this we need\n\t\t\t// to flip `twos` such that it is 2**256 / twos.\n\t\t\t// If twos is zero, then it becomes one\n\t\t\tassembly {\n\t\t\t\ttwos := add(div(sub(0, twos), twos), 1)\n\t\t\t}\n\t\t\tprod0 |= prod1 * twos;\n\n\t\t\t// Invert denominator mod 2**256\n\t\t\t// Now that denominator is an odd number, it has an inverse\n\t\t\t// modulo 2**256 such that denominator * inv = 1 mod 2**256.\n\t\t\t// Compute the inverse by starting with a seed that is correct\n\t\t\t// correct for four bits. That is, denominator * inv = 1 mod 2**4\n\t\t\tuint256 inv = (3 * denominator) ^ 2;\n\t\t\t// Now use Newton-Raphson iteration to improve the precision.\n\t\t\t// Thanks to Hensel's lifting lemma, this also works in modular\n\t\t\t// arithmetic, doubling the correct bits in each step.\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**8\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**16\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**32\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**64\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**128\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**256\n\n\t\t\t// Because the division is now exact we can divide by multiplying\n\t\t\t// with the modular inverse of denominator. This will give us the\n\t\t\t// correct result modulo 2**256. Since the precoditions guarantee\n\t\t\t// that the outcome is less than 2**256, this is the final result.\n\t\t\t// We don't need to compute the high bits of the result and prod1\n\t\t\t// is no longer required.\n\t\t\tresult = prod0 * inv;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n\t/// @param a The multiplicand\n\t/// @param b The multiplier\n\t/// @param denominator The divisor\n\t/// @return result The 256-bit result\n\tfunction mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n\t\tunchecked {\n\t\t\tresult = mulDiv(a, b, denominator);\n\t\t\tif (mulmod(a, b, denominator) > 0) {\n\t\t\t\trequire(result < type(uint256).max);\n\t\t\t\tresult++;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "contracts/test/uniswap/periphery/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.12;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n\tfunction add(uint x, uint y) internal pure returns (uint z) {\n\t\trequire((z = x + y) >= x, \"ds-math-add-overflow\");\n\t}\n\n\tfunction sub(uint x, uint y) internal pure returns (uint z) {\n\t\trequire((z = x - y) <= x, \"ds-math-sub-underflow\");\n\t}\n\n\tfunction mul(uint x, uint y) internal pure returns (uint z) {\n\t\trequire(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n\t}\n}\n"
    },
    "contracts/test/uniswap/periphery/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n\tfunction safeTransfer(address token, address to, uint256 value) internal {\n\t\t// bytes4(keccak256(bytes('transfer(address,uint256)')));\n\t\t(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n\t\trequire(\n\t\t\tsuccess && (data.length == 0 || abi.decode(data, (bool))),\n\t\t\t\"TransferHelper::safeTransfer: transfer failed\"\n\t\t);\n\t}\n\n\tfunction safeTransferFrom(address token, address from, address to, uint256 value) internal {\n\t\t// bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n\t\t(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n\t\trequire(\n\t\t\tsuccess && (data.length == 0 || abi.decode(data, (bool))),\n\t\t\t\"TransferHelper::transferFrom: transferFrom failed\"\n\t\t);\n\t}\n\n\tfunction safeTransferETH(address to, uint256 value) internal {\n\t\t(bool success, ) = to.call{value: value}(new bytes(0));\n\t\trequire(success, \"TransferHelper::safeTransferETH: ETH transfer failed\");\n\t}\n}\n"
    },
    "contracts/test/uniswap/periphery/libraries/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.12;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n// import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport \"../../core/interfaces/IUniswapV2Factory.sol\";\nimport \"./SafeMath.sol\";\n\nlibrary UniswapV2Library {\n\tusing SafeMath for uint;\n\n\t// returns sorted token addresses, used to handle return values from pairs sorted in this order\n\tfunction sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n\t\trequire(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n\t\t(token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n\t\trequire(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n\t}\n\n\t// calculates the CREATE2 address for a pair without making any external calls\n\tfunction pairFor(address factory, address tokenA, address tokenB) internal view returns (address pair) {\n\t\t(address token0, address token1) = sortTokens(tokenA, tokenB);\n\t\tpair = address(\n\t\t\tuint160(\n\t\t\t\tuint(\n\t\t\t\t\tkeccak256(\n\t\t\t\t\t\tabi.encodePacked(\n\t\t\t\t\t\t\thex\"ff\",\n\t\t\t\t\t\t\tfactory,\n\t\t\t\t\t\t\tkeccak256(abi.encodePacked(token0, token1)),\n\t\t\t\t\t\t\tIUniswapV2Factory(factory).getInitHash()\n\t\t\t\t\t\t\t// hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n\t// fetches and sorts the reserves for a pair\n\tfunction getReserves(\n\t\taddress factory,\n\t\taddress tokenA,\n\t\taddress tokenB\n\t) internal view returns (uint reserveA, uint reserveB) {\n\t\t(address token0, ) = sortTokens(tokenA, tokenB);\n\t\t(uint reserve0, uint reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n\n\t\t(reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n\t}\n\n\t// given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n\tfunction quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n\t\trequire(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n\t\trequire(reserveA > 0 && reserveB > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n\t\tamountB = amountA.mul(reserveB) / reserveA;\n\t}\n\n\t// given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n\t\trequire(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n\t\trequire(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n\t\tuint amountInWithFee = amountIn.mul(997);\n\t\tuint numerator = amountInWithFee.mul(reserveOut);\n\t\tuint denominator = reserveIn.mul(1000).add(amountInWithFee);\n\t\tamountOut = numerator / denominator;\n\t}\n\n\t// given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n\t\trequire(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n\t\trequire(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n\t\tuint numerator = reserveIn.mul(amountOut).mul(1000);\n\t\tuint denominator = reserveOut.sub(amountOut).mul(997);\n\t\tamountIn = (numerator / denominator).add(1);\n\t}\n\n\t// performs chained getAmountOut calculations on any number of pairs\n\tfunction getAmountsOut(\n\t\taddress factory,\n\t\tuint amountIn,\n\t\taddress[] memory path\n\t) internal view returns (uint[] memory amounts) {\n\t\trequire(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n\t\tamounts = new uint[](path.length);\n\t\tamounts[0] = amountIn;\n\t\tfor (uint i; i < path.length - 1; i++) {\n\t\t\t(uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n\t\t\tamounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n\t\t}\n\t}\n\n\t// performs chained getAmountIn calculations on any number of pairs\n\tfunction getAmountsIn(\n\t\taddress factory,\n\t\tuint amountOut,\n\t\taddress[] memory path\n\t) internal view returns (uint[] memory amounts) {\n\t\trequire(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n\t\tamounts = new uint[](path.length);\n\t\tamounts[amounts.length - 1] = amountOut;\n\t\tfor (uint i = path.length - 1; i > 0; i--) {\n\t\t\t(uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n\t\t\tamounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n\t\t}\n\t}\n}\n"
    },
    "contracts/test/uniswap/periphery/libraries/UniswapV2LiquidityMathLibrary.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.12;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n// import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport \"./Babylonian.sol\";\nimport \"./FullMath.sol\";\n\nimport \"./SafeMath.sol\";\nimport \"./UniswapV2Library.sol\";\n\n// library containing some math for dealing with the liquidity shares of a pair, e.g. computing their exact value\n// in terms of the underlying tokens\nlibrary UniswapV2LiquidityMathLibrary {\n\tusing SafeMath for uint256;\n\n\t// computes the direction and magnitude of the profit-maximizing trade\n\tfunction computeProfitMaximizingTrade(\n\t\tuint256 truePriceTokenA,\n\t\tuint256 truePriceTokenB,\n\t\tuint256 reserveA,\n\t\tuint256 reserveB\n\t) internal pure returns (bool aToB, uint256 amountIn) {\n\t\taToB = FullMath.mulDiv(reserveA, truePriceTokenB, reserveB) < truePriceTokenA;\n\n\t\tuint256 invariant = reserveA.mul(reserveB);\n\n\t\tuint256 leftSide = Babylonian.sqrt(\n\t\t\tFullMath.mulDiv(\n\t\t\t\tinvariant.mul(1000),\n\t\t\t\taToB ? truePriceTokenA : truePriceTokenB,\n\t\t\t\t(aToB ? truePriceTokenB : truePriceTokenA).mul(997)\n\t\t\t)\n\t\t);\n\t\tuint256 rightSide = (aToB ? reserveA.mul(1000) : reserveB.mul(1000)) / 997;\n\n\t\tif (leftSide < rightSide) return (false, 0);\n\n\t\t// compute the amount that must be sent to move the price to the profit-maximizing price\n\t\tamountIn = leftSide.sub(rightSide);\n\t}\n\n\t// gets the reserves after an arbitrage moves the price to the profit-maximizing ratio given an externally observed true price\n\tfunction getReservesAfterArbitrage(\n\t\taddress factory,\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 truePriceTokenA,\n\t\tuint256 truePriceTokenB\n\t) internal view returns (uint256 reserveA, uint256 reserveB) {\n\t\t// first get reserves before the swap\n\t\t(reserveA, reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n\n\t\trequire(reserveA > 0 && reserveB > 0, \"UniswapV2ArbitrageLibrary: ZERO_PAIR_RESERVES\");\n\n\t\t// then compute how much to swap to arb to the true price\n\t\t(bool aToB, uint256 amountIn) = computeProfitMaximizingTrade(\n\t\t\ttruePriceTokenA,\n\t\t\ttruePriceTokenB,\n\t\t\treserveA,\n\t\t\treserveB\n\t\t);\n\n\t\tif (amountIn == 0) {\n\t\t\treturn (reserveA, reserveB);\n\t\t}\n\n\t\t// now affect the trade to the reserves\n\t\tif (aToB) {\n\t\t\tuint amountOut = UniswapV2Library.getAmountOut(amountIn, reserveA, reserveB);\n\t\t\treserveA += amountIn;\n\t\t\treserveB -= amountOut;\n\t\t} else {\n\t\t\tuint amountOut = UniswapV2Library.getAmountOut(amountIn, reserveB, reserveA);\n\t\t\treserveB += amountIn;\n\t\t\treserveA -= amountOut;\n\t\t}\n\t}\n\n\t// computes liquidity value given all the parameters of the pair\n\tfunction computeLiquidityValue(\n\t\tuint256 reservesA,\n\t\tuint256 reservesB,\n\t\tuint256 totalSupply,\n\t\tuint256 liquidityAmount,\n\t\tbool feeOn,\n\t\tuint kLast\n\t) internal pure returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n\t\tif (feeOn && kLast > 0) {\n\t\t\tuint rootK = Babylonian.sqrt(reservesA.mul(reservesB));\n\t\t\tuint rootKLast = Babylonian.sqrt(kLast);\n\t\t\tif (rootK > rootKLast) {\n\t\t\t\tuint numerator1 = totalSupply;\n\t\t\t\tuint numerator2 = rootK.sub(rootKLast);\n\t\t\t\tuint denominator = rootK.mul(5).add(rootKLast);\n\t\t\t\tuint feeLiquidity = FullMath.mulDiv(numerator1, numerator2, denominator);\n\t\t\t\ttotalSupply = totalSupply.add(feeLiquidity);\n\t\t\t}\n\t\t}\n\t\treturn (reservesA.mul(liquidityAmount) / totalSupply, reservesB.mul(liquidityAmount) / totalSupply);\n\t}\n\n\t// get all current parameters from the pair and compute value of a liquidity amount\n\t// **note this is subject to manipulation, e.g. sandwich attacks**. prefer passing a manipulation resistant price to\n\t// #getLiquidityValueAfterArbitrageToPrice\n\tfunction getLiquidityValue(\n\t\taddress factory,\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 liquidityAmount\n\t) internal view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n\t\t(uint256 reservesA, uint256 reservesB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n\t\tIUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, tokenA, tokenB));\n\t\tbool feeOn = IUniswapV2Factory(factory).feeTo() != address(0);\n\t\tuint kLast = feeOn ? pair.kLast() : 0;\n\t\tuint totalSupply = pair.totalSupply();\n\t\treturn computeLiquidityValue(reservesA, reservesB, totalSupply, liquidityAmount, feeOn, kLast);\n\t}\n\n\t// given two tokens, tokenA and tokenB, and their \"true price\", i.e. the observed ratio of value of token A to token B,\n\t// and a liquidity amount, returns the value of the liquidity in terms of tokenA and tokenB\n\tfunction getLiquidityValueAfterArbitrageToPrice(\n\t\taddress factory,\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 truePriceTokenA,\n\t\tuint256 truePriceTokenB,\n\t\tuint256 liquidityAmount\n\t) internal view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n\t\tbool feeOn = IUniswapV2Factory(factory).feeTo() != address(0);\n\t\tIUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, tokenA, tokenB));\n\t\tuint kLast = feeOn ? pair.kLast() : 0;\n\t\tuint totalSupply = pair.totalSupply();\n\n\t\t// this also checks that totalSupply > 0\n\t\trequire(totalSupply >= liquidityAmount && liquidityAmount > 0, \"ComputeLiquidityValue: LIQUIDITY_AMOUNT\");\n\n\t\t(uint reservesA, uint reservesB) = getReservesAfterArbitrage(\n\t\t\tfactory,\n\t\t\ttokenA,\n\t\t\ttokenB,\n\t\t\ttruePriceTokenA,\n\t\t\ttruePriceTokenB\n\t\t);\n\n\t\treturn computeLiquidityValue(reservesA, reservesB, totalSupply, liquidityAmount, feeOn, kLast);\n\t}\n}\n"
    },
    "contracts/test/uniswap/periphery/test/DeflatingERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.12;\n\nimport \"../libraries/SafeMath.sol\";\n\ncontract DeflatingERC20 {\n\tusing SafeMath for uint;\n\n\tstring public constant name = \"Deflating Test Token\";\n\tstring public constant symbol = \"DTT\";\n\tuint8 public constant decimals = 18;\n\tuint public totalSupply;\n\tmapping(address => uint) public balanceOf;\n\tmapping(address => mapping(address => uint)) public allowance;\n\n\tbytes32 public DOMAIN_SEPARATOR;\n\t// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\tbytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\tmapping(address => uint) public nonces;\n\n\tevent Approval(address indexed owner, address indexed spender, uint value);\n\tevent Transfer(address indexed from, address indexed to, uint value);\n\n\tconstructor(uint _totalSupply) {\n\t\tuint chainId;\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\t\tDOMAIN_SEPARATOR = keccak256(\n\t\t\tabi.encode(\n\t\t\t\tkeccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n\t\t\t\tkeccak256(bytes(name)),\n\t\t\t\tkeccak256(bytes(\"1\")),\n\t\t\t\tchainId,\n\t\t\t\taddress(this)\n\t\t\t)\n\t\t);\n\t\t_mint(msg.sender, _totalSupply);\n\t}\n\n\tfunction _mint(address to, uint value) internal {\n\t\ttotalSupply = totalSupply.add(value);\n\t\tbalanceOf[to] = balanceOf[to].add(value);\n\t\temit Transfer(address(0), to, value);\n\t}\n\n\tfunction _burn(address from, uint value) internal {\n\t\tbalanceOf[from] = balanceOf[from].sub(value);\n\t\ttotalSupply = totalSupply.sub(value);\n\t\temit Transfer(from, address(0), value);\n\t}\n\n\tfunction _approve(address owner, address spender, uint value) private {\n\t\tallowance[owner][spender] = value;\n\t\temit Approval(owner, spender, value);\n\t}\n\n\tfunction _transfer(address from, address to, uint value) private {\n\t\tuint burnAmount = value / 100;\n\t\t_burn(from, burnAmount);\n\t\tuint transferAmount = value.sub(burnAmount);\n\t\tbalanceOf[from] = balanceOf[from].sub(transferAmount);\n\t\tbalanceOf[to] = balanceOf[to].add(transferAmount);\n\t\temit Transfer(from, to, transferAmount);\n\t}\n\n\tfunction approve(address spender, uint value) external returns (bool) {\n\t\t_approve(msg.sender, spender, value);\n\t\treturn true;\n\t}\n\n\tfunction transfer(address to, uint value) external returns (bool) {\n\t\t_transfer(msg.sender, to, value);\n\t\treturn true;\n\t}\n\n\tfunction transferFrom(address from, address to, uint value) external returns (bool) {\n\t\tif (allowance[from][msg.sender] != type(uint256).max) {\n\t\t\tallowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n\t\t}\n\t\t_transfer(from, to, value);\n\t\treturn true;\n\t}\n\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n\t\trequire(deadline >= block.timestamp, \"EXPIRED\");\n\t\tbytes32 digest = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\t\"\\x19\\x01\",\n\t\t\t\tDOMAIN_SEPARATOR,\n\t\t\t\tkeccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n\t\t\t)\n\t\t);\n\t\taddress recoveredAddress = ecrecover(digest, v, r, s);\n\t\trequire(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNATURE\");\n\t\t_approve(owner, spender, value);\n\t}\n}\n"
    },
    "contracts/test/uniswap/periphery/UniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.12;\n\n// import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport \"./libraries/TransferHelper.sol\";\n\nimport \"./libraries/UniswapV2Library.sol\";\nimport \"./interfaces/IUniswapV2Router01.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IWETH.sol\";\n\ncontract UniswapV2Router01 is IUniswapV2Router01 {\n\taddress public immutable factory;\n\taddress public immutable WETH;\n\n\tmodifier ensure(uint deadline) {\n\t\trequire(deadline >= block.timestamp, \"UniswapV2Router: EXPIRED\");\n\t\t_;\n\t}\n\n\tconstructor(address _factory, address _WETH) {\n\t\tfactory = _factory;\n\t\tWETH = _WETH;\n\t}\n\n\treceive() external payable {\n\t\tassert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n\t}\n\n\t// **** ADD LIQUIDITY ****\n\tfunction _addLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint amountADesired,\n\t\tuint amountBDesired,\n\t\tuint amountAMin,\n\t\tuint amountBMin\n\t) private returns (uint amountA, uint amountB) {\n\t\t// create the pair if it doesn't exist yet\n\t\tif (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n\t\t\tIUniswapV2Factory(factory).createPair(tokenA, tokenB);\n\t\t}\n\t\t(uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n\t\tif (reserveA == 0 && reserveB == 0) {\n\t\t\t(amountA, amountB) = (amountADesired, amountBDesired);\n\t\t} else {\n\t\t\tuint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n\t\t\tif (amountBOptimal <= amountBDesired) {\n\t\t\t\trequire(amountBOptimal >= amountBMin, \"UniswapV2Router: INSUFFICIENT_B_AMOUNT\");\n\t\t\t\t(amountA, amountB) = (amountADesired, amountBOptimal);\n\t\t\t} else {\n\t\t\t\tuint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n\t\t\t\tassert(amountAOptimal <= amountADesired);\n\t\t\t\trequire(amountAOptimal >= amountAMin, \"UniswapV2Router: INSUFFICIENT_A_AMOUNT\");\n\t\t\t\t(amountA, amountB) = (amountAOptimal, amountBDesired);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint amountADesired,\n\t\tuint amountBDesired,\n\t\tuint amountAMin,\n\t\tuint amountBMin,\n\t\taddress to,\n\t\tuint deadline\n\t) external override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n\t\t(amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n\t\taddress pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n\t\tTransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n\t\tTransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n\t\tliquidity = IUniswapV2Pair(pair).mint(to);\n\t}\n\n\tfunction addLiquidityETH(\n\t\taddress token,\n\t\tuint amountTokenDesired,\n\t\tuint amountTokenMin,\n\t\tuint amountETHMin,\n\t\taddress to,\n\t\tuint deadline\n\t) external payable override ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\n\t\t(amountToken, amountETH) = _addLiquidity(\n\t\t\ttoken,\n\t\t\tWETH,\n\t\t\tamountTokenDesired,\n\t\t\tmsg.value,\n\t\t\tamountTokenMin,\n\t\t\tamountETHMin\n\t\t);\n\t\taddress pair = UniswapV2Library.pairFor(factory, token, WETH);\n\t\tTransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n\t\tIWETH(WETH).deposit{value: amountETH}();\n\t\tassert(IWETH(WETH).transfer(pair, amountETH));\n\t\tliquidity = IUniswapV2Pair(pair).mint(to);\n\t\tif (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH); // refund dust eth, if any\n\t}\n\n\t// **** REMOVE LIQUIDITY ****\n\tfunction removeLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint liquidity,\n\t\tuint amountAMin,\n\t\tuint amountBMin,\n\t\taddress to,\n\t\tuint deadline\n\t) public override ensure(deadline) returns (uint amountA, uint amountB) {\n\t\taddress pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n\t\tIUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n\t\t(uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\n\t\t(address token0, ) = UniswapV2Library.sortTokens(tokenA, tokenB);\n\t\t(amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n\t\trequire(amountA >= amountAMin, \"UniswapV2Router: INSUFFICIENT_A_AMOUNT\");\n\t\trequire(amountB >= amountBMin, \"UniswapV2Router: INSUFFICIENT_B_AMOUNT\");\n\t}\n\n\tfunction removeLiquidityETH(\n\t\taddress token,\n\t\tuint liquidity,\n\t\tuint amountTokenMin,\n\t\tuint amountETHMin,\n\t\taddress to,\n\t\tuint deadline\n\t) public override ensure(deadline) returns (uint amountToken, uint amountETH) {\n\t\t(amountToken, amountETH) = removeLiquidity(\n\t\t\ttoken,\n\t\t\tWETH,\n\t\t\tliquidity,\n\t\t\tamountTokenMin,\n\t\t\tamountETHMin,\n\t\t\taddress(this),\n\t\t\tdeadline\n\t\t);\n\t\tTransferHelper.safeTransfer(token, to, amountToken);\n\t\tIWETH(WETH).withdraw(amountETH);\n\t\tTransferHelper.safeTransferETH(to, amountETH);\n\t}\n\n\t// **** SWAP ****\n\t// requires the initial amount to have already been sent to the first pair\n\tfunction _swap(uint[] memory amounts, address[] memory path, address _to) private {\n\t\tuint256 length = path.length;\n\t\tfor (uint i; i < length - 1; i++) {\n\t\t\t(address input, address output) = (path[i], path[i + 1]);\n\t\t\t(address token0, ) = UniswapV2Library.sortTokens(input, output);\n\t\t\tuint amountOut = amounts[i + 1];\n\t\t\t(uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n\t\t\taddress to = i < length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n\t\t\tIUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\n\t\t\t\tamount0Out,\n\t\t\t\tamount1Out,\n\t\t\t\tto,\n\t\t\t\tnew bytes(0)\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction swapExactTokensForTokens(\n\t\tuint amountIn,\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external override ensure(deadline) returns (uint[] memory amounts) {\n\t\tamounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\t\trequire(amounts[amounts.length - 1] >= amountOutMin, \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n\t\tTransferHelper.safeTransferFrom(\n\t\t\tpath[0],\n\t\t\tmsg.sender,\n\t\t\tUniswapV2Library.pairFor(factory, path[0], path[1]),\n\t\t\tamounts[0]\n\t\t);\n\t\t_swap(amounts, path, to);\n\t}\n\n\tfunction swapTokensForExactTokens(\n\t\tuint amountOut,\n\t\tuint amountInMax,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external override ensure(deadline) returns (uint[] memory amounts) {\n\t\tamounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\t\trequire(amounts[0] <= amountInMax, \"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\");\n\t\tTransferHelper.safeTransferFrom(\n\t\t\tpath[0],\n\t\t\tmsg.sender,\n\t\t\tUniswapV2Library.pairFor(factory, path[0], path[1]),\n\t\t\tamounts[0]\n\t\t);\n\t\t_swap(amounts, path, to);\n\t}\n\n\tfunction swapExactETHForTokens(\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external payable override ensure(deadline) returns (uint[] memory amounts) {\n\t\trequire(path[0] == WETH, \"UniswapV2Router: INVALID_PATH\");\n\t\tamounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\n\t\trequire(amounts[amounts.length - 1] >= amountOutMin, \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n\t\tIWETH(WETH).deposit{value: amounts[0]}();\n\t\tassert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n\t\t_swap(amounts, path, to);\n\t}\n\n\tfunction swapTokensForExactETH(\n\t\tuint amountOut,\n\t\tuint amountInMax,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external override ensure(deadline) returns (uint[] memory amounts) {\n\t\trequire(path[path.length - 1] == WETH, \"UniswapV2Router: INVALID_PATH\");\n\t\tamounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\t\trequire(amounts[0] <= amountInMax, \"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\");\n\t\tTransferHelper.safeTransferFrom(\n\t\t\tpath[0],\n\t\t\tmsg.sender,\n\t\t\tUniswapV2Library.pairFor(factory, path[0], path[1]),\n\t\t\tamounts[0]\n\t\t);\n\t\t_swap(amounts, path, address(this));\n\t\tIWETH(WETH).withdraw(amounts[amounts.length - 1]);\n\t\tTransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n\t}\n\n\tfunction swapExactTokensForETH(\n\t\tuint amountIn,\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external override ensure(deadline) returns (uint[] memory amounts) {\n\t\trequire(path[path.length - 1] == WETH, \"UniswapV2Router: INVALID_PATH\");\n\t\tamounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\t\trequire(amounts[amounts.length - 1] >= amountOutMin, \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n\t\tTransferHelper.safeTransferFrom(\n\t\t\tpath[0],\n\t\t\tmsg.sender,\n\t\t\tUniswapV2Library.pairFor(factory, path[0], path[1]),\n\t\t\tamounts[0]\n\t\t);\n\t\t_swap(amounts, path, address(this));\n\t\tIWETH(WETH).withdraw(amounts[amounts.length - 1]);\n\t\tTransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n\t}\n\n\tfunction swapETHForExactTokens(\n\t\tuint amountOut,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external payable override ensure(deadline) returns (uint[] memory amounts) {\n\t\trequire(path[0] == WETH, \"UniswapV2Router: INVALID_PATH\");\n\t\tamounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\t\trequire(amounts[0] <= msg.value, \"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\");\n\t\tIWETH(WETH).deposit{value: amounts[0]}();\n\t\tassert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n\t\t_swap(amounts, path, to);\n\t\tif (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]); // refund dust eth, if any\n\t}\n\n\tfunction quote(uint amountA, uint reserveA, uint reserveB) public pure override returns (uint amountB) {\n\t\treturn UniswapV2Library.quote(amountA, reserveA, reserveB);\n\t}\n\n\tfunction getAmountOut(\n\t\tuint amountIn,\n\t\tuint reserveIn,\n\t\tuint reserveOut\n\t) public pure override returns (uint amountOut) {\n\t\treturn UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n\t}\n\n\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) public pure override returns (uint amountIn) {\n\t\treturn UniswapV2Library.getAmountOut(amountOut, reserveIn, reserveOut);\n\t}\n\n\tfunction getAmountsOut(uint amountIn, address[] memory path) public view override returns (uint[] memory amounts) {\n\t\treturn UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\t}\n\n\tfunction getAmountsIn(uint amountOut, address[] memory path) public view override returns (uint[] memory amounts) {\n\t\treturn UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\t}\n}\n"
    },
    "contracts/test/uniswap/periphery/UniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.12;\n\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/IUniswapV2Router02.sol\";\nimport \"./libraries/UniswapV2Library.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IWETH.sol\";\n\ncontract UniswapV2Router02 is IUniswapV2Router02 {\n\tusing SafeMath for uint;\n\n\taddress public immutable factory;\n\taddress public immutable WETH;\n\n\tmodifier ensure(uint deadline) {\n\t\trequire(deadline >= block.timestamp, \"UniswapV2Router: EXPIRED\");\n\t\t_;\n\t}\n\n\tconstructor(address _factory, address _WETH) {\n\t\tfactory = _factory;\n\t\tWETH = _WETH;\n\t}\n\n\treceive() external payable {\n\t\tassert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n\t}\n\n\t// **** ADD LIQUIDITY ****\n\tfunction _addLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint amountADesired,\n\t\tuint amountBDesired,\n\t\tuint amountAMin,\n\t\tuint amountBMin\n\t) internal virtual returns (uint amountA, uint amountB) {\n\t\t// create the pair if it doesn't exist yet\n\t\tif (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n\t\t\tIUniswapV2Factory(factory).createPair(tokenA, tokenB);\n\t\t}\n\t\t(uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n\t\tif (reserveA == 0 && reserveB == 0) {\n\t\t\t(amountA, amountB) = (amountADesired, amountBDesired);\n\t\t} else {\n\t\t\tuint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n\t\t\tif (amountBOptimal <= amountBDesired) {\n\t\t\t\trequire(amountBOptimal >= amountBMin, \"UniswapV2Router: INSUFFICIENT_B_AMOUNT\");\n\t\t\t\t(amountA, amountB) = (amountADesired, amountBOptimal);\n\t\t\t} else {\n\t\t\t\tuint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n\t\t\t\tassert(amountAOptimal <= amountADesired);\n\t\t\t\trequire(amountAOptimal >= amountAMin, \"UniswapV2Router: INSUFFICIENT_A_AMOUNT\");\n\t\t\t\t(amountA, amountB) = (amountAOptimal, amountBDesired);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint amountADesired,\n\t\tuint amountBDesired,\n\t\tuint amountAMin,\n\t\tuint amountBMin,\n\t\taddress to,\n\t\tuint deadline\n\t) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n\t\t(amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n\t\taddress pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n\n\t\tTransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n\t\tTransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n\n\t\tliquidity = IUniswapV2Pair(pair).mint(to);\n\t}\n\n\tfunction addLiquidityETH(\n\t\taddress token,\n\t\tuint amountTokenDesired,\n\t\tuint amountTokenMin,\n\t\tuint amountETHMin,\n\t\taddress to,\n\t\tuint deadline\n\t) external payable virtual override ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\n\t\t(amountToken, amountETH) = _addLiquidity(\n\t\t\ttoken,\n\t\t\tWETH,\n\t\t\tamountTokenDesired,\n\t\t\tmsg.value,\n\t\t\tamountTokenMin,\n\t\t\tamountETHMin\n\t\t);\n\t\taddress pair = UniswapV2Library.pairFor(factory, token, WETH);\n\t\tTransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n\t\tIWETH(WETH).deposit{value: amountETH}();\n\t\tassert(IWETH(WETH).transfer(pair, amountETH));\n\t\tliquidity = IUniswapV2Pair(pair).mint(to);\n\t\t// refund dust eth, if any\n\t\tif (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n\t}\n\n\t// **** REMOVE LIQUIDITY ****\n\tfunction removeLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint liquidity,\n\t\tuint amountAMin,\n\t\tuint amountBMin,\n\t\taddress to,\n\t\tuint deadline\n\t) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\n\t\taddress pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n\t\tIUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n\t\t(uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\n\t\t(address token0, ) = UniswapV2Library.sortTokens(tokenA, tokenB);\n\t\t(amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n\t\trequire(amountA >= amountAMin, \"UniswapV2Router: INSUFFICIENT_A_AMOUNT\");\n\t\trequire(amountB >= amountBMin, \"UniswapV2Router: INSUFFICIENT_B_AMOUNT\");\n\t}\n\n\tfunction removeLiquidityETH(\n\t\taddress token,\n\t\tuint liquidity,\n\t\tuint amountTokenMin,\n\t\tuint amountETHMin,\n\t\taddress to,\n\t\tuint deadline\n\t) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\n\t\t(amountToken, amountETH) = removeLiquidity(\n\t\t\ttoken,\n\t\t\tWETH,\n\t\t\tliquidity,\n\t\t\tamountTokenMin,\n\t\t\tamountETHMin,\n\t\t\taddress(this),\n\t\t\tdeadline\n\t\t);\n\t\tTransferHelper.safeTransfer(token, to, amountToken);\n\t\tIWETH(WETH).withdraw(amountETH);\n\t\tTransferHelper.safeTransferETH(to, amountETH);\n\t}\n\n\t// **** SWAP ****\n\t// requires the initial amount to have already been sent to the first pair\n\tfunction _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\n\t\tuint256 length = path.length;\n\t\tfor (uint i; i < length - 1; i++) {\n\t\t\t(address input, address output) = (path[i], path[i + 1]);\n\t\t\t(address token0, ) = UniswapV2Library.sortTokens(input, output);\n\t\t\tuint amountOut = amounts[i + 1];\n\t\t\t(uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n\t\t\taddress to = i < length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n\t\t\tIUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\n\t\t\t\tamount0Out,\n\t\t\t\tamount1Out,\n\t\t\t\tto,\n\t\t\t\tnew bytes(0)\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction swapExactTokensForTokens(\n\t\tuint amountIn,\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n\t\tamounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\t\trequire(amounts[amounts.length - 1] >= amountOutMin, \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n\t\tTransferHelper.safeTransferFrom(\n\t\t\tpath[0],\n\t\t\tmsg.sender,\n\t\t\tUniswapV2Library.pairFor(factory, path[0], path[1]),\n\t\t\tamounts[0]\n\t\t);\n\t\t_swap(amounts, path, to);\n\t}\n\n\tfunction swapTokensForExactTokens(\n\t\tuint amountOut,\n\t\tuint amountInMax,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n\t\tamounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\t\trequire(amounts[0] <= amountInMax, \"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\");\n\t\tTransferHelper.safeTransferFrom(\n\t\t\tpath[0],\n\t\t\tmsg.sender,\n\t\t\tUniswapV2Library.pairFor(factory, path[0], path[1]),\n\t\t\tamounts[0]\n\t\t);\n\t\t_swap(amounts, path, to);\n\t}\n\n\tfunction swapExactETHForTokens(\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external payable virtual override ensure(deadline) returns (uint[] memory amounts) {\n\t\trequire(path[0] == WETH, \"UniswapV2Router: INVALID_PATH\");\n\t\tamounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\n\t\trequire(amounts[amounts.length - 1] >= amountOutMin, \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n\t\tIWETH(WETH).deposit{value: amounts[0]}();\n\t\tassert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n\t\t_swap(amounts, path, to);\n\t}\n\n\tfunction swapTokensForExactETH(\n\t\tuint amountOut,\n\t\tuint amountInMax,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n\t\trequire(path[path.length - 1] == WETH, \"UniswapV2Router: INVALID_PATH\");\n\t\tamounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\t\trequire(amounts[0] <= amountInMax, \"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\");\n\t\tTransferHelper.safeTransferFrom(\n\t\t\tpath[0],\n\t\t\tmsg.sender,\n\t\t\tUniswapV2Library.pairFor(factory, path[0], path[1]),\n\t\t\tamounts[0]\n\t\t);\n\t\t_swap(amounts, path, address(this));\n\t\tIWETH(WETH).withdraw(amounts[amounts.length - 1]);\n\t\tTransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n\t}\n\n\tfunction swapExactTokensForETH(\n\t\tuint amountIn,\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n\t\trequire(path[path.length - 1] == WETH, \"UniswapV2Router: INVALID_PATH\");\n\t\tamounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\t\trequire(amounts[amounts.length - 1] >= amountOutMin, \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n\t\tTransferHelper.safeTransferFrom(\n\t\t\tpath[0],\n\t\t\tmsg.sender,\n\t\t\tUniswapV2Library.pairFor(factory, path[0], path[1]),\n\t\t\tamounts[0]\n\t\t);\n\t\t_swap(amounts, path, address(this));\n\t\tIWETH(WETH).withdraw(amounts[amounts.length - 1]);\n\t\tTransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n\t}\n\n\tfunction swapETHForExactTokens(\n\t\tuint amountOut,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external payable virtual override ensure(deadline) returns (uint[] memory amounts) {\n\t\trequire(path[0] == WETH, \"UniswapV2Router: INVALID_PATH\");\n\t\tamounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\t\trequire(amounts[0] <= msg.value, \"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\");\n\t\tIWETH(WETH).deposit{value: amounts[0]}();\n\t\tassert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n\t\t_swap(amounts, path, to);\n\t\t// refund dust eth, if any\n\t\tif (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n\t}\n\n\t// **** LIBRARY FUNCTIONS ****\n\tfunction quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\n\t\treturn UniswapV2Library.quote(amountA, reserveA, reserveB);\n\t}\n\n\tfunction getAmountOut(\n\t\tuint amountIn,\n\t\tuint reserveIn,\n\t\tuint reserveOut\n\t) public pure virtual override returns (uint amountOut) {\n\t\treturn UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n\t}\n\n\tfunction getAmountIn(\n\t\tuint amountOut,\n\t\tuint reserveIn,\n\t\tuint reserveOut\n\t) public pure virtual override returns (uint amountIn) {\n\t\treturn UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n\t}\n\n\tfunction getAmountsOut(\n\t\tuint amountIn,\n\t\taddress[] memory path\n\t) public view virtual override returns (uint[] memory amounts) {\n\t\treturn UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\t}\n\n\tfunction getAmountsIn(\n\t\tuint amountOut,\n\t\taddress[] memory path\n\t) public view virtual override returns (uint[] memory amounts) {\n\t\treturn UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\t}\n}\n"
    },
    "contracts/test/uniswap/UniswapV2OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.12;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"./core/libraries/FixedPoint.sol\";\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n\tusing FixedPoint for *;\n\n\t// helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n\tfunction currentBlockTimestamp() internal view returns (uint32) {\n\t\treturn uint32(block.timestamp % 2 ** 32);\n\t}\n\n\t// produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n\tfunction currentCumulativePrices(\n\t\taddress pair\n\t) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n\t\tblockTimestamp = currentBlockTimestamp();\n\t\tprice0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n\t\tprice1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n\t\t// if time has elapsed since the last update on the pair, mock the accumulated price values\n\t\t(uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n\t\tif (blockTimestampLast != blockTimestamp) {\n\t\t\t// subtraction overflow is desired\n\t\t\tuint32 timeElapsed = blockTimestamp - blockTimestampLast;\n\t\t\t// addition overflow is desired\n\t\t\t// counterfactual\n\t\t\tprice0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n\t\t\t// counterfactual\n\t\t\tprice1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n\t\t}\n\t}\n}\n"
    },
    "contracts/test/WBNB.sol": {
      "content": "// Copyright (C) 2015, 2016, 2017 Dapphub\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.12;\n\ncontract WBNB {\n\tstring public name = \"Wrapped BNB\";\n\tstring public symbol = \"WBNB\";\n\tuint8 public decimals = 18;\n\n\tevent Approval(address indexed src, address indexed guy, uint256 wad);\n\tevent Transfer(address indexed src, address indexed dst, uint256 wad);\n\tevent Deposit(address indexed dst, uint256 wad);\n\tevent Withdrawal(address indexed src, uint256 wad);\n\n\tmapping(address => uint256) public balanceOf;\n\tmapping(address => mapping(address => uint256)) public allowance;\n\n\t// function() public payable {\n\t//     deposit();\n\t// }\n\tfunction deposit() public payable {\n\t\tbalanceOf[msg.sender] += msg.value;\n\t\temit Deposit(msg.sender, msg.value);\n\t}\n\n\tfunction mint(uint256 val) public {\n\t\tbalanceOf[msg.sender] += val;\n\t\temit Deposit(msg.sender, val);\n\t}\n\n\tfunction withdraw(uint256 wad) public {\n\t\trequire(balanceOf[msg.sender] >= wad, \"\");\n\t\tbalanceOf[msg.sender] -= wad;\n\t\tpayable(msg.sender).transfer(wad);\n\t\temit Withdrawal(msg.sender, wad);\n\t}\n\n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn address(this).balance;\n\t}\n\n\tfunction approve(address guy, uint256 wad) public returns (bool) {\n\t\tallowance[msg.sender][guy] = wad;\n\t\temit Approval(msg.sender, guy, wad);\n\t\treturn true;\n\t}\n\n\tfunction transfer(address dst, uint256 wad) public returns (bool) {\n\t\treturn transferFrom(msg.sender, dst, wad);\n\t}\n\n\tfunction transferFrom(address src, address dst, uint256 wad) public returns (bool) {\n\t\trequire(balanceOf[src] >= wad, \"\");\n\n\t\tif (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\n\t\t\trequire(allowance[src][msg.sender] >= wad, \"\");\n\t\t\tallowance[src][msg.sender] -= wad;\n\t\t}\n\n\t\tbalanceOf[src] -= wad;\n\t\tbalanceOf[dst] += wad;\n\n\t\temit Transfer(src, dst, wad);\n\n\t\treturn true;\n\t}\n}\n\n/*\n                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<http://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\n\n*/\n"
    },
    "contracts/test/WETH.sol": {
      "content": "// Copyright (C) 2015, 2016, 2017 Dapphub\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.12;\n\ncontract WETH {\n\tstring public name = \"Wrapped Ether\";\n\tstring public symbol = \"WETH\";\n\tuint8 public decimals = 18;\n\n\tevent Approval(address indexed src, address indexed guy, uint256 wad);\n\tevent Transfer(address indexed src, address indexed dst, uint256 wad);\n\tevent Deposit(address indexed dst, uint256 wad);\n\tevent Withdrawal(address indexed src, uint256 wad);\n\n\tmapping(address => uint256) public balanceOf;\n\tmapping(address => mapping(address => uint256)) public allowance;\n\n\t// function() public payable {\n\t//     deposit();\n\t// }\n\tfunction deposit() public payable {\n\t\tbalanceOf[msg.sender] += msg.value;\n\t\temit Deposit(msg.sender, msg.value);\n\t}\n\n\tfunction mint(uint256 val) public {\n\t\tbalanceOf[msg.sender] += val;\n\t\temit Deposit(msg.sender, val);\n\t}\n\n\tfunction withdraw(uint256 wad) public {\n\t\trequire(balanceOf[msg.sender] >= wad, \"\");\n\t\tbalanceOf[msg.sender] -= wad;\n\t\tpayable(msg.sender).transfer(wad);\n\t\temit Withdrawal(msg.sender, wad);\n\t}\n\n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn address(this).balance;\n\t}\n\n\tfunction approve(address guy, uint256 wad) public returns (bool) {\n\t\tallowance[msg.sender][guy] = wad;\n\t\temit Approval(msg.sender, guy, wad);\n\t\treturn true;\n\t}\n\n\tfunction transfer(address dst, uint256 wad) public returns (bool) {\n\t\treturn transferFrom(msg.sender, dst, wad);\n\t}\n\n\tfunction transferFrom(address src, address dst, uint256 wad) public returns (bool) {\n\t\trequire(balanceOf[src] >= wad, \"\");\n\n\t\tif (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\n\t\t\trequire(allowance[src][msg.sender] >= wad, \"\");\n\t\t\tallowance[src][msg.sender] -= wad;\n\t\t}\n\n\t\tbalanceOf[src] -= wad;\n\t\tbalanceOf[dst] += wad;\n\n\t\temit Transfer(src, dst, wad);\n\n\t\treturn true;\n\t}\n}\n\n/*\n                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<http://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\n\n*/\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000,
      "details": {
        "yul": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}