{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/dependencies/math/HomoraMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nlibrary HomoraMath {\n\tusing SafeMath for uint;\n\n\tfunction divCeil(uint lhs, uint rhs) internal pure returns (uint) {\n\t\treturn lhs.add(rhs).sub(1) / rhs;\n\t}\n\n\tfunction fmul(uint lhs, uint rhs) internal pure returns (uint) {\n\t\treturn lhs.mul(rhs) / (2 ** 112);\n\t}\n\n\tfunction fdiv(uint lhs, uint rhs) internal pure returns (uint) {\n\t\treturn lhs.mul(2 ** 112) / rhs;\n\t}\n\n\t// implementation from https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c5292fb8291a0\n\t// original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n\tfunction sqrt(uint x) internal pure returns (uint) {\n\t\tif (x == 0) return 0;\n\t\tuint xx = x;\n\t\tuint r = 1;\n\n\t\tif (xx >= 0x100000000000000000000000000000000) {\n\t\t\txx >>= 128;\n\t\t\tr <<= 64;\n\t\t}\n\n\t\tif (xx >= 0x10000000000000000) {\n\t\t\txx >>= 64;\n\t\t\tr <<= 32;\n\t\t}\n\t\tif (xx >= 0x100000000) {\n\t\t\txx >>= 32;\n\t\t\tr <<= 16;\n\t\t}\n\t\tif (xx >= 0x10000) {\n\t\t\txx >>= 16;\n\t\t\tr <<= 8;\n\t\t}\n\t\tif (xx >= 0x100) {\n\t\t\txx >>= 8;\n\t\t\tr <<= 4;\n\t\t}\n\t\tif (xx >= 0x10) {\n\t\t\txx >>= 4;\n\t\t\tr <<= 2;\n\t\t}\n\t\tif (xx >= 0x8) {\n\t\t\tr <<= 1;\n\t\t}\n\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1; // Seven iterations should be enough\n\t\tuint r1 = x / r;\n\t\treturn (r < r1 ? r : r1);\n\t}\n}\n"
    },
    "contracts/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\ninterface AggregatorInterface {\n\tfunction latestAnswer() external view returns (int256);\n\n\tfunction latestTimestamp() external view returns (uint256);\n\n\tfunction latestRound() external view returns (uint256);\n\n\tfunction getAnswer(uint256 roundId) external view returns (int256);\n\n\tfunction getTimestamp(uint256 roundId) external view returns (uint256);\n\n\tevent AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n\tevent NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "contracts/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\ninterface AggregatorV3Interface {\n\tfunction decimals() external view returns (uint8);\n\n\tfunction description() external view returns (string memory);\n\n\tfunction version() external view returns (uint256);\n\n\t// getRoundData and latestRoundData should both raise \"No data present\"\n\t// if they do not have data to report, instead of returning unset values\n\t// which could be misinterpreted as actual reported values.\n\tfunction getRoundData(\n\t\tuint80 _roundId\n\t)\n\t\texternal\n\t\tview\n\t\treturns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n\tfunction latestRoundData()\n\t\texternal\n\t\tview\n\t\treturns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "contracts/interfaces/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\ninterface IAaveIncentivesController {\n\tevent RewardsAccrued(address indexed user, uint256 amount);\n\n\tevent RewardsClaimed(address indexed user, address indexed to, uint256 amount);\n\n\tevent RewardsClaimed(address indexed user, address indexed to, address indexed claimer, uint256 amount);\n\n\tevent ClaimerSet(address indexed user, address indexed claimer);\n\n\t/*\n\t * @dev Returns the configuration of the distribution for a certain asset\n\t * @param asset The address of the reference asset of the distribution\n\t * @return The asset index, the emission per second and the last updated timestamp\n\t **/\n\tfunction getAssetData(address asset) external view returns (uint256, uint256, uint256);\n\n\t/**\n\t * @dev Whitelists an address to claim the rewards on behalf of another address\n\t * @param user The address of the user\n\t * @param claimer The address of the claimer\n\t */\n\tfunction setClaimer(address user, address claimer) external;\n\n\t/**\n\t * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\n\t * @param user The address of the user\n\t * @return The claimer address\n\t */\n\tfunction getClaimer(address user) external view returns (address);\n\n\t/**\n\t * @dev Configure assets for a certain rewards emission\n\t * @param assets The assets to incentivize\n\t * @param emissionsPerSecond The emission for each asset\n\t */\n\tfunction configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond) external;\n\n\t/**\n\t * @dev Called by the corresponding asset on any update that affects the rewards distribution\n\t * @param user The address of the user\n\t **/\n\tfunction handleActionBefore(address user) external;\n\n\t/**\n\t * @dev Called by the corresponding asset on any update that affects the rewards distribution\n\t * @param user The address of the user\n\t * @param userBalance The balance of the user of the asset in the lending pool\n\t * @param totalSupply The total supply of the asset in the lending pool\n\t **/\n\tfunction handleActionAfter(address user, uint256 userBalance, uint256 totalSupply) external;\n\n\t/**\n\t * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n\t * @param user The address of the user\n\t * @return The rewards\n\t **/\n\tfunction getRewardsBalance(address[] calldata assets, address user) external view returns (uint256);\n\n\t/**\n\t * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\n\t * @param amount Amount of rewards to claim\n\t * @param to Address that will be receiving the rewards\n\t * @return Rewards claimed\n\t **/\n\tfunction claimRewards(address[] calldata assets, uint256 amount, address to) external returns (uint256);\n\n\t/**\n\t * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\n\t * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n\t * @param amount Amount of rewards to claim\n\t * @param user Address to check and claim rewards\n\t * @param to Address that will be receiving the rewards\n\t * @return Rewards claimed\n\t **/\n\tfunction claimRewardsOnBehalf(\n\t\taddress[] calldata assets,\n\t\tuint256 amount,\n\t\taddress user,\n\t\taddress to\n\t) external returns (uint256);\n\n\t/**\n\t * @dev returns the unclaimed rewards of the user\n\t * @param user the address of the user\n\t * @return the unclaimed user rewards\n\t */\n\tfunction getUserUnclaimedRewards(address user) external view returns (uint256);\n\n\t/**\n\t * @dev returns the unclaimed rewards of the user\n\t * @param user the address of the user\n\t * @param asset The asset to incentivize\n\t * @return the user index for the asset\n\t */\n\tfunction getUserAssetData(address user, address asset) external view returns (uint256);\n\n\t/**\n\t * @dev for backward compatibility with previous implementation of the Incentives controller\n\t */\n\tfunction REWARD_TOKEN() external view returns (address);\n\n\t/**\n\t * @dev for backward compatibility with previous implementation of the Incentives controller\n\t */\n\tfunction PRECISION() external view returns (uint8);\n\n\t/**\n\t * @dev Gets the distribution end timestamp of the emissions\n\t */\n\tfunction DISTRIBUTION_END() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IAaveOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title IAaveOracle interface\n * @notice Interface for the Aave oracle.\n **/\n\ninterface IAaveOracle {\n\tfunction BASE_CURRENCY() external view returns (address); // if usd returns 0x0, if eth returns weth address\n\n\tfunction BASE_CURRENCY_UNIT() external view returns (uint256);\n\n\t/***********\n    @dev returns the asset price in ETH\n     */\n\tfunction getAssetPrice(address asset) external view returns (uint256);\n\n\tfunction getSourceOfAsset(address asset) external view returns (address);\n}\n"
    },
    "contracts/interfaces/IAaveProtocolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\ninterface IAaveProtocolDataProvider {\n\tstruct TokenData {\n\t\tstring symbol;\n\t\taddress tokenAddress;\n\t}\n\n\tfunction getAllReservesTokens() external view returns (TokenData[] memory);\n\n\tfunction getAllATokens() external view returns (TokenData[] memory);\n\n\tfunction getReserveConfigurationData(\n\t\taddress asset\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 decimals,\n\t\t\tuint256 ltv,\n\t\t\tuint256 liquidationThreshold,\n\t\t\tuint256 liquidationBonus,\n\t\t\tuint256 reserveFactor,\n\t\t\tbool usageAsCollateralEnabled,\n\t\t\tbool borrowingEnabled,\n\t\t\tbool stableBorrowRateEnabled,\n\t\t\tbool isActive,\n\t\t\tbool isFrozen\n\t\t);\n\n\tfunction getReserveData(\n\t\taddress asset\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 availableLiquidity,\n\t\t\tuint256 totalStableDebt,\n\t\t\tuint256 totalVariableDebt,\n\t\t\tuint256 liquidityRate,\n\t\t\tuint256 variableBorrowRate,\n\t\t\tuint256 stableBorrowRate,\n\t\t\tuint256 averageStableBorrowRate,\n\t\t\tuint256 liquidityIndex,\n\t\t\tuint256 variableBorrowIndex,\n\t\t\tuint40 lastUpdateTimestamp\n\t\t);\n\n\tfunction getUserReserveData(\n\t\taddress asset,\n\t\taddress user\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 currentATokenBalance,\n\t\t\tuint256 currentStableDebt,\n\t\t\tuint256 currentVariableDebt,\n\t\t\tuint256 principalStableDebt,\n\t\t\tuint256 scaledVariableDebt,\n\t\t\tuint256 stableBorrowRate,\n\t\t\tuint256 liquidityRate,\n\t\t\tuint40 stableRateLastUpdated,\n\t\t\tbool usageAsCollateralEnabled\n\t\t);\n\n\tfunction getReserveTokensAddresses(\n\t\taddress asset\n\t) external view returns (address aTokenAddress, address stableDebtTokenAddress, address variableDebtTokenAddress);\n}\n"
    },
    "contracts/interfaces/IAToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IScaledBalanceToken} from \"./IScaledBalanceToken.sol\";\nimport {IInitializableAToken} from \"./IInitializableAToken.sol\";\nimport {IAaveIncentivesController} from \"./IAaveIncentivesController.sol\";\n\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\n\t/**\n\t * @dev Emitted after the mint action\n\t * @param from The address performing the mint\n\t * @param value The amount being\n\t * @param index The new liquidity index of the reserve\n\t **/\n\tevent Mint(address indexed from, uint256 value, uint256 index);\n\n\t/**\n\t * @dev Mints `amount` aTokens to `user`\n\t * @param user The address receiving the minted tokens\n\t * @param amount The amount of tokens getting minted\n\t * @param index The new liquidity index of the reserve\n\t * @return `true` if the the previous balance of the user was 0\n\t */\n\tfunction mint(address user, uint256 amount, uint256 index) external returns (bool);\n\n\t/**\n\t * @dev Emitted after aTokens are burned\n\t * @param from The owner of the aTokens, getting them burned\n\t * @param target The address that will receive the underlying\n\t * @param value The amount being burned\n\t * @param index The new liquidity index of the reserve\n\t **/\n\tevent Burn(address indexed from, address indexed target, uint256 value, uint256 index);\n\n\t/**\n\t * @dev Emitted during the transfer action\n\t * @param from The user whose tokens are being transferred\n\t * @param to The recipient\n\t * @param value The amount being transferred\n\t * @param index The new liquidity index of the reserve\n\t **/\n\tevent BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\n\n\t/**\n\t * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n\t * @param user The owner of the aTokens, getting them burned\n\t * @param receiverOfUnderlying The address that will receive the underlying\n\t * @param amount The amount being burned\n\t * @param index The new liquidity index of the reserve\n\t **/\n\tfunction burn(address user, address receiverOfUnderlying, uint256 amount, uint256 index) external;\n\n\t/**\n\t * @dev Mints aTokens to the reserve treasury\n\t * @param amount The amount of tokens getting minted\n\t * @param index The new liquidity index of the reserve\n\t */\n\tfunction mintToTreasury(uint256 amount, uint256 index) external;\n\n\t/**\n\t * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n\t * @param from The address getting liquidated, current owner of the aTokens\n\t * @param to The recipient\n\t * @param value The amount of tokens getting transferred\n\t **/\n\tfunction transferOnLiquidation(address from, address to, uint256 value) external;\n\n\t/**\n\t * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\n\t * assets in borrow(), withdraw() and flashLoan()\n\t * @param user The recipient of the underlying\n\t * @param amount The amount getting transferred\n\t * @return The amount transferred\n\t **/\n\tfunction transferUnderlyingTo(address user, uint256 amount) external returns (uint256);\n\n\t/**\n\t * @dev Invoked to execute actions on the aToken side after a repayment.\n\t * @param user The user executing the repayment\n\t * @param amount The amount getting repaid\n\t **/\n\tfunction handleRepayment(address user, uint256 amount) external;\n\n\t/**\n\t * @dev Returns the address of the incentives controller contract\n\t **/\n\tfunction getIncentivesController() external view returns (IAaveIncentivesController);\n\n\t/**\n\t * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n\t **/\n\tfunction UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IBountyManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ninterface IBountyManager {\n\tfunction quote(address _param) external returns (uint256 bounty);\n\n\tfunction claim(address _param) external returns (uint256 bounty);\n\n\tfunction minDLPBalance() external view returns (uint256 amt);\n\n\tfunction executeBounty(\n\t\taddress _user,\n\t\tbool _execute,\n\t\tuint256 _actionType\n\t) external returns (uint256 bounty, uint256 actionType);\n}\n"
    },
    "contracts/interfaces/IChainlinkAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\ninterface IChainlinkAdapter {\n\tfunction latestAnswer() external view returns (uint256 price);\n}\n"
    },
    "contracts/interfaces/IChainlinkAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Code from https://github.com/smartcontractkit/chainlink/blob/master/evm-contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\n\npragma solidity 0.8.12;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface IChainlinkAggregator is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "contracts/interfaces/IChefIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\ninterface IChefIncentivesController {\n\t/**\n\t * @dev Called by the corresponding asset on any update that affects the rewards distribution\n\t * @param user The address of the user\n\t **/\n\tfunction handleActionBefore(address user) external;\n\n\t/**\n\t * @dev Called by the corresponding asset on any update that affects the rewards distribution\n\t * @param user The address of the user\n\t * @param userBalance The balance of the user of the asset in the lending pool\n\t * @param totalSupply The total supply of the asset in the lending pool\n\t **/\n\tfunction handleActionAfter(address user, uint256 userBalance, uint256 totalSupply) external;\n\n\t/**\n\t * @dev Called by the locking contracts after locking or unlocking happens\n\t * @param user The address of the user\n\t **/\n\tfunction beforeLockUpdate(address user) external;\n\n\t/**\n\t * @notice Hook for lock update.\n\t * @dev Called by the locking contracts after locking or unlocking happens\n\t */\n\tfunction afterLockUpdate(address _user) external;\n\n\tfunction addPool(address _token, uint256 _allocPoint) external;\n\n\tfunction claim(address _user, address[] calldata _tokens) external;\n\n\tfunction setClaimReceiver(address _user, address _receiver) external;\n\n\tfunction getRegisteredTokens() external view returns (address[] memory);\n\n\tfunction disqualifyUser(address _user, address _hunter) external returns (uint256 bounty);\n\n\tfunction bountyForUser(address _user) external view returns (uint256 bounty);\n\n\tfunction allPendingRewards(address _user) external view returns (uint256 pending);\n\n\tfunction claimAll(address _user) external;\n\n\tfunction claimBounty(address _user, bool _execute) external returns (bool issueBaseBounty);\n\n\tfunction setEligibilityExempt(address _address, bool _value) external;\n}\n"
    },
    "contracts/interfaces/IFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"./LockedBalance.sol\";\n\ninterface IFeeDistribution {\n\tstruct RewardData {\n\t\taddress token;\n\t\tuint256 amount;\n\t}\n\n\tfunction addReward(address rewardsToken) external;\n\n\tfunction removeReward(address _rewardToken) external;\n}\n"
    },
    "contracts/interfaces/IInitializableAToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {ILendingPool} from \"./ILendingPool.sol\";\nimport {IAaveIncentivesController} from \"./IAaveIncentivesController.sol\";\n\n/**\n * @title IInitializableAToken\n * @notice Interface for the initialize function on AToken\n * @author Aave\n **/\ninterface IInitializableAToken {\n\t/**\n\t * @dev Emitted when an aToken is initialized\n\t * @param underlyingAsset The address of the underlying asset\n\t * @param pool The address of the associated lending pool\n\t * @param treasury The address of the treasury\n\t * @param incentivesController The address of the incentives controller for this aToken\n\t * @param aTokenDecimals the decimals of the underlying\n\t * @param aTokenName the name of the aToken\n\t * @param aTokenSymbol the symbol of the aToken\n\t * @param params A set of encoded parameters for additional initialization\n\t **/\n\tevent Initialized(\n\t\taddress indexed underlyingAsset,\n\t\taddress indexed pool,\n\t\taddress treasury,\n\t\taddress incentivesController,\n\t\tuint8 aTokenDecimals,\n\t\tstring aTokenName,\n\t\tstring aTokenSymbol,\n\t\tbytes params\n\t);\n\n\t/**\n\t * @dev Initializes the aToken\n\t * @param pool The address of the lending pool where this aToken will be used\n\t * @param treasury The address of the Aave treasury, receiving the fees on this aToken\n\t * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n\t * @param incentivesController The smart contract managing potential incentives distribution\n\t * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\n\t * @param aTokenName The name of the aToken\n\t * @param aTokenSymbol The symbol of the aToken\n\t */\n\tfunction initialize(\n\t\tILendingPool pool,\n\t\taddress treasury,\n\t\taddress underlyingAsset,\n\t\tIAaveIncentivesController incentivesController,\n\t\tuint8 aTokenDecimals,\n\t\tstring calldata aTokenName,\n\t\tstring calldata aTokenSymbol,\n\t\tbytes calldata params\n\t) external;\n}\n"
    },
    "contracts/interfaces/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPoolAddressesProvider} from \"./ILendingPoolAddressesProvider.sol\";\nimport {DataTypes} from \"../lending/libraries/types/DataTypes.sol\";\n\ninterface ILendingPool {\n\t/**\n\t * @dev Emitted on deposit()\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param user The address initiating the deposit\n\t * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n\t * @param amount The amount deposited\n\t * @param referral The referral code used\n\t **/\n\tevent Deposit(\n\t\taddress indexed reserve,\n\t\taddress user,\n\t\taddress indexed onBehalfOf,\n\t\tuint256 amount,\n\t\tuint16 indexed referral\n\t);\n\n\t/**\n\t * @dev Emitted on withdraw()\n\t * @param reserve The address of the underlyng asset being withdrawn\n\t * @param user The address initiating the withdrawal, owner of aTokens\n\t * @param to Address that will receive the underlying\n\t * @param amount The amount to be withdrawn\n\t **/\n\tevent Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n\t/**\n\t * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n\t * @param reserve The address of the underlying asset being borrowed\n\t * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n\t * initiator of the transaction on flashLoan()\n\t * @param onBehalfOf The address that will be getting the debt\n\t * @param amount The amount borrowed out\n\t * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n\t * @param borrowRate The numeric rate at which the user has borrowed\n\t * @param referral The referral code used\n\t **/\n\tevent Borrow(\n\t\taddress indexed reserve,\n\t\taddress user,\n\t\taddress indexed onBehalfOf,\n\t\tuint256 amount,\n\t\tuint256 borrowRateMode,\n\t\tuint256 borrowRate,\n\t\tuint16 indexed referral\n\t);\n\n\t/**\n\t * @dev Emitted on repay()\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param user The beneficiary of the repayment, getting his debt reduced\n\t * @param repayer The address of the user initiating the repay(), providing the funds\n\t * @param amount The amount repaid\n\t **/\n\tevent Repay(address indexed reserve, address indexed user, address indexed repayer, uint256 amount);\n\n\t/**\n\t * @dev Emitted on swapBorrowRateMode()\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param user The address of the user swapping his rate mode\n\t * @param rateMode The rate mode that the user wants to swap to\n\t **/\n\tevent Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n\t/**\n\t * @dev Emitted on setUserUseReserveAsCollateral()\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param user The address of the user enabling the usage as collateral\n\t **/\n\tevent ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n\t/**\n\t * @dev Emitted on setUserUseReserveAsCollateral()\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param user The address of the user enabling the usage as collateral\n\t **/\n\tevent ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n\t/**\n\t * @dev Emitted on rebalanceStableBorrowRate()\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param user The address of the user for which the rebalance has been executed\n\t **/\n\tevent RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n\t/**\n\t * @dev Emitted on flashLoan()\n\t * @param target The address of the flash loan receiver contract\n\t * @param initiator The address initiating the flash loan\n\t * @param asset The address of the asset being flash borrowed\n\t * @param amount The amount flash borrowed\n\t * @param premium The fee flash borrowed\n\t * @param referralCode The referral code used\n\t **/\n\tevent FlashLoan(\n\t\taddress indexed target,\n\t\taddress indexed initiator,\n\t\taddress indexed asset,\n\t\tuint256 amount,\n\t\tuint256 premium,\n\t\tuint16 referralCode\n\t);\n\n\t/**\n\t * @dev Emitted when the pause is triggered.\n\t */\n\tevent Paused();\n\n\t/**\n\t * @dev Emitted when the pause is lifted.\n\t */\n\tevent Unpaused();\n\n\t/**\n\t * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n\t * LendingPoolCollateral manager using a DELEGATECALL\n\t * This allows to have the events in the generated ABI for LendingPool.\n\t * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n\t * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n\t * @param user The address of the borrower getting liquidated\n\t * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n\t * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n\t * @param liquidator The address of the liquidator\n\t * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n\t * to receive the underlying collateral asset directly\n\t **/\n\tevent LiquidationCall(\n\t\taddress indexed collateralAsset,\n\t\taddress indexed debtAsset,\n\t\taddress indexed user,\n\t\tuint256 debtToCover,\n\t\tuint256 liquidatedCollateralAmount,\n\t\taddress liquidator,\n\t\tbool receiveAToken\n\t);\n\n\t/**\n\t * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n\t * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n\t * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n\t * gets added to the LendingPool ABI\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param liquidityRate The new liquidity rate\n\t * @param stableBorrowRate The new stable borrow rate\n\t * @param variableBorrowRate The new variable borrow rate\n\t * @param liquidityIndex The new liquidity index\n\t * @param variableBorrowIndex The new variable borrow index\n\t **/\n\tevent ReserveDataUpdated(\n\t\taddress indexed reserve,\n\t\tuint256 liquidityRate,\n\t\tuint256 stableBorrowRate,\n\t\tuint256 variableBorrowRate,\n\t\tuint256 liquidityIndex,\n\t\tuint256 variableBorrowIndex\n\t);\n\n\tfunction initialize(ILendingPoolAddressesProvider provider) external;\n\n\t/**\n\t * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n\t * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n\t * @param asset The address of the underlying asset to deposit\n\t * @param amount The amount to be deposited\n\t * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n\t *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n\t *   is a different wallet\n\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n\t *   0 if the action is executed directly by the user, without any middle-man\n\t **/\n\tfunction deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n\tfunction depositWithAutoDLP(\n\t\taddress asset,\n\t\tuint256 amount,\n\t\taddress onBehalfOf,\n\t\tuint16 referralCode\n\t) external;\n\n\t/**\n\t * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n\t * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n\t * @param asset The address of the underlying asset to withdraw\n\t * @param amount The underlying amount to be withdrawn\n\t *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n\t * @param to Address that will receive the underlying, same as msg.sender if the user\n\t *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n\t *   different wallet\n\t * @return The final amount withdrawn\n\t **/\n\tfunction withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n\t/**\n\t * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n\t * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n\t * corresponding debt token (StableDebtToken or VariableDebtToken)\n\t * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n\t *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n\t * @param asset The address of the underlying asset to borrow\n\t * @param amount The amount to be borrowed\n\t * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n\t *   0 if the action is executed directly by the user, without any middle-man\n\t * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n\t * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n\t * if he has been given credit delegation allowance\n\t **/\n\tfunction borrow(\n\t\taddress asset,\n\t\tuint256 amount,\n\t\tuint256 interestRateMode,\n\t\tuint16 referralCode,\n\t\taddress onBehalfOf\n\t) external;\n\n\t/**\n\t * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n\t * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n\t * @param asset The address of the borrowed underlying asset previously borrowed\n\t * @param amount The amount to repay\n\t * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n\t * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n\t * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n\t * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n\t * other borrower whose debt should be removed\n\t * @return The final amount repaid\n\t **/\n\tfunction repay(address asset, uint256 amount, uint256 rateMode, address onBehalfOf) external returns (uint256);\n\n\t/**\n\t * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n\t * @param asset The address of the underlying asset borrowed\n\t * @param rateMode The rate mode that the user wants to swap to\n\t **/\n\tfunction swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n\t/**\n\t * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n\t * - Users can be rebalanced if the following conditions are satisfied:\n\t *     1. Usage ratio is above 95%\n\t *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n\t *        borrowed at a stable rate and depositors are not earning enough\n\t * @param asset The address of the underlying asset borrowed\n\t * @param user The address of the user to be rebalanced\n\t **/\n\tfunction rebalanceStableBorrowRate(address asset, address user) external;\n\n\t/**\n\t * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n\t * @param asset The address of the underlying asset deposited\n\t * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n\t **/\n\tfunction setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n\t/**\n\t * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n\t * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n\t *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n\t * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n\t * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n\t * @param user The address of the borrower getting liquidated\n\t * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n\t * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n\t * to receive the underlying collateral asset directly\n\t **/\n\tfunction liquidationCall(\n\t\taddress collateralAsset,\n\t\taddress debtAsset,\n\t\taddress user,\n\t\tuint256 debtToCover,\n\t\tbool receiveAToken\n\t) external;\n\n\t/**\n\t * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n\t * as long as the amount taken plus a fee is returned.\n\t * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n\t * For further details please visit https://developers.aave.com\n\t * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n\t * @param assets The addresses of the assets being flash-borrowed\n\t * @param amounts The amounts amounts being flash-borrowed\n\t * @param modes Types of the debt to open if the flash loan is not returned:\n\t *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n\t *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n\t *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n\t * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n\t * @param params Variadic packed params to pass to the receiver as extra information\n\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n\t *   0 if the action is executed directly by the user, without any middle-man\n\t **/\n\tfunction flashLoan(\n\t\taddress receiverAddress,\n\t\taddress[] calldata assets,\n\t\tuint256[] calldata amounts,\n\t\tuint256[] calldata modes,\n\t\taddress onBehalfOf,\n\t\tbytes calldata params,\n\t\tuint16 referralCode\n\t) external;\n\n\t/**\n\t * @dev Returns the user account data across all the reserves\n\t * @param user The address of the user\n\t * @return totalCollateralETH the total collateral in ETH of the user\n\t * @return totalDebtETH the total debt in ETH of the user\n\t * @return availableBorrowsETH the borrowing power left of the user\n\t * @return currentLiquidationThreshold the liquidation threshold of the user\n\t * @return ltv the loan to value of the user\n\t * @return healthFactor the current health factor of the user\n\t **/\n\tfunction getUserAccountData(\n\t\taddress user\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 totalCollateralETH,\n\t\t\tuint256 totalDebtETH,\n\t\t\tuint256 availableBorrowsETH,\n\t\t\tuint256 currentLiquidationThreshold,\n\t\t\tuint256 ltv,\n\t\t\tuint256 healthFactor\n\t\t);\n\n\tfunction initReserve(\n\t\taddress reserve,\n\t\taddress aTokenAddress,\n\t\taddress stableDebtAddress,\n\t\taddress variableDebtAddress,\n\t\taddress interestRateStrategyAddress\n\t) external;\n\n\tfunction setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;\n\n\tfunction setConfiguration(address reserve, uint256 configuration) external;\n\n\t/**\n\t * @dev Returns the configuration of the reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The configuration of the reserve\n\t **/\n\tfunction getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n\t/**\n\t * @dev Returns the configuration of the user across all the reserves\n\t * @param user The user address\n\t * @return The configuration of the user\n\t **/\n\tfunction getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\n\n\t/**\n\t * @dev Returns the normalized income normalized income of the reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The reserve's normalized income\n\t */\n\tfunction getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n\t/**\n\t * @dev Returns the normalized variable debt per unit of asset\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The reserve normalized variable debt\n\t */\n\tfunction getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n\t/**\n\t * @dev Returns the state and configuration of the reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The state of the reserve\n\t **/\n\tfunction getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n\tfunction finalizeTransfer(\n\t\taddress asset,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount,\n\t\tuint256 balanceFromAfter,\n\t\tuint256 balanceToBefore\n\t) external;\n\n\tfunction getReservesList() external view returns (address[] memory);\n\n\tfunction getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\n\n\tfunction setPause(bool val) external;\n\n\tfunction paused() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ILendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n\tevent MarketIdSet(string newMarketId);\n\tevent LendingPoolUpdated(address indexed newAddress);\n\tevent ConfigurationAdminUpdated(address indexed newAddress);\n\tevent EmergencyAdminUpdated(address indexed newAddress);\n\tevent LendingPoolConfiguratorUpdated(address indexed newAddress);\n\tevent LendingPoolCollateralManagerUpdated(address indexed newAddress);\n\tevent PriceOracleUpdated(address indexed newAddress);\n\tevent LendingRateOracleUpdated(address indexed newAddress);\n\tevent ProxyCreated(bytes32 id, address indexed newAddress);\n\tevent AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n\tfunction getMarketId() external view returns (string memory);\n\n\tfunction setMarketId(string calldata marketId) external;\n\n\tfunction setAddress(bytes32 id, address newAddress) external;\n\n\tfunction setAddressAsProxy(bytes32 id, address impl) external;\n\n\tfunction getAddress(bytes32 id) external view returns (address);\n\n\tfunction getLendingPool() external view returns (address);\n\n\tfunction setLendingPoolImpl(address pool) external;\n\n\tfunction getLendingPoolConfigurator() external view returns (address);\n\n\tfunction setLendingPoolConfiguratorImpl(address configurator) external;\n\n\tfunction getLendingPoolCollateralManager() external view returns (address);\n\n\tfunction setLendingPoolCollateralManager(address manager) external;\n\n\tfunction getPoolAdmin() external view returns (address);\n\n\tfunction setPoolAdmin(address admin) external;\n\n\tfunction getEmergencyAdmin() external view returns (address);\n\n\tfunction setEmergencyAdmin(address admin) external;\n\n\tfunction getPriceOracle() external view returns (address);\n\n\tfunction setPriceOracle(address priceOracle) external;\n\n\tfunction getLendingRateOracle() external view returns (address);\n\n\tfunction setLendingRateOracle(address lendingRateOracle) external;\n\n\tfunction getLiquidationFeeTo() external view returns (address);\n\n\tfunction setLiquidationFeeTo(address liquidationFeeTo) external;\n}\n"
    },
    "contracts/interfaces/ILiquidityZap.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface ILiquidityZap {\n\tfunction _WETH() external view returns (address);\n\n\tfunction token() external view returns (address);\n\n\tfunction tokenWETHPair() external view returns (address);\n\n\tfunction addLiquidityETHOnly(address to) external returns (uint256 liquidity);\n\n\tfunction addLiquidityTokensOnly(address from, address to, uint256 amount) external returns (uint256 liquidity);\n\n\tfunction getLPTokenPerEthUnit(uint256 ethAmt) external view returns (uint256 liquidity);\n\n\tfunction initLiquidityZap(address token, address WETH, address tokenWethPair, address helper) external;\n\n\tfunction quote(uint256 wethAmount) external view returns (uint256 optimalTokenAmount);\n\n\tfunction quoteFromToken(uint256 tokenAmount) external view returns (uint256 optimalWETHAmount);\n\n\tfunction removeAllLiquidityETHOnly(address to) external returns (uint256 amount);\n\n\tfunction removeAllLiquidityTokenOnly(address to) external returns (uint256 amount);\n\n\tfunction removeLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 liquidity,\n\t\taddress to\n\t) external returns (uint256 amountA, uint256 amountB);\n\n\tfunction removeLiquidityETHOnly(address to, uint256 liquidity) external returns (uint256 amountOut);\n\n\tfunction removeLiquidityTokenOnly(address to, uint256 liquidity) external returns (uint256 amount);\n\n\tfunction standardAdd(\n\t\tuint256 tokenAmount,\n\t\tuint256 _wethAmt,\n\t\taddress to\n\t) external payable returns (uint256 liquidity);\n\n\tfunction unzap() external returns (uint256 amountToken, uint256 amountETH);\n\n\tfunction unzapToETH() external returns (uint256 amount);\n\n\tfunction unzapToTokens() external returns (uint256 amount);\n\n\tfunction zapETH(address payable _onBehalf) external payable returns (uint256 liquidity);\n\n\tfunction zapTokens(uint256 amount) external returns (uint256 liquidity);\n\n\tfunction addLiquidityWETHOnly(uint256 _amount, address payable to) external returns (uint256 liquidity);\n}\n"
    },
    "contracts/interfaces/ILockZap.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\ninterface ILockZap {\n\tfunction zap(\n\t\tbool _borrow,\n\t\taddress _asset,\n\t\tuint256 _assetAmt,\n\t\tuint256 _prntAmt,\n\t\tuint256 _lockTypeIndex,\n\t\tuint256 _slippage\n\t) external returns (uint256 liquidity);\n\n\tfunction zapOnBehalf(\n\t\tbool _borrow,\n\t\taddress _asset,\n\t\tuint256 _assetAmt,\n\t\tuint256 _prntAmt,\n\t\taddress _onBehalf,\n\t\tuint256 _slippage\n\t) external returns (uint256 liquidity);\n}\n"
    },
    "contracts/interfaces/IMiddleFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"./LockedBalance.sol\";\nimport {IFeeDistribution} from \"./IMultiFeeDistribution.sol\";\n\ninterface IMiddleFeeDistribution is IFeeDistribution {\n\tfunction forwardReward(address[] memory _rewardTokens) external;\n\n\tfunction getPrntTokenAddress() external view returns (address);\n\n\tfunction getMultiFeeDistributionAddress() external view returns (address);\n\n\tfunction operationExpenseRatio() external view returns (uint256);\n\n\tfunction operationExpenses() external view returns (address);\n\n\tfunction isRewardToken(address) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IMintableToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IMintableToken is IERC20 {\n\tfunction mint(address _receiver, uint256 _amount) external returns (bool);\n\n\tfunction burn(uint256 _amount) external returns (bool);\n\n\tfunction setMinter(address _minter) external returns (bool);\n\n\tfunction priceProvider() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IMultiFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"./LockedBalance.sol\";\nimport \"./IFeeDistribution.sol\";\nimport \"./IMintableToken.sol\";\n\ninterface IMultiFeeDistribution is IFeeDistribution {\n\tfunction exit(bool claimRewards) external;\n\n\tfunction stake(uint256 amount, address onBehalfOf, uint256 typeIndex) external;\n\n\tfunction prntToken() external view returns (IMintableToken);\n\n\tfunction getPriceProvider() external view returns (address);\n\n\tfunction lockInfo(address user) external view returns (LockedBalance[] memory);\n\n\tfunction autocompoundEnabled(address user) external view returns (bool);\n\n\tfunction defaultLockIndex(address _user) external view returns (uint256);\n\n\tfunction autoRelockDisabled(address user) external view returns (bool);\n\n\tfunction totalBalance(address user) external view returns (uint256);\n\n\tfunction lockedBalance(address user) external view returns (uint256);\n\n\tfunction lockedBalances(\n\t\taddress user\n\t) external view returns (uint256, uint256, uint256, uint256, LockedBalance[] memory);\n\n\tfunction getBalances(address _user) external view returns (Balances memory);\n\n\tfunction zapVestingToLp(address _address) external returns (uint256);\n\n\tfunction claimableRewards(address account) external view returns (IFeeDistribution.RewardData[] memory rewards);\n\n\tfunction setDefaultRelockTypeIndex(uint256 _index) external;\n\n\tfunction daoTreasury() external view returns (address);\n\n\tfunction stakingToken() external view returns (address);\n\n\tfunction userSlippage(address) external view returns (uint256);\n\n\tfunction claimFromConverter(address) external;\n\n\tfunction vestTokens(address user, uint256 amount, bool withPenalty) external;\n}\n\ninterface IMFDPlus is IMultiFeeDistribution {\n\tfunction getLastClaimTime(address _user) external returns (uint256);\n\n\tfunction claimBounty(address _user, bool _execute) external returns (bool issueBaseBounty);\n\n\tfunction claimCompound(address _user, bool _execute, uint256 _slippage) external returns (uint256 bountyAmt);\n\n\tfunction setAutocompound(bool _newVal) external;\n\n\tfunction getAutocompoundEnabled(address _user) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IPoolHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IPoolHelper {\n\tfunction lpTokenAddr() external view returns (address);\n\n\tfunction zapWETH(uint256 amount) external returns (uint256);\n\n\tfunction zapTokens(uint256 _wethAmt, uint256 _prntAmt) external returns (uint256);\n\n\tfunction quoteFromToken(uint256 tokenAmount) external view returns (uint256 optimalWETHAmount);\n\n\tfunction quoteWETH(uint256 lpAmount) external view returns (uint256 wethAmount);\n\n\tfunction getLpPrice(uint256 prntPriceInEth) external view returns (uint256 priceInEth);\n\n\tfunction getReserves() external view returns (uint256 prnt, uint256 weth, uint256 lpTokenSupply);\n\n\tfunction getPrice() external view returns (uint256 priceInEth);\n\n\tfunction quoteSwap(address _inToken, uint256 _wethAmount) external view returns (uint256 tokenAmount);\n\n\tfunction swapToWeth(address _inToken, uint256 _amount, uint256 _minAmountOut) external;\n}\n\ninterface IBalancerPoolHelper is IPoolHelper {\n\tfunction initializePool(string calldata _tokenName, string calldata _tokenSymbol) external;\n}\n\ninterface IUniswapPoolHelper is IPoolHelper {\n\tfunction initializePool() external;\n}\n\ninterface ITestPoolHelper is IPoolHelper {\n\tfunction sell(uint256 _amount) external returns (uint256 amountOut);\n}\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/************\n@title IPriceOracle interface\n@notice Interface for the Aave price oracle.*/\ninterface IPriceOracle {\n\t/***********\n    @dev returns the asset price in ETH\n     */\n\tfunction getAssetPrice(address asset) external view returns (uint256);\n\n\t/***********\n    @dev sets the asset price, in wei\n     */\n\tfunction setAssetPrice(address asset, uint256 price) external;\n}\n"
    },
    "contracts/interfaces/IPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ninterface IPriceProvider {\n\tfunction getTokenPrice() external view returns (uint256);\n\n\tfunction getTokenPriceUsd() external view returns (uint256);\n\n\tfunction getLpTokenPrice() external view returns (uint256);\n\n\tfunction getLpTokenPriceUsd() external view returns (uint256);\n\n\tfunction decimals() external view returns (uint256);\n\n\tfunction update() external;\n\n\tfunction baseAssetChainlinkAdapter() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IScaledBalanceToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface IScaledBalanceToken {\n\t/**\n\t * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n\t * updated stored balance divided by the reserve's liquidity index at the moment of the update\n\t * @param user The user whose balance is calculated\n\t * @return The scaled balance of the user\n\t **/\n\tfunction scaledBalanceOf(address user) external view returns (uint256);\n\n\t/**\n\t * @dev Returns the scaled balance of the user and the scaled total supply.\n\t * @param user The address of the user\n\t * @return The scaled balance of the user\n\t * @return The scaled balance and the scaled total supply\n\t **/\n\tfunction getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n\n\t/**\n\t * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n\t * @return The scaled total supply\n\t **/\n\tfunction scaledTotalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface IWETH {\n\tfunction balanceOf(address) external returns (uint256);\n\n\tfunction deposit() external payable;\n\n\tfunction withdraw(uint256) external;\n\n\tfunction approve(address guy, uint256 wad) external returns (bool);\n\n\tfunction transferFrom(address src, address dst, uint256 wad) external returns (bool);\n\n\tfunction transfer(address to, uint256 value) external returns (bool);\n\n\tfunction allowance(address owner, address spender) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/LockedBalance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nstruct LockedBalance {\n\tuint256 amount;\n\tuint256 unlockTime;\n\tuint256 multiplier;\n\tuint256 duration;\n}\n\nstruct EarnedBalance {\n\tuint256 amount;\n\tuint256 unlockTime;\n\tuint256 penalty;\n}\n\nstruct Reward {\n\tuint256 periodFinish;\n\tuint256 rewardPerSecond;\n\tuint256 lastUpdateTime;\n\tuint256 rewardPerTokenStored;\n\t// tracks already-added balances to handle accrued interest in aToken rewards\n\t// for the stakingToken this value is unused and will always be 0\n\tuint256 balance;\n}\n\nstruct Balances {\n\tuint256 total; // sum of earnings and lockings; no use when LP and PRNT is different\n\tuint256 unlocked; // PRNT token\n\tuint256 locked; // LP token or PRNT token\n\tuint256 lockedWithMultiplier; // Multiplied locked amount\n\tuint256 earned; // PRNT token\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface IUniswapV2Router01 {\n\tfunction factory() external view returns (address);\n\n\tfunction WETH() external view returns (address);\n\n\tfunction addLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 amountADesired,\n\t\tuint256 amountBDesired,\n\t\tuint256 amountAMin,\n\t\tuint256 amountBMin,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n\tfunction addLiquidityETH(\n\t\taddress token,\n\t\tuint256 amountTokenDesired,\n\t\tuint256 amountTokenMin,\n\t\tuint256 amountETHMin,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\n\n\tfunction removeLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 liquidity,\n\t\tuint256 amountAMin,\n\t\tuint256 amountBMin,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256 amountA, uint256 amountB);\n\n\tfunction removeLiquidityETH(\n\t\taddress token,\n\t\tuint256 liquidity,\n\t\tuint256 amountTokenMin,\n\t\tuint256 amountETHMin,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256 amountToken, uint256 amountETH);\n\n\tfunction removeLiquidityWithPermit(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 liquidity,\n\t\tuint256 amountAMin,\n\t\tuint256 amountBMin,\n\t\taddress to,\n\t\tuint256 deadline,\n\t\tbool approveMax,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external returns (uint256 amountA, uint256 amountB);\n\n\tfunction removeLiquidityETHWithPermit(\n\t\taddress token,\n\t\tuint256 liquidity,\n\t\tuint256 amountTokenMin,\n\t\tuint256 amountETHMin,\n\t\taddress to,\n\t\tuint256 deadline,\n\t\tbool approveMax,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external returns (uint256 amountToken, uint256 amountETH);\n\n\tfunction swapExactTokensForTokens(\n\t\tuint256 amountIn,\n\t\tuint256 amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256[] memory amounts);\n\n\tfunction swapTokensForExactTokens(\n\t\tuint256 amountOut,\n\t\tuint256 amountInMax,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256[] memory amounts);\n\n\tfunction swapExactETHForTokens(\n\t\tuint256 amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external payable returns (uint256[] memory amounts);\n\n\tfunction swapTokensForExactETH(\n\t\tuint256 amountOut,\n\t\tuint256 amountInMax,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256[] memory amounts);\n\n\tfunction swapExactTokensForETH(\n\t\tuint256 amountIn,\n\t\tuint256 amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256[] memory amounts);\n\n\tfunction swapETHForExactTokens(\n\t\tuint256 amountOut,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external payable returns (uint256[] memory amounts);\n\n\tfunction quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);\n\n\tfunction getAmountOut(\n\t\tuint256 amountIn,\n\t\tuint256 reserveIn,\n\t\tuint256 reserveOut\n\t) external pure returns (uint256 amountOut);\n\n\tfunction getAmountIn(\n\t\tuint256 amountOut,\n\t\tuint256 reserveIn,\n\t\tuint256 reserveOut\n\t) external pure returns (uint256 amountIn);\n\n\tfunction getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n\tfunction getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./IUniswapV2Router01.sol\";\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n\tfunction removeLiquidityETHSupportingFeeOnTransferTokens(\n\t\taddress token,\n\t\tuint256 liquidity,\n\t\tuint256 amountTokenMin,\n\t\tuint256 amountETHMin,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256 amountETH);\n\n\tfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n\t\taddress token,\n\t\tuint256 liquidity,\n\t\tuint256 amountTokenMin,\n\t\tuint256 amountETHMin,\n\t\taddress to,\n\t\tuint256 deadline,\n\t\tbool approveMax,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external returns (uint256 amountETH);\n\n\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\n\t\tuint256 amountIn,\n\t\tuint256 amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external;\n\n\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\n\t\tuint256 amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external payable;\n\n\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\n\t\tuint256 amountIn,\n\t\tuint256 amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external;\n}\n"
    },
    "contracts/lending/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nlibrary DataTypes {\n\t// refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n\tstruct ReserveData {\n\t\t//stores the reserve configuration\n\t\tReserveConfigurationMap configuration;\n\t\t//the liquidity index. Expressed in ray\n\t\tuint128 liquidityIndex;\n\t\t//variable borrow index. Expressed in ray\n\t\tuint128 variableBorrowIndex;\n\t\t//the current supply rate. Expressed in ray\n\t\tuint128 currentLiquidityRate;\n\t\t//the current variable borrow rate. Expressed in ray\n\t\tuint128 currentVariableBorrowRate;\n\t\t//the current stable borrow rate. Expressed in ray\n\t\tuint128 currentStableBorrowRate;\n\t\tuint40 lastUpdateTimestamp;\n\t\t//tokens addresses\n\t\taddress aTokenAddress;\n\t\taddress stableDebtTokenAddress;\n\t\taddress variableDebtTokenAddress;\n\t\t//address of the interest rate strategy\n\t\taddress interestRateStrategyAddress;\n\t\t//the id of the reserve. Represents the position in the list of the active reserves\n\t\tuint8 id;\n\t}\n\n\tstruct ReserveConfigurationMap {\n\t\t//bit 0-15: LTV\n\t\t//bit 16-31: Liq. threshold\n\t\t//bit 32-47: Liq. bonus\n\t\t//bit 48-55: Decimals\n\t\t//bit 56: Reserve is active\n\t\t//bit 57: reserve is frozen\n\t\t//bit 58: borrowing is enabled\n\t\t//bit 59: stable rate borrowing enabled\n\t\t//bit 60-63: reserved\n\t\t//bit 64-79: reserve factor\n\t\tuint256 data;\n\t}\n\n\tstruct UserConfigurationMap {\n\t\tuint256 data;\n\t}\n\n\tenum InterestRateMode {\n\t\tNONE,\n\t\tSTABLE,\n\t\tVARIABLE\n\t}\n}\n"
    },
    "contracts/prime/accessories/Compounder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IUniswapV2Router} from \"../../uniswap-solc-0.8/interfaces/IUniswapV2Router.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IAToken} from \"../../interfaces/IAToken.sol\";\nimport {IMultiFeeDistribution} from \"../../interfaces/IMultiFeeDistribution.sol\";\nimport {ILendingPoolAddressesProvider} from \"../../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {IAaveOracle} from \"../../interfaces/IAaveOracle.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\nimport {ILockZap} from \"../../interfaces/ILockZap.sol\";\nimport {IPriceProvider} from \"../../interfaces/IPriceProvider.sol\";\nimport {IFeeDistribution} from \"../../interfaces/IFeeDistribution.sol\";\nimport {IMintableToken} from \"../../interfaces/IMintableToken.sol\";\nimport {IBountyManager} from \"../../interfaces/IBountyManager.sol\";\n\n/// @title Compounder Contract\n/// @author Prime\ncontract Compounder is OwnableUpgradeable, PausableUpgradeable {\n\tusing SafeERC20 for IERC20;\n\n\t/// @notice Reward data struct\n\tstruct RewardData {\n\t\taddress token;\n\t\tuint256 amount;\n\t}\n\n\t/********************** Events ***********************/\n\n\t/// @notice Emitted when routes are updated\n\tevent RoutesUpdated(address _token, address[] _routes);\n\n\t/// @notice Emitted when bounty manager is updated\n\tevent BountyManagerUpdated(address indexed _manager);\n\n\t/// @notice Emitted when compounding fee is updated\n\tevent CompoundFeeUpdated(uint256 indexed _compoundFee);\n\n\t/// @notice Emitted when slippage limit is updated\n\tevent SlippageLimitUpdated(uint256 indexed _slippageLimit);\n\n\t/********************** Errors ***********************/\n\terror AddressZero();\n\n\terror InvalidCompoundFee();\n\n\terror InvalidSlippage();\n\n\terror NotBountyManager();\n\n\terror NotEligible();\n\n\terror InsufficientStakeAmount();\n\n\terror ArrayLengthMismatch();\n\n\terror SwapFailed(address asset, uint256 amount);\n\n\t/// @notice The maximum slippage limit that can be set by admins\n\t/// @dev The max slippage should be equal to the max slippage of the LockZap contract, otherwise transactions could revert\n\tuint256 public constant MAX_SLIPPAGE_LIMIT = 8500; //15%\n\n\t/// @notice Percent divisor which is equal to 100%\n\tuint256 public constant PERCENT_DIVISOR = 10000;\n\tuint256 public constant MAX_COMPOUND_FEE = 2000;\n\tuint256 public constant MIN_DELAY = 1 days;\n\t/// @notice Fee of compounding\n\tuint256 public compoundFee;\n\n\t/// @notice Slippage limit for swap\n\tuint256 public slippageLimit;\n\n\t/// @notice PRNT token address\n\tIMintableToken public prntToken;\n\n\t/// @notice Token that PRNT is paired with in LP\n\taddress public baseToken;\n\n\t/// @notice Lending Pool Addresses Provider contract address\n\taddress public addressProvider;\n\n\t/// @notice Price provider contract address\n\taddress public priceProvider;\n\n\t/// @notice Swap route WETH -> PRNT\n\taddress[] public wethToPrime;\n\n\t/// @notice Swap router\n\taddress public uniRouter;\n\n\t/// @notice MFD address\n\taddress public multiFeeDistribution;\n\n\t/// @notice Lockzap address\n\taddress public lockZap;\n\n\t/// @notice BountyManager address\n\taddress public bountyManager;\n\n\t/// @notice Timestamp of last auto compounding\n\tmapping(address => uint256) public lastAutocompound;\n\n\t/// @notice Swap route from rewardToken to baseToken\n\tmapping(address => address[]) public rewardToBaseRoute;\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Initializer\n\t * @param _uniRouter Address of swap router\n\t * @param _mfd Address of MFD\n\t * @param _baseToken Address of pair asset of PRNT LP\n\t * @param _addressProvider Address of LendingPoolAddressesProvider\n\t * @param _lockZap Address of LockZap contract\n\t * @param _compoundFee Compounding fee\n\t * @param _slippageLimit Slippage limit\n\t */\n\tfunction initialize(\n\t\taddress _uniRouter,\n\t\taddress _mfd,\n\t\taddress _baseToken,\n\t\taddress _addressProvider,\n\t\taddress _lockZap,\n\t\tuint256 _compoundFee,\n\t\tuint256 _slippageLimit\n\t) external initializer {\n\t\tif (_uniRouter == address(0)) revert AddressZero();\n\t\tif (_mfd == address(0)) revert AddressZero();\n\t\tif (_baseToken == address(0)) revert AddressZero();\n\t\tif (_addressProvider == address(0)) revert AddressZero();\n\t\tif (_lockZap == address(0)) revert AddressZero();\n\t\tif (_compoundFee == 0) revert InvalidCompoundFee();\n\t\tif (_compoundFee > MAX_COMPOUND_FEE) revert InvalidCompoundFee();\n\t\t_validateSlippageLimit(_slippageLimit);\n\n\t\tuniRouter = _uniRouter;\n\t\tmultiFeeDistribution = _mfd;\n\t\tbaseToken = _baseToken;\n\t\taddressProvider = _addressProvider;\n\t\tlockZap = _lockZap;\n\t\tprntToken = IMultiFeeDistribution(multiFeeDistribution).prntToken();\n\t\tpriceProvider = IMultiFeeDistribution(multiFeeDistribution).getPriceProvider();\n\t\twethToPrime = [baseToken, address(prntToken)];\n\t\tcompoundFee = _compoundFee;\n\t\tslippageLimit = _slippageLimit;\n\t\t__Ownable_init();\n\t\t__Pausable_init();\n\t}\n\n\t/**\n\t * @notice Pause contract\n\t */\n\tfunction pause() external onlyOwner {\n\t\t_pause();\n\t}\n\n\t/**\n\t * @notice Unpause contract\n\t */\n\tfunction unpause() external onlyOwner {\n\t\t_unpause();\n\t}\n\n\t/**\n\t * @notice Set swap routes\n\t * @param _token Token for swap\n\t * @param _routes Swap route for token\n\t */\n\tfunction setRoutes(address _token, address[] memory _routes) external onlyOwner {\n\t\trewardToBaseRoute[_token] = _routes;\n\t\temit RoutesUpdated(_token, _routes);\n\t}\n\n\t/**\n\t * @notice Set bounty manager\n\t * @param _manager Bounty manager address\n\t */\n\tfunction setBountyManager(address _manager) external onlyOwner {\n\t\tif (_manager == address(0)) revert AddressZero();\n\t\tbountyManager = _manager;\n\t\temit BountyManagerUpdated(_manager);\n\t}\n\n\t/**\n\t * @notice Sets the fee for compounding.\n\t * @param _compoundFee fee ratio for compounding\n\t */\n\tfunction setCompoundFee(uint256 _compoundFee) external onlyOwner {\n\t\tif (_compoundFee == 0) revert InvalidCompoundFee();\n\t\tif (_compoundFee > MAX_COMPOUND_FEE) revert InvalidCompoundFee();\n\t\tcompoundFee = _compoundFee;\n\t\temit CompoundFeeUpdated(_compoundFee);\n\t}\n\n\t/**\n\t * @notice Sets slippage limit.\n\t * @param _slippageLimit new slippage limit\n\t */\n\tfunction setSlippageLimit(uint256 _slippageLimit) external onlyOwner {\n\t\t_validateSlippageLimit(_slippageLimit);\n\t\tslippageLimit = _slippageLimit;\n\t\temit SlippageLimitUpdated(_slippageLimit);\n\t}\n\n\t/**\n\t * @notice Claim and swap them into base token.\n\t * @param _user User whose rewards are compounded into dLP\n\t * @param tokens Tokens to claim and turn into dLP\n\t * @param amts Amounts of each token to be claimed and turned into dLP\n\t * @return Total base token amount\n\t */\n\tfunction _claimAndSwapToBase(\n\t\taddress _user,\n\t\taddress[] memory tokens,\n\t\tuint256[] memory amts\n\t) internal returns (uint256) {\n\t\tIMultiFeeDistribution mfd = IMultiFeeDistribution(multiFeeDistribution);\n\t\tmfd.claimFromConverter(_user);\n\t\tILendingPool lendingPool = ILendingPool(ILendingPoolAddressesProvider(addressProvider).getLendingPool());\n\n\t\tuint256 length = tokens.length;\n\t\tfor (uint256 i; i < length; i++) {\n\t\t\tuint256 balance = amts[i];\n\t\t\tif (balance == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\taddress tokenToTrade = tokens[i];\n\t\t\tuint256 amount;\n\t\t\ttry lendingPool.withdraw(tokenToTrade, type(uint256).max, address(this)) returns (uint256 withdrawnAmt) {\n\t\t\t\tamount = withdrawnAmt;\n\t\t\t} catch {\n\t\t\t\tamount = balance;\n\t\t\t}\n\n\t\t\tif (tokenToTrade != baseToken) {\n\t\t\t\tIERC20(tokenToTrade).forceApprove(uniRouter, amount);\n\t\t\t\ttry\n\t\t\t\t\tIUniswapV2Router(uniRouter).swapExactTokensForTokens(\n\t\t\t\t\t\tamount,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\trewardToBaseRoute[tokenToTrade],\n\t\t\t\t\t\taddress(this),\n\t\t\t\t\t\tblock.timestamp\n\t\t\t\t\t)\n\t\t\t\t{} catch {\n\t\t\t\t\trevert SwapFailed(tokenToTrade, amount);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn IERC20(baseToken).balanceOf(address(this));\n\t}\n\n\t/**\n\t * @notice Converts base token to lp token and stake them.\n\t * @param _user User for this action\n\t * @param _slippage maximum tolerated slippage for any occurring swaps\n\t * @return liquidity LP token amount\n\t */\n\tfunction _convertBaseToLPandStake(address _user, uint256 _slippage) internal returns (uint256 liquidity) {\n\t\tuint256 baseBal = IERC20(baseToken).balanceOf(address(this));\n\t\tif (baseBal != 0) {\n\t\t\tIERC20(baseToken).forceApprove(lockZap, baseBal);\n\t\t\tliquidity = ILockZap(lockZap).zapOnBehalf(false, address(0), baseBal, 0, _user, _slippage);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Compound user's rewards\n\t * @dev Can be auto compound or manual compound\n\t * @param _user user address\n\t * @param _execute whether to execute txn, or just quote (expected amount out for bounty executor)\n\t * @param _slippage that shouldn't be exceeded when performing swaps\n\t * @return fee amount\n\t */\n\tfunction claimCompound(address _user, bool _execute, uint256 _slippage) public returns (uint256 fee) {\n\t\tif (paused()) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 slippageLimit_ = slippageLimit;\n\n\t\tbool isAutoCompound = _user != msg.sender;\n\n\t\t(address[] memory tokens, uint256[] memory amts) = viewPendingRewards(_user);\n\t\tuint256 noSlippagePendingEth = _quoteSwapWithOracles(tokens, amts, baseToken);\n\n\t\tif (isAutoCompound) {\n\t\t\t_slippage = IMultiFeeDistribution(multiFeeDistribution).userSlippage(_user);\n\t\t}\n\t\tif (_slippage == 0) {\n\t\t\t_slippage = slippageLimit_;\n\t\t}\n\t\tif (_slippage < slippageLimit_ || _slippage >= PERCENT_DIVISOR) revert InvalidSlippage();\n\n\t\tif (isAutoCompound) {\n\t\t\tif (msg.sender != bountyManager) revert NotBountyManager();\n\t\t\tbool eligible = isEligibleForAutoCompound(_user, noSlippagePendingEth);\n\t\t\tif (!eligible) {\n\t\t\t\tif (_execute) {\n\t\t\t\t\trevert NotEligible();\n\t\t\t\t} else {\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!isEligibleForCompound(noSlippagePendingEth)) revert InsufficientStakeAmount();\n\t\t}\n\n\t\tif (!_execute) {\n\t\t\tif (isAutoCompound) {\n\t\t\t\tuint256 pendingInPrnt = _wethToPrnt(noSlippagePendingEth, _execute, _slippage);\n\t\t\t\tfee = (pendingInPrnt * compoundFee) / PERCENT_DIVISOR;\n\t\t\t\treturn fee;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tuint256 actualWethAfterSwap = _claimAndSwapToBase(_user, tokens, amts);\n\t\tif ((PERCENT_DIVISOR * actualWethAfterSwap) / noSlippagePendingEth < _slippage) revert InvalidSlippage();\n\n\t\tif (isAutoCompound) {\n\t\t\tfee = _wethToPrnt(((actualWethAfterSwap * compoundFee) / PERCENT_DIVISOR), _execute, _slippage);\n\t\t}\n\n\t\t_convertBaseToLPandStake(_user, _slippage);\n\n\t\tif (isAutoCompound) {\n\t\t\tprntToken.approve(bountyManager, fee);\n\t\t\tlastAutocompound[_user] = block.timestamp;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Compound `msg.sender`'s rewards.\n\t * @param _slippage that shouldn't be exceeded when performing swaps\n\t */\n\tfunction selfCompound(uint256 _slippage) external {\n\t\tclaimCompound(msg.sender, true, _slippage);\n\t}\n\n\t/**\n\t * @notice Returns the pending rewards of the `_user`\n\t * @param _user owner of rewards\n\t * @return tokens array of reward token addresses\n\t * @return amts array of reward amounts\n\t */\n\tfunction viewPendingRewards(address _user) public view returns (address[] memory tokens, uint256[] memory amts) {\n\t\tIFeeDistribution.RewardData[] memory pending = IMultiFeeDistribution(multiFeeDistribution).claimableRewards(\n\t\t\t_user\n\t\t);\n\t\ttokens = new address[](pending.length - 1);\n\t\tamts = new uint256[](pending.length - 1);\n\t\tuint256 index;\n\t\tuint256 length = pending.length;\n\t\tfor (uint256 i; i < length;) {\n\t\t\tif (pending[i].token != address(prntToken)) {\n\t\t\t\ttry IAToken(pending[i].token).UNDERLYING_ASSET_ADDRESS() returns (address underlyingAddress) {\n\t\t\t\t\ttokens[index] = underlyingAddress;\n\t\t\t\t} catch {\n\t\t\t\t\ttokens[index] = pending[i].token;\n\t\t\t\t}\n\t\t\t\tamts[index] = pending[i].amount;\n\t\t\t\tunchecked {\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Estimate the out tokens amount.\n\t * @param _in token address\n\t * @param _out token address\n\t * @param _amtIn amount of input token\n\t * @return tokensOut amount of output\n\t */\n\tfunction _estimateTokensOut(address _in, address _out, uint256 _amtIn) internal view returns (uint256 tokensOut) {\n\t\tIAaveOracle oracle = IAaveOracle(ILendingPoolAddressesProvider(addressProvider).getPriceOracle());\n\t\tuint256 priceInAsset = oracle.getAssetPrice(_in); //USDC: 100000000\n\t\tuint256 priceOutAsset = oracle.getAssetPrice(_out); //WETH: 153359950000\n\t\tuint256 decimalsIn = IERC20Metadata(_in).decimals();\n\t\tuint256 decimalsOut = IERC20Metadata(_out).decimals();\n\t\ttokensOut = (_amtIn * priceInAsset * (10 ** decimalsOut)) / (priceOutAsset * (10 ** decimalsIn));\n\t}\n\n\t/**\n\t * @notice Estimate the out tokens amount.\n\t * @param _in array of input token address\n\t * @param _amtsIn amount of input tokens\n\t * @return amtOut Sum of outputs\n\t */\n\tfunction _quoteSwapWithOracles(\n\t\taddress[] memory _in,\n\t\tuint256[] memory _amtsIn,\n\t\taddress _out\n\t) internal view returns (uint256 amtOut) {\n\t\tif (_in.length != _amtsIn.length) revert ArrayLengthMismatch();\n\t\tuint256 length = _in.length;\n\t\tfor (uint256 i; i < length;) {\n\t\t\tamtOut += _estimateTokensOut(_in[i], _out, _amtsIn[i]);\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Swap WETH to PRNT.\n\t * @param _wethIn WETH input amount\n\t * @param _execute Option to excute this action or not\n\t * @param _slippageLimit User defined slippage limit\n\t * @return prntOut Output PRNT amount\n\t */\n\tfunction _wethToPrnt(uint256 _wethIn, bool _execute, uint256 _slippageLimit) internal returns (uint256 prntOut) {\n\t\tif (_execute) {\n\t\t\tIPriceProvider(priceProvider).update();\n\t\t}\n\t\tuint256 prntPrice = IPriceProvider(priceProvider).getTokenPrice();\n\t\tif (_wethIn != 0) {\n\t\t\tif (_execute) {\n\t\t\t\tIERC20(baseToken).forceApprove(uniRouter, _wethIn);\n\t\t\t\tuint256[] memory amounts = IUniswapV2Router(uniRouter).swapExactTokensForTokens(\n\t\t\t\t\t_wethIn,\n\t\t\t\t\t0,\n\t\t\t\t\twethToPrime,\n\t\t\t\t\taddress(this),\n\t\t\t\t\tblock.timestamp\n\t\t\t\t);\n\t\t\t\tprntOut = amounts[amounts.length - 1];\n\t\t\t} else {\n\t\t\t\tuint256[] memory amounts = IUniswapV2Router(uniRouter).getAmountsOut(\n\t\t\t\t\t_wethIn, //amt in\n\t\t\t\t\twethToPrime\n\t\t\t\t);\n\t\t\t\tprntOut = amounts[amounts.length - 1];\n\t\t\t}\n\t\t}\n\t\tuint256 ethValueOfPRNT = prntPrice * prntOut;\n\t\tif (ethValueOfPRNT / 10 ** 8 < (_wethIn * _slippageLimit) / PERCENT_DIVISOR) revert InvalidSlippage();\n\t}\n\n\t/**\n\t * @notice Returns minimum stake amount in ETH\n\t * @return minStakeAmtEth Minimum stake amount in ETH\n\t */\n\tfunction autocompoundThreshold() public view returns (uint256 minStakeAmtEth) {\n\t\tIPriceProvider priceProv = IPriceProvider(priceProvider);\n\n\t\tuint256 minStakeLpAmt = IBountyManager(bountyManager).minDLPBalance();\n\t\tuint256 lpPriceEth = priceProv.getLpTokenPrice();\n\n\t\tminStakeAmtEth = (minStakeLpAmt * lpPriceEth) / (10 ** priceProv.decimals());\n\t}\n\n\t/**\n\t * @notice Returns if user is eligbile for auto compounding\n\t * @param _user address\n\t * @param _pending amount\n\t * @return True or False\n\t */\n\tfunction isEligibleForAutoCompound(address _user, uint256 _pending) public view returns (bool) {\n\t\tbool delayComplete = true;\n\t\tif (lastAutocompound[_user] != 0) {\n\t\t\tdelayComplete = (block.timestamp - lastAutocompound[_user]) >= MIN_DELAY;\n\t\t}\n\t\treturn\n\t\t\tIMultiFeeDistribution(multiFeeDistribution).autocompoundEnabled(_user) &&\n\t\t\tisEligibleForCompound(_pending) &&\n\t\t\tdelayComplete;\n\t}\n\n\t/**\n\t * @notice Returns if pending amount is elgible for auto compounding\n\t * @param _pending amount\n\t * @return eligible True or False\n\t */\n\tfunction isEligibleForCompound(uint256 _pending) public view returns (bool eligible) {\n\t\teligible = _pending >= autocompoundThreshold();\n\t}\n\n\t/**\n\t * @notice Returns if the user is eligible for auto compound\n\t * @param _user address\n\t * @return eligible `true` or `false`\n\t */\n\tfunction userEligibleForCompound(address _user) external view returns (bool eligible) {\n\t\teligible = _userEligibleForCompound(_user);\n\t}\n\n\t/**\n\t * @notice Returns if the `msg.sender` is eligible for self compound\n\t * @return eligible `true` or `false`\n\t */\n\tfunction selfEligibleCompound() external view returns (bool eligible) {\n\t\teligible = _userEligibleForCompound(msg.sender);\n\t}\n\n\t/**\n\t * @notice Returns if the user is eligible for auto compound\n\t * @param _user address the be checked\n\t * @return eligible `true` if eligible or `false` if not\n\t */\n\tfunction _userEligibleForCompound(address _user) internal view returns (bool eligible) {\n\t\t(address[] memory tokens, uint256[] memory amts) = viewPendingRewards(_user);\n\t\tuint256 pendingEth = _quoteSwapWithOracles(tokens, amts, baseToken);\n\t\teligible = pendingEth >= autocompoundThreshold();\n\t}\n\n\t/**\n\t * @notice Validate if the slippage limit is within the boundaries\n\t * @param _slippageLimit slippage limit to be validated\n\t */\n\tfunction _validateSlippageLimit(uint256 _slippageLimit) internal pure {\n\t\tif (_slippageLimit < MAX_SLIPPAGE_LIMIT || _slippageLimit >= PERCENT_DIVISOR) revert InvalidSlippage();\n\t}\n}\n"
    },
    "contracts/prime/eligibility/EligibilityDataProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\nimport {IMultiFeeDistribution} from \"../../interfaces/IMultiFeeDistribution.sol\";\nimport {IChefIncentivesController} from \"../../interfaces/IChefIncentivesController.sol\";\nimport {IPriceProvider} from \"../../interfaces/IPriceProvider.sol\";\nimport {IMiddleFeeDistribution} from \"../../interfaces/IMiddleFeeDistribution.sol\";\nimport {LockedBalance, Balances} from \"../../interfaces/LockedBalance.sol\";\n\n\n/// @title Eligible Deposit Provider\n/// @author Prime Labs\ncontract EligibilityDataProvider is OwnableUpgradeable {\n\t/********************** Common Info ***********************/\n\n\t/// @notice RATIO BASE equal to 100%\n\tuint256 public constant RATIO_DIVISOR = 10000;\n\n\t/// @notice Initial required ratio of TVL to get reward; in bips\n\tuint256 public constant INITIAL_REQUIRED_DEPOSIT_RATIO = 500;\n\n\t/// @notice Initial ratio of the required price to still allow without disqualification; in bips\n\tuint256 public constant INITIAL_PRICE_TOLERANCE_RATIO = 9000;\n\n\t/// @notice Minimum required ratio of TVL to get reward; in bips\n\tuint256 public constant MIN_PRICE_TOLERANCE_RATIO = 8000;\n\n\t/// @notice Address of Lending Pool\n\tILendingPool public lendingPool;\n\n\t/// @notice Address of CIC\n\tIChefIncentivesController public chef;\n\n\t/// @notice Address of Middle fee distribution\n\tIMiddleFeeDistribution public middleFeeDistribution;\n\n\t/// @notice PRNT + LP price provider\n\tIPriceProvider public priceProvider;\n\n\t/// @notice Required ratio of TVL to get reward; in bips\n\tuint256 public requiredDepositRatio;\n\n\t/// @notice Ratio of the required price to still allow without disqualification; in bips\n\tuint256 public priceToleranceRatio;\n\n\t/// @notice PRNT-ETH LP token\n\taddress public lpToken;\n\n\t/********************** Eligible info ***********************/\n\n\t/// @notice Last eligible status of the user\n\tmapping(address => bool) public lastEligibleStatus;\n\n\t/// @notice Disqualified time of the user\n\tmapping(address => uint256) public disqualifiedTime;\n\n\t/********************** Events ***********************/\n\n\t/// @notice Emitted when CIC is set\n\tevent ChefIncentivesControllerUpdated(IChefIncentivesController indexed _chef);\n\n\t/// @notice Emitted when LP token is set\n\tevent LPTokenUpdated(address indexed _lpToken);\n\n\t/// @notice Emitted when required TVL ratio is updated\n\tevent RequiredDepositRatioUpdated(uint256 indexed requiredDepositRatio);\n\n\t/// @notice Emitted when price tolerance ratio is updated\n\tevent PriceToleranceRatioUpdated(uint256 indexed priceToleranceRatio);\n\n\t/// @notice Emitted when DQ time is set\n\tevent DqTimeUpdated(address indexed _user, uint256 _time);\n\n\t/********************** Errors ***********************/\n\terror AddressZero();\n\n\terror LPTokenSet();\n\n\terror InvalidRatio();\n\n\terror OnlyCIC();\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Constructor\n\t * @param _lendingPool Address of lending pool.\n\t * @param _middleFeeDistribution MiddleFeeDistribution address.\n\t * @param _priceProvider PriceProvider address.\n\t */\n\tfunction initialize(\n\t\tILendingPool _lendingPool,\n\t\tIMiddleFeeDistribution _middleFeeDistribution,\n\t\tIPriceProvider _priceProvider\n\t) public initializer {\n\t\tif (address(_lendingPool) == address(0)) revert AddressZero();\n\t\tif (address(_middleFeeDistribution) == address(0)) revert AddressZero();\n\t\tif (address(_priceProvider) == address(0)) revert AddressZero();\n\n\t\tlendingPool = _lendingPool;\n\t\tmiddleFeeDistribution = _middleFeeDistribution;\n\t\tpriceProvider = _priceProvider;\n\t\trequiredDepositRatio = INITIAL_REQUIRED_DEPOSIT_RATIO;\n\t\tpriceToleranceRatio = INITIAL_PRICE_TOLERANCE_RATIO;\n\t\t__Ownable_init();\n\t}\n\n\t/********************** Setters ***********************/\n\n\t/**\n\t * @notice Set CIC\n\t * @param _chef address.\n\t */\n\tfunction setChefIncentivesController(IChefIncentivesController _chef) external onlyOwner {\n\t\tif (address(_chef) == address(0)) revert AddressZero();\n\t\tchef = _chef;\n\t\temit ChefIncentivesControllerUpdated(_chef);\n\t}\n\n\t/**\n\t * @notice Set LP token\n\t */\n\tfunction setLPToken(address _lpToken) external onlyOwner {\n\t\tif (_lpToken == address(0)) revert AddressZero();\n\t\tif (lpToken != address(0)) revert LPTokenSet();\n\t\tlpToken = _lpToken;\n\n\t\temit LPTokenUpdated(_lpToken);\n\t}\n\n\t/**\n\t * @notice Sets required tvl ratio. Can only be called by the owner.\n\t * @param _requiredDepositRatio Ratio in bips.\n\t */\n\tfunction setRequiredDepositRatio(uint256 _requiredDepositRatio) external onlyOwner {\n\t\tif (_requiredDepositRatio > RATIO_DIVISOR) revert InvalidRatio();\n\t\trequiredDepositRatio = _requiredDepositRatio;\n\n\t\temit RequiredDepositRatioUpdated(_requiredDepositRatio);\n\t}\n\n\t/**\n\t * @notice Sets price tolerance ratio. Can only be called by the owner.\n\t * @param _priceToleranceRatio Ratio in bips.\n\t */\n\tfunction setPriceToleranceRatio(uint256 _priceToleranceRatio) external onlyOwner {\n\t\tif (_priceToleranceRatio < MIN_PRICE_TOLERANCE_RATIO || _priceToleranceRatio > RATIO_DIVISOR)\n\t\t\trevert InvalidRatio();\n\t\tpriceToleranceRatio = _priceToleranceRatio;\n\n\t\temit PriceToleranceRatioUpdated(_priceToleranceRatio);\n\t}\n\n\t/**\n\t * @notice Sets DQ time of the user\n\t * @dev Only callable by CIC\n\t * @param _user's address\n\t * @param _time for DQ\n\t */\n\tfunction setDqTime(address _user, uint256 _time) external {\n\t\tif (msg.sender != address(chef)) revert OnlyCIC();\n\t\tdisqualifiedTime[_user] = _time;\n\n\t\temit DqTimeUpdated(_user, _time);\n\t}\n\n\t/********************** View functions ***********************/\n\n\t/**\n\t * @notice Returns locked PRNT and LP token value in eth\n\t * @param user's address\n\t */\n\tfunction lockedUsdValue(address user) public view returns (uint256) {\n\t\tIMultiFeeDistribution multiFeeDistribution = IMultiFeeDistribution(\n\t\t\tmiddleFeeDistribution.getMultiFeeDistributionAddress()\n\t\t);\n\t\tBalances memory _balances = multiFeeDistribution.getBalances(user);\n\t\treturn _lockedUsdValue(_balances.locked);\n\t}\n\n\t/**\n\t * @notice Returns USD value required to be locked\n\t * @param user's address\n\t * @return required USD value.\n\t */\n\tfunction requiredUsdValue(address user) public view returns (uint256 required) {\n\t\t(uint256 totalCollateralUSD, , , , , ) = lendingPool.getUserAccountData(user);\n\t\trequired = (totalCollateralUSD * requiredDepositRatio) / RATIO_DIVISOR;\n\t}\n\n\t/**\n\t * @notice Returns if the user is eligible to receive rewards\n\t * @param _user's address\n\t */\n\tfunction isEligibleForRewards(address _user) public view returns (bool) {\n\t\tuint256 lockedValue = lockedUsdValue(_user);\n\t\tuint256 requiredValue = (requiredUsdValue(_user) * priceToleranceRatio) / RATIO_DIVISOR;\n\t\treturn requiredValue != 0 && lockedValue >= requiredValue;\n\t}\n\n\t/**\n\t * @notice Returns DQ time of the user\n\t * @param _user's address\n\t */\n\tfunction getDqTime(address _user) public view returns (uint256) {\n\t\treturn disqualifiedTime[_user];\n\t}\n\n\t/**\n\t * @notice Returns last eligible time of the user\n\t * @dev If user is still eligible, it will return future time\n\t *  CAUTION: this function only works perfect when the array\n\t *  is ordered by lock time. This is assured when _stake happens.\n\t * @param user's address\n\t * @return lastEligibleTimestamp of the user. Returns 0 if user is not eligible.\n\t */\n\tfunction lastEligibleTime(address user) public view returns (uint256 lastEligibleTimestamp) {\n\t\tif (!isEligibleForRewards(user)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 requiredValue = requiredUsdValue(user);\n\n\t\tIMultiFeeDistribution multiFeeDistribution = IMultiFeeDistribution(\n\t\t\tmiddleFeeDistribution.getMultiFeeDistributionAddress()\n\t\t);\n\t\tLockedBalance[] memory lpLockData = multiFeeDistribution.lockInfo(user);\n\n\t\tuint256 lockedLP;\n\t\tfor (uint256 i = lpLockData.length; i > 0; ) {\n\t\t\tLockedBalance memory currentLockData = lpLockData[i - 1];\n\t\t\tlockedLP += currentLockData.amount;\n\n\t\t\tif (_lockedUsdValue(lockedLP) >= requiredValue) {\n\t\t\t\treturn currentLockData.unlockTime;\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/********************** Operate functions ***********************/\n\t/**\n\t * @notice Refresh token amount for eligibility\n\t * @param user The address of the user\n\t * @return currentEligibility The current eligibility status of the user\n\t */\n\tfunction refresh(address user) external returns (bool currentEligibility) {\n\t\tif (msg.sender != address(chef)) revert OnlyCIC();\n\t\tif (user == address(0)) revert AddressZero();\n\n\t\tupdatePrice();\n\t\tcurrentEligibility = isEligibleForRewards(user);\n\t\tif (currentEligibility && disqualifiedTime[user] != 0) {\n\t\t\tdisqualifiedTime[user] = 0;\n\t\t}\n\t\tlastEligibleStatus[user] = currentEligibility;\n\t}\n\n\t/**\n\t * @notice Update token price\n\t */\n\tfunction updatePrice() public {\n\t\tpriceProvider.update();\n\t}\n\n\t/********************** Internal functions ***********************/\n\n\t/**\n\t * @notice Returns locked PRNT and LP token value in USD\n\t * @param lockedLP is locked lp amount\n\t */\n\tfunction _lockedUsdValue(uint256 lockedLP) internal view returns (uint256) {\n\t\tuint256 lpPrice = priceProvider.getLpTokenPriceUsd();\n\t\treturn (lockedLP * lpPrice) / 10 ** 18;\n\t}\n}\n"
    },
    "contracts/prime/libraries/RecoverERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title RecoverERC20 contract\n/// @author Prime Devs\n/// @dev All function calls are currently implemented without side effects\ncontract RecoverERC20 {\n\tusing SafeERC20 for IERC20;\n\n\t/// @notice Emitted when ERC20 token is recovered\n\tevent Recovered(address indexed token, uint256 amount);\n\n\t/**\n\t * @notice Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n\t */\n\tfunction _recoverERC20(address tokenAddress, uint256 tokenAmount) internal {\n\t\tIERC20(tokenAddress).safeTransfer(msg.sender, tokenAmount);\n\t\temit Recovered(tokenAddress, tokenAmount);\n\t}\n}\n"
    },
    "contracts/prime/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\n// helper methods from uniswap, for sending ETH that do not consistently return true/false\n// we modified the original code\nlibrary TransferHelper {\n\terror ETHTransferFailed();\n\n\t/**\n\t * @notice Transfer ETH\n\t * @param to address\n\t * @param value ETH amount\n\t */\n\tfunction safeTransferETH(address to, uint256 value) internal {\n\t\t(bool success, ) = to.call{value: value}(new bytes(0));\n\t\tif (!success) revert ETHTransferFailed();\n\t}\n}\n"
    },
    "contracts/prime/libraries/UniV2Helper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IUniswapV2Router02} from \"../../interfaces/uniswap/IUniswapV2Router02.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nlibrary UniV2Helper {\n    using SafeERC20 for IERC20;\n\n    /**\n\t * @notice Swap the privded amount of _inTokens for _outTokens\n\t * @param _router the AMM router that will be used to perform the price query\n\t * @param _inToken the address of the token that will be sold\n\t * @param _outToken the address of the token that will be bought\n\t * @param _inAmount amount of _inTokens to be sold\n\t * @return amount of _outTokens received\n\t */\n    function _swap(address _router, address _inToken, address _outToken, uint256 _inAmount) internal returns(uint256){\n        address[] memory path = new address[](2);\n        path[0] = _inToken;\n        path[1] = _outToken;\n        IERC20(_inToken).forceApprove(_router, _inAmount);\n        return IUniswapV2Router02(_router).swapExactTokensForTokens(\n            _inAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        )[1];\n    } \n\n    /**\n\t * @notice Query the amount of _outTokens received for a given amount of _inTokens\n\t * @param _router the AMM router that will be used to perform the price query\n\t * @param _inToken the address of the token that will be sold\n\t * @param _outToken the address of the token that will be bought\n\t * @param _inAmount amount of _inTokens to be sold\n\t * @return amount of _outTokens received\n\t */\n    function _quoteSwap(address _router, address _inToken, address _outToken, uint256 _inAmount) internal view returns(uint256){\n        address[] memory path = new address[](2);\n        path[0] = _inToken;\n        path[1] = _outToken;\n        return IUniswapV2Router02(_router).getAmountsOut(_inAmount, path)[1];\n    } \n}"
    },
    "contracts/prime/staking/MiddleFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {RecoverERC20} from \"../libraries/RecoverERC20.sol\";\nimport {IMiddleFeeDistribution} from \"../../interfaces/IMiddleFeeDistribution.sol\";\nimport {IMultiFeeDistribution} from \"../../interfaces/IMultiFeeDistribution.sol\";\nimport {IMintableToken} from \"../../interfaces/IMintableToken.sol\";\nimport {IAaveOracle} from \"../../interfaces/IAaveOracle.sol\";\nimport {IAToken} from \"../../interfaces/IAToken.sol\";\nimport {IChainlinkAggregator} from \"../../interfaces/IChainlinkAggregator.sol\";\nimport {IAaveProtocolDataProvider} from \"../../interfaces/IAaveProtocolDataProvider.sol\";\nimport {IPriceProvider} from \"../../interfaces/IPriceProvider.sol\";\n\n/// @title Fee distributor inside\n/// @author Prime\ncontract MiddleFeeDistribution is IMiddleFeeDistribution, Initializable, OwnableUpgradeable, RecoverERC20 {\n\tusing SafeERC20 for IERC20;\n\n\t/// @notice PRNT token\n\tIMintableToken public prntToken;\n\n\t/// @notice Fee distributor contract for earnings and PRNT lockings\n\tIMultiFeeDistribution public multiFeeDistribution;\n\n\t/// @notice Reward ratio for operation expenses\n\tuint256 public operationExpenseRatio;\n\n\tuint256 public constant RATIO_DIVISOR = 10000;\n\n\tuint8 public constant DECIMALS = 18;\n\n\tmapping(address => bool) public isRewardToken;\n\n\t/// @notice Operation Expense account\n\taddress public operationExpenses;\n\n\t/// @notice Admin address\n\taddress public admin;\n\n\t// AAVE Oracle address\n\taddress internal _aaveOracle;\n\n\t// AAVE Protocol Data Provider address\n\tIAaveProtocolDataProvider public aaveProtocolDataProvider;\n\n\t/********************** Events ***********************/\n\n\t/// @notice Emitted when reward token is forwarded\n\tevent ForwardReward(address indexed token, uint256 amount);\n\n\t/// @notice Emitted when operation expenses is set\n\tevent OperationExpensesUpdated(address indexed _operationExpenses, uint256 _operationExpenseRatio);\n\n\tevent NewTransferAdded(address indexed asset, uint256 lpUsdValue);\n\n\tevent AdminUpdated(address indexed _configurator);\n\n\tevent RewardsUpdated(address indexed _rewardsToken);\n\n\tevent ProtocolDataProviderUpdated(address indexed _providerAddress);\n\n\t/********************** Errors ***********************/\n\n\terror ZeroAddress();\n\n\terror IncompatibleToken();\n\n\terror InvalidRatio();\n\n\terror NotMFD();\n\n\terror InsufficientPermission();\n\n\t/**\n\t * @dev Throws if called by any account other than the admin or owner.\n\t */\n\tmodifier onlyAdminOrOwner() {\n\t\tif (admin != _msgSender() && owner() != _msgSender()) revert InsufficientPermission();\n\t\t_;\n\t}\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Initializer\n\t * @param prntToken_ PRNT address\n\t * @param aaveOracle_ Aave oracle address\n\t * @param multiFeeDistribution_ Multi fee distribution contract\n\t */\n\tfunction initialize(\n\t\tIMintableToken prntToken_,\n\t\taddress aaveOracle_,\n\t\tIMultiFeeDistribution multiFeeDistribution_,\n\t\tIAaveProtocolDataProvider aaveProtocolDataProvider_\n\t) public initializer {\n\t\tif (aaveOracle_ == address(0)) revert ZeroAddress();\n\t\tif (address(prntToken_) == address(0)) revert ZeroAddress();\n\t\tif (address(multiFeeDistribution_) == address(0)) revert ZeroAddress();\n\t\tif (address(aaveProtocolDataProvider_) == address(0)) revert ZeroAddress();\n\n\t\t__Ownable_init();\n\n\t\tprntToken = prntToken_;\n\t\t_aaveOracle = aaveOracle_;\n\t\tmultiFeeDistribution = multiFeeDistribution_;\n\t\taaveProtocolDataProvider = aaveProtocolDataProvider_;\n\n\t\tadmin = msg.sender;\n\t}\n\n\t/**\n\t * @notice Set operation expenses account\n\t * @param _operationExpenses Address to receive operation expenses\n\t * @param _operationExpenseRatio Proportion of operation expense\n\t */\n\tfunction setOperationExpenses(address _operationExpenses, uint256 _operationExpenseRatio) external onlyOwner {\n\t\tif (_operationExpenseRatio > RATIO_DIVISOR) revert InvalidRatio();\n\t\tif (_operationExpenses == address(0)) revert ZeroAddress();\n\t\toperationExpenses = _operationExpenses;\n\t\toperationExpenseRatio = _operationExpenseRatio;\n\t\temit OperationExpensesUpdated(_operationExpenses, _operationExpenseRatio);\n\t}\n\n\t/**\n\t * @notice Sets pool configurator as admin.\n\t * @param _configurator Configurator address\n\t */\n\tfunction setAdmin(address _configurator) external onlyOwner {\n\t\tif (_configurator == address(0)) revert ZeroAddress();\n\t\tadmin = _configurator;\n\t\temit AdminUpdated(_configurator);\n\t}\n\n\t/**\n\t * @notice Set the Protocol Data Provider address\n\t * @param _providerAddress The address of the protocol data provider contract\n\t */\n\tfunction setProtocolDataProvider(IAaveProtocolDataProvider _providerAddress) external onlyOwner {\n\t\tif (address(_providerAddress) == address(0)) revert ZeroAddress();\n\t\taaveProtocolDataProvider = _providerAddress;\n\t\temit ProtocolDataProviderUpdated(address(_providerAddress));\n\t}\n\n\t/**\n\t * @notice Add a new reward token to be distributed to stakers\n\t * @param _rewardsToken address of the reward token\n\t */\n\tfunction addReward(address _rewardsToken) external onlyAdminOrOwner {\n\t\tif (msg.sender != admin) {\n\t\t\ttry IAToken(_rewardsToken).UNDERLYING_ASSET_ADDRESS() returns (address underlying) {\n\t\t\t\t(address aTokenAddress, , ) = aaveProtocolDataProvider.getReserveTokensAddresses(underlying);\n\t\t\t\tif (aTokenAddress == address(0)) revert IncompatibleToken();\n\t\t\t} catch {\n\t\t\t\t// _rewardsToken is not an rToken, do nothing\n\t\t\t}\n\t\t}\n\t\tmultiFeeDistribution.addReward(_rewardsToken);\n\t\tisRewardToken[_rewardsToken] = true;\n\t\temit RewardsUpdated(_rewardsToken);\n\t}\n\n\t/**\n\t * @notice Remove an existing reward token\n\t */\n\tfunction removeReward(address _rewardsToken) external onlyAdminOrOwner {\n\t\tif (_rewardsToken == address(0)) revert ZeroAddress();\n\t\tmultiFeeDistribution.removeReward(_rewardsToken);\n\t\tisRewardToken[_rewardsToken] = false;\n\t\temit RewardsUpdated(_rewardsToken);\n\t}\n\n\t/**\n\t * @notice Run by MFD to pull pending platform revenue\n\t * @param _rewardTokens an array of reward token addresses\n\t */\n\tfunction forwardReward(address[] memory _rewardTokens) external {\n\t\tif (msg.sender != address(multiFeeDistribution)) revert NotMFD();\n\n\t\tuint256 length = _rewardTokens.length;\n\t\tfor (uint256 i = 0; i < length; ) {\n\t\t\taddress rewardToken = _rewardTokens[i];\n\t\t\tuint256 total = IERC20(rewardToken).balanceOf(address(this));\n\n\t\t\tif (operationExpenses != address(0) && operationExpenseRatio != 0) {\n\t\t\t\tuint256 opExAmount = (total * operationExpenseRatio) / RATIO_DIVISOR;\n\t\t\t\tif (opExAmount != 0) {\n\t\t\t\t\tIERC20(rewardToken).safeTransfer(operationExpenses, opExAmount);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttotal = IERC20(rewardToken).balanceOf(address(this));\n\t\t\tIERC20(rewardToken).safeTransfer(address(multiFeeDistribution), total);\n\n\t\t\tif (rewardToken == address(prntToken)) {\n\t\t\t\tmultiFeeDistribution.vestTokens(address(multiFeeDistribution), total, false);\n\t\t\t}\n\n\t\t\temit ForwardReward(rewardToken, total);\n\n\t\t\t_emitNewTransferAdded(rewardToken, total);\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Returns PRNT token address.\n\t * @return PRNT token address\n\t */\n\tfunction getPrntTokenAddress() external view returns (address) {\n\t\treturn address(prntToken);\n\t}\n\n\t/**\n\t * @notice Returns MFD address.\n\t * @return MFD address\n\t */\n\tfunction getMultiFeeDistributionAddress() external view returns (address) {\n\t\treturn address(multiFeeDistribution);\n\t}\n\n\t/**\n\t * @notice Emit event for new asset reward\n\t * @param asset address of transfer assset\n\t * @param lpReward amount of rewards\n\t */\n\tfunction _emitNewTransferAdded(address asset, uint256 lpReward) internal {\n\t\tuint256 lpUsdValue;\n\t\tif (asset != address(prntToken)) {\n\t\t\ttry IAToken(asset).UNDERLYING_ASSET_ADDRESS() returns (address underlyingAddress) {\n\t\t\t\tif (underlyingAddress != address(prntToken)) {\n\t\t\t\t\tuint256 assetPrice = IAaveOracle(_aaveOracle).getAssetPrice(underlyingAddress);\n\t\t\t\t\taddress sourceOfAsset = IAaveOracle(_aaveOracle).getSourceOfAsset(underlyingAddress);\n\t\t\t\t\tuint8 priceDecimal = IChainlinkAggregator(sourceOfAsset).decimals();\n\t\t\t\t\tuint8 assetDecimals = IERC20Metadata(asset).decimals();\n\t\t\t\t\tlpUsdValue = (assetPrice * lpReward * (10 ** DECIMALS)) / (10 ** priceDecimal) / (10 ** assetDecimals);\n\t\t\t\t} else {\n\t\t\t\t\tuint256 assetPrice = IPriceProvider(IMintableToken(prntToken).priceProvider()).getTokenPriceUsd();\n\t\t\t\t\tuint256 priceDecimal = IPriceProvider(IMintableToken(prntToken).priceProvider()).decimals();\n\t\t\t\t\tuint8 assetDecimals = IERC20Metadata(asset).decimals();\n\t\t\t\t\tlpUsdValue = (assetPrice * lpReward * (10 ** DECIMALS)) / (10 ** priceDecimal) / (10 ** assetDecimals);\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\tuint256 assetPrice = IAaveOracle(_aaveOracle).getAssetPrice(asset);\n\t\t\t\taddress sourceOfAsset = IAaveOracle(_aaveOracle).getSourceOfAsset(asset);\n\t\t\t\tuint8 priceDecimal = IChainlinkAggregator(sourceOfAsset).decimals();\n\t\t\t\tuint8 assetDecimals = IERC20Metadata(asset).decimals();\n\t\t\t\tlpUsdValue = (assetPrice * lpReward * (10 ** DECIMALS)) / (10 ** priceDecimal) / (10 ** assetDecimals);\n\t\t\t}\n\t\t\temit NewTransferAdded(asset, lpUsdValue);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Added to support recovering any ERC20 tokens inside the contract\n\t * @param tokenAddress address of erc20 token to recover\n\t * @param tokenAmount amount to recover\n\t */\n\tfunction recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n\t\t_recoverERC20(tokenAddress, tokenAmount);\n\t}\n}\n"
    },
    "contracts/prime/zap/helpers/DustRefunder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IWETH} from \"../../../interfaces/IWETH.sol\";\n\n/// @title Dust Refunder Contract\n/// @dev Refunds dust tokens remaining from zapping.\n/// @author Prime\ncontract DustRefunder {\n\tusing SafeERC20 for IERC20;\n\n\t/**\n\t * @notice Refunds PRNT and WETH.\n\t * @param _prnt PRNT address\n\t * @param _weth WETH address\n\t * @param _refundAddress Address for refund\n\t */\n\tfunction _refundDust(address _prnt, address _weth, address _refundAddress) internal {\n\t\tIERC20 prnt = IERC20(_prnt);\n\t\tIWETH weth = IWETH(_weth);\n\n\t\tuint256 dustWETH = weth.balanceOf(address(this));\n\t\tif (dustWETH > 0) {\n\t\t\tweth.transfer(_refundAddress, dustWETH);\n\t\t}\n\t\tuint256 dustPrnt = prnt.balanceOf(address(this));\n\t\tif (dustPrnt > 0) {\n\t\t\tprnt.safeTransfer(_refundAddress, dustPrnt);\n\t\t}\n\t}\n}\n"
    },
    "contracts/prime/zap/helpers/LiquidityZap.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.12;\n\n//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\n//\n// LiquidityZAP takes ETH and converts to  liquidity tokens.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program.\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// Attribution: CORE / cvault.finance\n//  https://github.com/cVault-finance/CORE-periphery/blob/master/contracts/COREv1Router.sol\n//\n//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\n//----------------------------------------------------------------------------------\n//    I n s t a n t\n//\n//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.\n//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.\n//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:\n//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'\n//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'\n//\n//----------------------------------------------------------------------------------\n\nimport {IUniswapV2Pair} from \"../../../uniswap-solc-0.8/interfaces/IUniswapV2Pair.sol\";\nimport {UniswapV2Library} from \"../../../uniswap-solc-0.8/libraries/UniswapV2Library.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {DustRefunder} from \"./DustRefunder.sol\";\n\nimport {IWETH} from \"../../../interfaces/IWETH.sol\";\nimport {IPriceProvider} from \"../../../interfaces/IPriceProvider.sol\";\nimport {IChainlinkAdapter} from \"../../../interfaces/IChainlinkAdapter.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/// @title Prime token contract with OFT integration\n/// @author Prime Devs\ncontract LiquidityZap is Initializable, OwnableUpgradeable, DustRefunder {\n\tusing SafeERC20 for IERC20;\n\n\terror ZapExists();\n\terror InvalidETHAmount();\n\terror AddressZero();\n\terror InsufficientPermission();\n\terror TransferFailed();\n\terror InvalidRatio();\n\terror InvalidSlippage();\n\n\taddress public token;\n\taddress public tokenWETHPair;\n\tIWETH public weth;\n\tbool private initializedLiquidityZap;\n\taddress public poolHelper;\n\n\t/// @notice ratio Divisor\n\tuint256 public constant RATIO_DIVISOR = 10000;\n\n\t/// @notice Acceptable ratio\n\tuint256 public acceptableRatio;\n\n\t/// @notice Price provider contract\n\tIPriceProvider public priceProvider;\n\n\t/// @notice ETH oracle contract\n\tIChainlinkAdapter public ethOracle;\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Initialize\n\t */\n\tfunction initialize() external initializer {\n\t\t__Ownable_init();\n\t}\n\n\t/**\n\t * @notice Initialize liquidity zap param\n\t * @param token_ PRNT address\n\t * @param weth_ WETH address\n\t * @param tokenWethPair_ LP pair\n\t * @param helper_ Pool helper contract\n\t */\n\tfunction initLiquidityZap(\n\t\taddress token_,\n\t\taddress weth_,\n\t\taddress tokenWethPair_,\n\t\taddress helper_\n\t) external onlyOwner {\n\t\tif (initializedLiquidityZap) revert ZapExists();\n\t\ttoken = token_;\n\t\tweth = IWETH(weth_);\n\t\ttokenWETHPair = tokenWethPair_;\n\t\tinitializedLiquidityZap = true;\n\t\tpoolHelper = helper_;\n\t}\n\n\tfallback() external payable {\n\t\tif (msg.sender != address(weth)) {\n\t\t\taddLiquidityETHOnly(payable(msg.sender));\n\t\t}\n\t}\n\n\treceive() external payable {\n\t\tif (msg.sender != address(weth)) {\n\t\t\taddLiquidityETHOnly(payable(msg.sender));\n\t\t}\n\t}\n\n\t/**\n\t * @notice Set Price Provider.\n\t * @param _provider Price provider contract address.\n\t */\n\tfunction setPriceProvider(address _provider) external onlyOwner {\n\t\tif (address(_provider) == address(0)) revert AddressZero();\n\t\tpriceProvider = IPriceProvider(_provider);\n\t\tethOracle = IChainlinkAdapter(priceProvider.baseAssetChainlinkAdapter());\n\t}\n\n\t/**\n\t * @notice Set Acceptable Ratio.\n\t * @param _acceptableRatio Acceptable slippage ratio.\n\t */\n\tfunction setAcceptableRatio(uint256 _acceptableRatio) external onlyOwner {\n\t\tif (_acceptableRatio > RATIO_DIVISOR) revert InvalidRatio();\n\t\tacceptableRatio = _acceptableRatio;\n\t}\n\n\t/**\n\t * @notice Zap ethereum\n\t * @param _onBehalf of the user\n\t * @return liquidity lp amount\n\t */\n\tfunction zapETH(address payable _onBehalf) external payable returns (uint256) {\n\t\tif (msg.value == 0) revert InvalidETHAmount();\n\t\treturn addLiquidityETHOnly(_onBehalf);\n\t}\n\n\t/**\n\t * @notice Add liquidity with WETH\n\t * @param _amount of WETH\n\t * @param to address of lp token\n\t * @return liquidity lp amount\n\t */\n\tfunction addLiquidityWETHOnly(uint256 _amount, address payable to) public returns (uint256) {\n\t\tif (msg.sender != poolHelper) revert InsufficientPermission();\n\t\tif (to == address(0)) revert AddressZero();\n\t\tuint256 buyAmount = _amount / 2;\n\t\tif (buyAmount == 0) revert InvalidETHAmount();\n\n\t\t(uint256 reserveWeth, uint256 reserveTokens) = _getPairReserves();\n\t\tuint256 outTokens = UniswapV2Library.getAmountOut(buyAmount, reserveWeth, reserveTokens);\n\n\t\tweth.transfer(tokenWETHPair, buyAmount);\n\n\t\t(address token0, address token1) = UniswapV2Library.sortTokens(address(weth), token);\n\t\tIUniswapV2Pair(tokenWETHPair).swap(\n\t\t\ttoken == token0 ? outTokens : 0,\n\t\t\ttoken == token1 ? outTokens : 0,\n\t\t\taddress(this),\n\t\t\t\"\"\n\t\t);\n\n\t\treturn _addLiquidity(outTokens, buyAmount, to);\n\t}\n\n\t/**\n\t * @notice Add liquidity with ETH\n\t * @param to address of lp token\n\t * @return liquidity lp amount\n\t */\n\tfunction addLiquidityETHOnly(address payable to) public payable returns (uint256) {\n\t\tif (to == address(0)) revert AddressZero();\n\t\tuint256 buyAmount = msg.value / 2;\n\t\tif (buyAmount == 0) revert InvalidETHAmount();\n\t\tweth.deposit{value: msg.value}();\n\n\t\t(uint256 reserveWeth, uint256 reserveTokens) = _getPairReserves();\n\t\tuint256 outTokens = UniswapV2Library.getAmountOut(buyAmount, reserveWeth, reserveTokens);\n\n\t\tif (address(priceProvider) != address(0)) {\n\t\t\tuint256 slippage = _calcSlippage(buyAmount, outTokens);\n\t\t\tif (slippage < acceptableRatio) revert InvalidSlippage();\n\t\t}\n\n\t\tweth.transfer(tokenWETHPair, buyAmount);\n\n\t\t(address token0, address token1) = UniswapV2Library.sortTokens(address(weth), token);\n\t\tIUniswapV2Pair(tokenWETHPair).swap(\n\t\t\ttoken == token0 ? outTokens : 0,\n\t\t\ttoken == token1 ? outTokens : 0,\n\t\t\taddress(this),\n\t\t\t\"\"\n\t\t);\n\n\t\treturn _addLiquidity(outTokens, buyAmount, to);\n\t}\n\n\t/**\n\t * @notice Quote WETH amount from PRNT\n\t * @param tokenAmount PRNT amount\n\t * @return optimalWETHAmount Output WETH amount\n\t */\n\tfunction quoteFromToken(uint256 tokenAmount) public view returns (uint256 optimalWETHAmount) {\n\t\t(uint256 wethReserve, uint256 tokenReserve) = _getPairReserves();\n\t\toptimalWETHAmount = UniswapV2Library.quote(tokenAmount, tokenReserve, wethReserve);\n\t}\n\n\t/**\n\t * @notice Quote PRNT amount from WETH\n\t * @param wethAmount PRNT amount\n\t * @return optimalTokenAmount Output PRNT amount\n\t */\n\tfunction quote(uint256 wethAmount) public view returns (uint256 optimalTokenAmount) {\n\t\t(uint256 wethReserve, uint256 tokenReserve) = _getPairReserves();\n\t\toptimalTokenAmount = UniswapV2Library.quote(wethAmount, wethReserve, tokenReserve);\n\t}\n\n\t/**\n\t * @notice Add liquidity with PRNT and WETH\n\t * @dev use with quote\n\t * @param tokenAmount PRNT amount\n\t * @param _wethAmt WETH amount\n\t * @param to LP address to be transferred\n\t * @return liquidity LP amount\n\t */\n\tfunction standardAdd(uint256 tokenAmount, uint256 _wethAmt, address payable to) public returns (uint256) {\n\t\tif (to == address(0)) revert AddressZero();\n\t\tif (tokenAmount == 0 || _wethAmt == 0) revert InvalidETHAmount();\n\t\tIERC20(token).safeTransferFrom(msg.sender, address(this), tokenAmount);\n\t\tweth.transferFrom(msg.sender, address(this), _wethAmt);\n\t\treturn _addLiquidity(tokenAmount, _wethAmt, to);\n\t}\n\n\t/**\n\t * @notice Add liquidity with PRNT and WETH\n\t * @dev use with quote\n\t * @param tokenAmount PRNT amount\n\t * @param wethAmount WETH amount\n\t * @param to LP address to be transferred\n\t * @return liquidity LP amount\n\t */\n\tfunction _addLiquidity(\n\t\tuint256 tokenAmount,\n\t\tuint256 wethAmount,\n\t\taddress payable to\n\t) internal returns (uint256 liquidity) {\n\t\tuint256 optimalTokenAmount = quote(wethAmount);\n\n\t\tuint256 optimalWETHAmount;\n\t\tif (optimalTokenAmount > tokenAmount) {\n\t\t\toptimalWETHAmount = quoteFromToken(tokenAmount);\n\t\t\toptimalTokenAmount = tokenAmount;\n\t\t} else {\n\t\t\toptimalWETHAmount = wethAmount;\n\t\t}\n\n\t\tbool wethTransferSuccess = weth.transfer(tokenWETHPair, optimalWETHAmount);\n\t\tif (!wethTransferSuccess) revert TransferFailed();\n\t\tIERC20(token).safeTransfer(tokenWETHPair, optimalTokenAmount);\n\n\t\tliquidity = IUniswapV2Pair(tokenWETHPair).mint(to);\n\n\t\t//refund dust\n\t\t_refundDust(token, address(weth), to);\n\t}\n\n\t/**\n\t * @notice LP token amount entitled with ETH\n\t * @param ethAmt ETH amount\n\t * @return liquidity LP amount\n\t */\n\tfunction getLPTokenPerEthUnit(uint256 ethAmt) public view returns (uint256 liquidity) {\n\t\t(uint256 reserveWeth, uint256 reserveTokens) = _getPairReserves();\n\t\tuint256 outTokens = UniswapV2Library.getAmountOut(ethAmt / 2, reserveWeth, reserveTokens);\n\t\tuint256 _totalSupply = IUniswapV2Pair(tokenWETHPair).totalSupply();\n\n\t\t(address token0, ) = UniswapV2Library.sortTokens(address(weth), token);\n\t\t(uint256 amount0, uint256 amount1) = token0 == token ? (outTokens, ethAmt / 2) : (ethAmt / 2, outTokens);\n\t\t(uint256 _reserve0, uint256 _reserve1) = token0 == token\n\t\t\t? (reserveTokens, reserveWeth)\n\t\t\t: (reserveWeth, reserveTokens);\n\t\tliquidity = Math.min((amount0 * _totalSupply) / _reserve0, (amount1 * _totalSupply) / _reserve1);\n\t}\n\n\t/**\n\t * @notice Get amount of lp reserves\n\t * @return wethReserves WETH amount\n\t * @return tokenReserves PRNT amount\n\t */\n\tfunction _getPairReserves() internal view returns (uint256 wethReserves, uint256 tokenReserves) {\n\t\t(address token0, ) = UniswapV2Library.sortTokens(address(weth), token);\n\t\t(uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(tokenWETHPair).getReserves();\n\t\t(wethReserves, tokenReserves) = token0 == token ? (reserve1, reserve0) : (reserve0, reserve1);\n\t}\n\n\t/**\n\t * @notice Calculates slippage ratio from weth to PRNT\n\t * @param _ethAmt ETH amount\n\t * @param _tokens PRNT token amount\n\t */\n\tfunction _calcSlippage(uint256 _ethAmt, uint256 _tokens) internal returns (uint256 ratio) {\n\t\tpriceProvider.update();\n\t\tuint256 tokenAmtEth = (_tokens * priceProvider.getTokenPrice() * 1e18) / (10 ** priceProvider.decimals()); // price decimal is 8\n\t\tratio = (tokenAmtEth * RATIO_DIVISOR) / _ethAmt;\n\t\tratio = ratio / 1E18;\n\t}\n}\n"
    },
    "contracts/prime/zap/helpers/UniswapPoolHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {DustRefunder} from \"./DustRefunder.sol\";\nimport {UniswapV2Library} from \"../../../uniswap-solc-0.8/libraries/UniswapV2Library.sol\";\nimport {IUniswapV2Pair} from \"../../../uniswap-solc-0.8/interfaces/IUniswapV2Pair.sol\";\nimport {IUniswapV2Factory} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {HomoraMath} from \"../../../dependencies/math/HomoraMath.sol\";\nimport {IUniswapV2Router02} from \"../../../interfaces/uniswap/IUniswapV2Router02.sol\";\nimport {ILiquidityZap} from \"../../../interfaces/ILiquidityZap.sol\";\nimport {IWETH} from \"../../../interfaces/IWETH.sol\";\n\n/// @title Uniswap Pool Helper Contract\n/// @author Prime\ncontract UniswapPoolHelper is Initializable, OwnableUpgradeable, DustRefunder {\n\tusing SafeERC20 for IERC20;\n\tusing HomoraMath for uint256;\n\n\t/********************** Events ***********************/\n\tevent LiquidityZapUpdated(address indexed _liquidityZap);\n\n\tevent LockZapUpdated(address indexed _lockZap);\n\n\t/********************** Errors ***********************/\n\terror AddressZero();\n\terror InsufficientPermission();\n\n\taddress public lpTokenAddr;\n\taddress public prntAddr;\n\taddress public wethAddr;\n\n\tIUniswapV2Router02 public router;\n\tILiquidityZap public liquidityZap;\n\taddress public lockZap;\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Initializer\n\t * @param _prntAddr PRNT address\n\t * @param _wethAddr WETH address\n\t * @param _routerAddr Uniswap router address\n\t * @param _liquidityZap LiquidityZap addrress\n\t */\n\tfunction initialize(\n\t\taddress _prntAddr,\n\t\taddress _wethAddr,\n\t\taddress _routerAddr,\n\t\tILiquidityZap _liquidityZap\n\t) external initializer {\n\t\tif (_prntAddr == address(0)) revert AddressZero();\n\t\tif (_wethAddr == address(0)) revert AddressZero();\n\t\tif (_routerAddr == address(0)) revert AddressZero();\n\t\tif (address(_liquidityZap) == address(0)) revert AddressZero();\n\n\t\t__Ownable_init();\n\n\t\tprntAddr = _prntAddr;\n\t\twethAddr = _wethAddr;\n\n\t\trouter = IUniswapV2Router02(_routerAddr);\n\t\tliquidityZap = _liquidityZap;\n\t}\n\n\t/**\n\t * @notice Initialize PRNT/WETH pool and liquidity zap\n\t */\n\tfunction initializePool() public onlyOwner {\n\t\tlpTokenAddr = IUniswapV2Factory(router.factory()).createPair(prntAddr, wethAddr);\n\n\t\tIERC20 prnt = IERC20(prntAddr);\n\t\tprnt.forceApprove(address(router), type(uint256).max);\n\t\tprnt.forceApprove(address(liquidityZap), type(uint256).max);\n\t\tIERC20(wethAddr).approve(address(liquidityZap), type(uint256).max);\n\t\tIERC20(wethAddr).approve(address(router), type(uint256).max);\n\n\t\trouter.addLiquidity(\n\t\t\taddress(prnt),\n\t\t\twethAddr,\n\t\t\tprnt.balanceOf(address(this)),\n\t\t\tIERC20(wethAddr).balanceOf(address(this)),\n\t\t\t0,\n\t\t\t0,\n\t\t\taddress(this),\n\t\t\tblock.timestamp\n\t\t);\n\n\t\tIERC20 lp = IERC20(lpTokenAddr);\n\t\tlp.safeTransfer(msg.sender, lp.balanceOf(address(this)));\n\t}\n\n\t/**\n\t * @notice Gets needed WETH for adding LP\n\t * @param lpAmount LP amount\n\t * @return wethAmount WETH amount\n\t */\n\tfunction quoteWETH(uint256 lpAmount) public view returns (uint256 wethAmount) {\n\t\tIUniswapV2Pair lpToken = IUniswapV2Pair(lpTokenAddr);\n\n\t\t(uint256 reserve0, uint256 reserve1, ) = lpToken.getReserves();\n\t\tuint256 weth = lpToken.token0() != address(prntAddr) ? reserve0 : reserve1;\n\t\tuint256 prnt = lpToken.token0() == address(prntAddr) ? reserve0 : reserve1;\n\t\tuint256 lpTokenSupply = lpToken.totalSupply();\n\n\t\tuint256 neededPrnt = (prnt * lpAmount) / lpTokenSupply;\n\t\tuint256 neededWeth = (prnt * lpAmount) / lpTokenSupply;\n\n\t\tuint256 neededPrntInWeth = router.getAmountIn(neededPrnt, weth, prnt);\n\t\treturn neededWeth + neededPrntInWeth;\n\t}\n\n\t/**\n\t * @notice Zap WETH into LP\n\t * @param amount of WETH\n\t * @return liquidity LP token amount\n\t */\n\tfunction zapWETH(uint256 amount) public returns (uint256 liquidity) {\n\t\tif (msg.sender != lockZap) revert InsufficientPermission();\n\t\tIWETH weth = IWETH(wethAddr);\n\t\tweth.transferFrom(msg.sender, address(liquidityZap), amount);\n\t\tliquidityZap.addLiquidityWETHOnly(amount, payable(address(this)));\n\t\tIERC20 lp = IERC20(lpTokenAddr);\n\n\t\tliquidity = lp.balanceOf(address(this));\n\t\tlp.safeTransfer(msg.sender, liquidity);\n\t\t_refundDust(prntAddr, wethAddr, msg.sender);\n\t}\n\n\t/**\n\t * @notice Returns reserve information.\n\t * @return prnt PRNT amount\n\t * @return weth WETH amount\n\t * @return lpTokenSupply LP token supply\n\t */\n\tfunction getReserves() public view returns (uint256 prnt, uint256 weth, uint256 lpTokenSupply) {\n\t\tIUniswapV2Pair lpToken = IUniswapV2Pair(lpTokenAddr);\n\n\t\t(uint256 reserve0, uint256 reserve1, ) = lpToken.getReserves();\n\t\tweth = lpToken.token0() != address(prntAddr) ? reserve0 : reserve1;\n\t\tprnt = lpToken.token0() == address(prntAddr) ? reserve0 : reserve1;\n\n\t\tlpTokenSupply = lpToken.totalSupply();\n\t}\n\n\t// UniV2 / SLP LP Token Price\n\t// Alpha Homora Fair LP Pricing Method (flash loan resistant)\n\t// https://cmichel.io/pricing-lp-tokens/\n\t// https://blog.alphafinance.io/fair-lp-token-pricing/\n\t// https://github.com/AlphaFinanceLab/alpha-homora-v2-contract/blob/master/contracts/oracle/UniswapV2Oracle.sol\n\t/**\n\t * @notice Returns LP price\n\t * @param prntPriceInEth price of PRNT in ETH\n\t * @return priceInEth LP price in ETH\n\t */\n\tfunction getLpPrice(uint256 prntPriceInEth) public view returns (uint256 priceInEth) {\n\t\t(uint256 prntReserve, uint256 wethReserve, uint256 lpSupply) = getReserves();\n\n\t\tuint256 sqrtK = HomoraMath.sqrt(prntReserve * wethReserve).fdiv(lpSupply); // in 2**112\n\n\t\t// prnt in eth, decis 8\n\t\tuint256 px0 = prntPriceInEth * (2 ** 112); // in 2**112\n\t\t// eth in eth, decis 8\n\t\tuint256 px1 = uint256(100_000_000) * (2 ** 112); // in 2**112\n\n\t\t// fair token0 amt: sqrtK * sqrt(px1/px0)\n\t\t// fair token1 amt: sqrtK * sqrt(px0/px1)\n\t\t// fair lp price = 2 * sqrt(px0 * px1)\n\t\t// split into 2 sqrts multiplication to prevent uint256 overflow (note the 2**112)\n\t\tuint256 result = (((sqrtK * 2 * (HomoraMath.sqrt(px0))) / (2 ** 56)) * (HomoraMath.sqrt(px1))) / (2 ** 56);\n\t\tpriceInEth = result / (2 ** 112);\n\t}\n\n\t/**\n\t * @notice Zap WETH and RDNt into LP\n\t * @param _wethAmt amount of WETH\n\t * @param _prntAmt amount of PRNT\n\t * @return liquidity LP token amount\n\t */\n\tfunction zapTokens(uint256 _wethAmt, uint256 _prntAmt) public returns (uint256 liquidity) {\n\t\tif (msg.sender != lockZap) revert InsufficientPermission();\n\t\tIWETH weth = IWETH(wethAddr);\n\t\tweth.transferFrom(msg.sender, address(this), _wethAmt);\n\t\tIERC20(prntAddr).safeTransferFrom(msg.sender, address(this), _prntAmt);\n\t\tliquidityZap.standardAdd(_prntAmt, _wethAmt, address(this));\n\t\tIERC20 lp = IERC20(lpTokenAddr);\n\t\tliquidity = lp.balanceOf(address(this));\n\t\tlp.safeTransfer(msg.sender, liquidity);\n\t\t_refundDust(prntAddr, wethAddr, msg.sender);\n\t}\n\n\t/**\n\t * @notice Returns `quote` of PRNT in WETH\n\t * @param tokenAmount amount of PRNT\n\t * @return optimalWETHAmount WETH amount\n\t */\n\tfunction quoteFromToken(uint256 tokenAmount) public view returns (uint256 optimalWETHAmount) {\n\t\toptimalWETHAmount = liquidityZap.quoteFromToken(tokenAmount);\n\t}\n\n\t/**\n\t * @notice Returns LiquidityZap address\n\t */\n\tfunction getLiquidityZap() public view returns (address) {\n\t\treturn address(liquidityZap);\n\t}\n\n\t/**\n\t * @notice Sets new LiquidityZap address\n\t * @param _liquidityZap LiquidityZap address\n\t */\n\tfunction setLiquidityZap(address _liquidityZap) external onlyOwner {\n\t\tif (_liquidityZap == address(0)) revert AddressZero();\n\t\tliquidityZap = ILiquidityZap(_liquidityZap);\n\t\temit LiquidityZapUpdated(_liquidityZap);\n\t}\n\n\t/**\n\t * @notice Sets new LockZap address\n\t * @param _lockZap LockZap address\n\t */\n\tfunction setLockZap(address _lockZap) external onlyOwner {\n\t\tif (_lockZap == address(0)) revert AddressZero();\n\t\tlockZap = _lockZap;\n\t\temit LockZapUpdated(_lockZap);\n\t}\n\n\t/**\n\t * @notice Returns PRNT price in ETH\n\t * @return priceInEth price of PRNT\n\t */\n\tfunction getPrice() public view returns (uint256 priceInEth) {\n\t\t(uint256 prnt, uint256 weth, ) = getReserves();\n\t\tif (prnt > 0) {\n\t\t\tpriceInEth = (weth * (10 ** 8)) / prnt;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Calculate quote in WETH from token\n\t * @param _inToken input token\n\t * @param _wethAmount WETH amount\n\t * @return tokenAmount token amount\n\t */\n\tfunction quoteSwap(address _inToken, uint256 _wethAmount) public view returns (uint256 tokenAmount) {\n\t\taddress[] memory path = new address[](2);\n\t\tpath[0] = _inToken;\n\t\tpath[1] = wethAddr;\n\t\tuint256[] memory amountsIn = router.getAmountsIn(_wethAmount, path);\n\t\treturn amountsIn[0];\n\t}\n\n\t/**\n\t * @dev Helper function to swap a token to weth given an {_inToken} and swap {_amount}.\n\t * Will revert if the output is under the {_minAmountOut}\n\t * @param _inToken Input token for swap\n\t * @param _amount Amount of input tokens\n\t * @param _minAmountOut Minimum output amount\n\t */\n\tfunction swapToWeth(address _inToken, uint256 _amount, uint256 _minAmountOut) external {\n\t\tif (msg.sender != lockZap) revert InsufficientPermission();\n\t\taddress[] memory path = new address[](2);\n\t\tpath[0] = _inToken;\n\t\tpath[1] = wethAddr;\n\t\tIERC20(_inToken).forceApprove(address(router), _amount);\n\t\trouter.swapExactTokensForTokens(_amount, _minAmountOut, path, msg.sender, block.timestamp);\n\t}\n}\n"
    },
    "contracts/prime/zap/LockZap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {DustRefunder} from \"./helpers/DustRefunder.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {IMultiFeeDistribution} from \"../../interfaces/IMultiFeeDistribution.sol\";\nimport {ILendingPool, DataTypes} from \"../../interfaces/ILendingPool.sol\";\nimport {IPoolHelper} from \"../../interfaces/IPoolHelper.sol\";\nimport {IPriceProvider} from \"../../interfaces/IPriceProvider.sol\";\nimport {IAaveOracle} from \"../../interfaces/IAaveOracle.sol\";\nimport {IChainlinkAggregator} from \"../../interfaces/IChainlinkAggregator.sol\";\nimport {IWETH} from \"../../interfaces/IWETH.sol\";\nimport {IPriceOracle} from \"../../interfaces/IPriceOracle.sol\";\nimport {TransferHelper} from \"../libraries/TransferHelper.sol\";\nimport {UniV2Helper} from \"../libraries/UniV2Helper.sol\";\n\n/// @title LockZap contract\n/// @author Prime\ncontract LockZap is Initializable, OwnableUpgradeable, PausableUpgradeable, DustRefunder {\n\tusing SafeERC20 for IERC20;\n\n\t/// @notice The maximum amount of slippage that a user can set for the execution of Zaps\n\t/// @dev If the slippage limit of the LockZap contract is lower then that of the Compounder, transactions might fail unexpectedly.\n\t///      Therefore ensure that this slippage limit is equal to that of the Compounder contract.\n\tuint256 public constant MAX_SLIPPAGE = 8500; //15%\n\n\t/// @notice RATIO Divisor\n\tuint256 public constant RATIO_DIVISOR = 10000;\n\n\t/// @notice Base Percent\n\tuint256 public constant BASE_PERCENT = 100;\n\n\t/// @notice Borrow rate mode\n\tuint256 public constant VARIABLE_INTEREST_RATE_MODE = 2;\n\n\t/// @notice We don't utilize any specific referral code for borrows perfomed via zaps\n\tuint16 public constant REFERRAL_CODE = 0;\n\n\t/// @notice Wrapped ETH\n\tIWETH public weth;\n\n\t/// @notice PRNT token address\n\taddress public prntAddr;\n\n\t/// @notice Multi Fee distribution contract\n\tIMultiFeeDistribution public mfd;\n\n\t/// @notice Lending Pool contract\n\tILendingPool public lendingPool;\n\n\t/// @notice Pool helper contract used for PRNT-WETH swaps\n\tIPoolHelper public poolHelper;\n\n\t/// @notice Price provider contract\n\tIPriceProvider public priceProvider;\n\n\t/// @notice aave oracle contract\n\tIAaveOracle public aaveOracle;\n\n\t/// @notice parameter to set the ratio of ETH in the LP token, can be 2000 for an 80/20 bal lp\n\tuint256 public ethLPRatio;\n\n\t/// @notice AMM router used for all non PRNT-WETH swaps on Arbitrum\n\taddress public uniRouter;\n\n\t/********************** Events ***********************/\n\t/// @notice Emitted when zap is done\n\tevent Zapped(\n\t\tbool _borrow,\n\t\tuint256 _ethAmt,\n\t\tuint256 _prntAmt,\n\t\taddress indexed _from,\n\t\taddress indexed _onBehalf,\n\t\tuint256 _lockTypeIndex\n\t);\n\n\tevent PriceProviderUpdated(address indexed _provider);\n\n\tevent MfdUpdated(address indexed _mfdAddr);\n\n\tevent PoolHelperUpdated(address indexed _poolHelper);\n\n\tevent UniRouterUpdated(address indexed _uniRouter);\n\n\t/********************** Errors ***********************/\n\terror AddressZero();\n\n\terror InvalidRatio();\n\n\terror InvalidLockLength();\n\n\terror AmountZero();\n\n\terror SlippageTooHigh();\n\n\terror SpecifiedSlippageExceedLimit();\n\n\terror InvalidZapETHSource();\n\n\terror ReceivedETHOnAlternativeAssetZap();\n\n\terror InsufficientETH();\n\n\terror EthTransferFailed();\n\n\tconstructor() {\n\t\t_disableInitializers();\n\t}\n\n\t/**\n\t * @notice Initializer\n\t * @param _rndtPoolHelper Pool helper address used for PRNT-WETH swaps\n\t * @param _uniRouter UniV2 router address used for all non PRNT-WETH swaps\n\t * @param _lendingPool Lending pool\n\t * @param _weth weth address\n\t * @param _prntAddr PRNT token address\n\t * @param _ethLPRatio ratio of ETH in the LP token, can be 2000 for an 80/20 bal lp\n\t * @param _aaveOracle Aave oracle address\n\t */\n\tfunction initialize(\n\t\tIPoolHelper _rndtPoolHelper,\n\t\taddress _uniRouter,\n\t\tILendingPool _lendingPool,\n\t\tIWETH _weth,\n\t\taddress _prntAddr,\n\t\tuint256 _ethLPRatio,\n\t\tIAaveOracle _aaveOracle\n\t) external initializer {\n\t\tif (address(_rndtPoolHelper) == address(0)) revert AddressZero();\n\t\tif (address(_uniRouter) == address(0)) revert AddressZero();\n\t\tif (address(_lendingPool) == address(0)) revert AddressZero();\n\t\tif (address(_weth) == address(0)) revert AddressZero();\n\t\tif (_prntAddr == address(0)) revert AddressZero();\n\t\tif (_ethLPRatio == 0 || _ethLPRatio >= RATIO_DIVISOR) revert InvalidRatio();\n\t\tif (address(_aaveOracle) == address(0)) revert AddressZero();\n\n\t\t__Ownable_init();\n\t\t__Pausable_init();\n\n\t\tlendingPool = _lendingPool;\n\t\tpoolHelper = _rndtPoolHelper;\n\t\tuniRouter = _uniRouter;\n\t\tweth = _weth;\n\t\tprntAddr = _prntAddr;\n\t\tethLPRatio = _ethLPRatio;\n\t\taaveOracle = _aaveOracle;\n\t}\n\n\treceive() external payable {}\n\n\t/**\n\t * @notice Set Price Provider.\n\t * @param _provider Price provider contract address.\n\t */\n\tfunction setPriceProvider(address _provider) external onlyOwner {\n\t\tif (_provider == address(0)) revert AddressZero();\n\t\tpriceProvider = IPriceProvider(_provider);\n\t\temit PriceProviderUpdated(_provider);\n\t}\n\n\t/**\n\t * @notice Set AAVE Oracle used to fetch asset prices in USD.\n\t * @param _aaveOracle oracle contract address.\n\t */\n\tfunction setAaveOracle(address _aaveOracle) external onlyOwner {\n\t\tif (_aaveOracle == address(0)) revert AddressZero();\n\t\taaveOracle = IAaveOracle(_aaveOracle);\n\t}\n\n\t/**\n\t * @notice Set Multi fee distribution contract.\n\t * @param _mfdAddr New contract address.\n\t */\n\tfunction setMfd(address _mfdAddr) external onlyOwner {\n\t\tif (_mfdAddr == address(0)) revert AddressZero();\n\t\tmfd = IMultiFeeDistribution(_mfdAddr);\n\t\temit MfdUpdated(_mfdAddr);\n\t}\n\n\t/**\n\t * @notice Set Pool Helper contract used fror WETH-PRNT swaps\n\t * @param _poolHelper New PoolHelper contract address.\n\t */\n\tfunction setPoolHelper(address _poolHelper) external onlyOwner {\n\t\tif (_poolHelper == address(0)) revert AddressZero();\n\t\tpoolHelper = IPoolHelper(_poolHelper);\n\t\temit PoolHelperUpdated(_poolHelper);\n\t}\n\n\t/**\n\t * @notice Set Univ2 style router contract address used for all non PRNT<>WETH swaps\n\t * @param _uniRouter New PoolHelper contract address.\n\t */\n\tfunction setUniRouter(address _uniRouter) external onlyOwner {\n\t\tif (_uniRouter == address(0)) revert AddressZero();\n\t\tuniRouter = _uniRouter;\n\t\temit UniRouterUpdated(_uniRouter);\n\t}\n\n\t/**\n\t * @notice Returns pool helper address used for PRNT-WETH swaps\n\t */\n\tfunction getPoolHelper() external view returns (address) {\n\t\treturn address(poolHelper);\n\t}\n\n\t/**\n\t * @notice Returns uni router address used for all non PRNT-WETH swaps\n\t */\n\tfunction getUniRouter() external view returns (address) {\n\t\treturn address(uniRouter);\n\t}\n\n\t/**\n\t * @notice Get Variable debt token address\n\t * @param _asset underlying.\n\t */\n\tfunction getVDebtToken(address _asset) external view returns (address) {\n\t\tDataTypes.ReserveData memory reserveData = lendingPool.getReserveData(_asset);\n\t\treturn reserveData.variableDebtTokenAddress;\n\t}\n\n\t/**\n\t * @notice Calculate amount of specified tokens received for selling PRNT\n\t * @dev this function is mainly used to calculate how much of the specified token is needed to match the provided PRNT amount when providing liquidity to an AMM\n\t * @param _token address of the token that would be received\n\t * @param _amount of PRNT to be sold\n\t * @return amount of _token received\n\t */\n\tfunction quoteFromToken(address _token, uint256 _amount) public view returns (uint256) {\n\t\taddress weth_ = address(weth);\n\t\tif (_token != weth_) {\n\t\t\tuint256 wethAmount = poolHelper.quoteFromToken(_amount);\n\t\t\treturn UniV2Helper._quoteSwap(uniRouter, weth_, _token, wethAmount);\n\t\t}\n\t\treturn poolHelper.quoteFromToken(_amount);\n\t}\n\n\t/**\n\t * @notice Zap tokens to stake LP\n\t * @param _borrow option to borrow ETH\n\t * @param _asset to be used for zapping\n\t * @param _assetAmt amount of weth.\n\t * @param _prntAmt amount of PRNT.\n\t * @param _lockTypeIndex lock length index.\n\t * @param _slippage maximum amount of slippage allowed for any occurring trades\n\t * @return LP amount\n\t */\n\tfunction zap(\n\t\tbool _borrow,\n\t\taddress _asset,\n\t\tuint256 _assetAmt,\n\t\tuint256 _prntAmt,\n\t\tuint256 _lockTypeIndex,\n\t\tuint256 _slippage\n\t) public payable whenNotPaused returns (uint256) {\n\t\treturn\n\t\t\t_zap(_borrow, _asset, _assetAmt, _prntAmt, msg.sender, msg.sender, _lockTypeIndex, msg.sender, _slippage);\n\t}\n\n\t/**\n\t * @notice Zap tokens to stake LP\n\t * @dev It will use default lock index\n\t * @param _borrow option to borrow ETH\n\t * @param _asset to be used for zapping\n\t * @param _assetAmt amount of weth.\n\t * @param _prntAmt amount of PRNT.\n\t * @param _onBehalf user address to be zapped.\n\t * @param _slippage maximum amount of slippage allowed for any occurring trades\n\t * @return LP amount\n\t */\n\tfunction zapOnBehalf(\n\t\tbool _borrow,\n\t\taddress _asset,\n\t\tuint256 _assetAmt,\n\t\tuint256 _prntAmt,\n\t\taddress _onBehalf,\n\t\tuint256 _slippage\n\t) public payable whenNotPaused returns (uint256) {\n\t\tuint256 duration = mfd.defaultLockIndex(_onBehalf);\n\t\treturn _zap(_borrow, _asset, _assetAmt, _prntAmt, msg.sender, _onBehalf, duration, _onBehalf, _slippage);\n\t}\n\n\t/**\n\t * @notice Zap tokens from vesting\n\t * @param _borrow option to borrow ETH\n\t * @param _asset to be used for zapping\n\t * @param _assetAmt amount of _asset tokens used to create dLP position\n\t * @param _lockTypeIndex lock length index. cannot be shortest option (index 0)\n\t * @param _slippage maximum amount of slippage allowed for any occurring trades\n\t * @return LP amount\n\t */\n\tfunction zapFromVesting(\n\t\tbool _borrow,\n\t\taddress _asset,\n\t\tuint256 _assetAmt,\n\t\tuint256 _lockTypeIndex,\n\t\tuint256 _slippage\n\t) public payable whenNotPaused returns (uint256) {\n\t\tif (_lockTypeIndex == 0) revert InvalidLockLength();\n\t\tuint256 prntAmt = mfd.zapVestingToLp(msg.sender);\n\n\t\treturn\n\t\t\t_zap(_borrow, _asset, _assetAmt, prntAmt, address(this), msg.sender, _lockTypeIndex, msg.sender, _slippage);\n\t}\n\n\t/**\n\t * @notice Calculates slippage ratio from usd value to LP\n\t * @param _assetValueUsd amount value in USD used to create LP pair\n\t * @param _liquidity LP token amount\n\t */\n\tfunction _calcSlippage(uint256 _assetValueUsd, uint256 _liquidity) internal returns (uint256 ratio) {\n\t\tpriceProvider.update();\n\t\tuint256 lpAmountValueUsd = (_liquidity * priceProvider.getLpTokenPriceUsd()) / 1e18;\n\t\tratio = (lpAmountValueUsd * (RATIO_DIVISOR)) / (_assetValueUsd);\n\t}\n\n\t/**\n\t * @notice Zap into LP\n\t * @param _borrow option to borrow ETH\n\t * @param _asset that will be used to zap.\n\t * @param _assetAmt amount of assets to be zapped\n\t * @param _prntAmt amount of PRNT.\n\t * @param _from src address of PRNT\n\t * @param _onBehalf of the user.\n\t * @param _lockTypeIndex lock length index.\n\t * @param _refundAddress dust is refunded to this address.\n\t * @param _slippage maximum amount of slippage allowed for any occurring trades\n\t * @return liquidity LP amount\n\t */\n\tfunction _zap(\n\t\tbool _borrow,\n\t\taddress _asset,\n\t\tuint256 _assetAmt,\n\t\tuint256 _prntAmt,\n\t\taddress _from,\n\t\taddress _onBehalf,\n\t\tuint256 _lockTypeIndex,\n\t\taddress _refundAddress,\n\t\tuint256 _slippage\n\t) internal returns (uint256 liquidity) {\n\t\tIWETH weth_ = weth;\n\t\tif (_asset == address(0)) {\n\t\t\t_asset = address(weth_);\n\t\t}\n\t\tif (_slippage == 0) {\n\t\t\t_slippage = MAX_SLIPPAGE;\n\t\t} else {\n\t\t\tif (MAX_SLIPPAGE > _slippage || _slippage > RATIO_DIVISOR) revert SpecifiedSlippageExceedLimit();\n\t\t}\n\t\tbool isAssetWeth = _asset == address(weth_);\n\n\t\t// Handle pure ETH\n\t\tif (msg.value > 0) {\n\t\t\tif (!isAssetWeth) revert ReceivedETHOnAlternativeAssetZap();\n\t\t\tif (_borrow) revert InvalidZapETHSource();\n\t\t\t_assetAmt = msg.value;\n\t\t\tweth_.deposit{value: _assetAmt}();\n\t\t}\n\t\tif (_assetAmt == 0) revert AmountZero();\n\t\tuint256 assetAmountValueUsd = (_assetAmt * aaveOracle.getAssetPrice(_asset)) /\n\t\t\t(10 ** IERC20Metadata(_asset).decimals());\n\n\t\t// Handle borrowing logic\n\t\tif (_borrow) {\n\t\t\t// Borrow the asset on the users behalf\n\t\t\tlendingPool.borrow(_asset, _assetAmt, VARIABLE_INTEREST_RATE_MODE, REFERRAL_CODE, msg.sender);\n\n\t\t\t// If asset isn't WETH, swap for WETH\n\t\t\tif (!isAssetWeth) {\n\t\t\t\t_assetAmt = UniV2Helper._swap(uniRouter, _asset, address(weth_), _assetAmt);\n\t\t\t}\n\t\t} else if (msg.value == 0) {\n\t\t\t// Transfer asset from user\n\t\t\tIERC20(_asset).transferFrom(msg.sender, address(this), _assetAmt);\n\t\t\tif (!isAssetWeth) {\n\t\t\t\t_assetAmt = UniV2Helper._swap(uniRouter, _asset, address(weth_), _assetAmt);\n\t\t\t}\n\t\t}\n\n\t\tweth_.approve(address(poolHelper), _assetAmt);\n\t\t//case where prnt is matched with provided ETH\n\t\tif (_prntAmt != 0) {\n\t\t\t// _from == this when zapping from vesting\n\t\t\tif (_from != address(this)) {\n\t\t\t\tIERC20(prntAddr).safeTransferFrom(msg.sender, address(this), _prntAmt);\n\t\t\t}\n\n\t\t\tIERC20(prntAddr).forceApprove(address(poolHelper), _prntAmt);\n\t\t\tliquidity = poolHelper.zapTokens(_assetAmt, _prntAmt);\n\t\t\tassetAmountValueUsd = (assetAmountValueUsd * RATIO_DIVISOR) / ethLPRatio;\n\t\t} else {\n\t\t\tliquidity = poolHelper.zapWETH(_assetAmt);\n\t\t}\n\n\t\tif (address(priceProvider) != address(0)) {\n\t\t\tif (_calcSlippage(assetAmountValueUsd, liquidity) < _slippage) revert SlippageTooHigh();\n\t\t}\n\n\t\tIERC20(poolHelper.lpTokenAddr()).forceApprove(address(mfd), liquidity);\n\t\tmfd.stake(liquidity, _onBehalf, _lockTypeIndex);\n\t\temit Zapped(_borrow, _assetAmt, _prntAmt, _from, _onBehalf, _lockTypeIndex);\n\n\t\t_refundDust(prntAddr, _asset, _refundAddress);\n\t}\n\n\t/**\n\t * @notice Pause zapping operation.\n\t */\n\tfunction pause() external onlyOwner {\n\t\t_pause();\n\t}\n\n\t/**\n\t * @notice Unpause zapping operation.\n\t */\n\tfunction unpause() external onlyOwner {\n\t\t_unpause();\n\t}\n\n\t/**\n\t * @notice Allows owner to recover ETH locked in this contract.\n\t * @param to ETH receiver\n\t * @param value ETH amount\n\t */\n\tfunction withdrawLockedETH(address to, uint256 value) external onlyOwner {\n\t\tTransferHelper.safeTransferETH(to, value);\n\t}\n}\n"
    },
    "contracts/test/MockNewMiddleFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"../prime/staking/MiddleFeeDistribution.sol\";\n\ncontract MockNewMiddleFeeDistribution is MiddleFeeDistribution {\n\tfunction mockNewFunction() external pure returns (bool) {\n\t\treturn true;\n\t}\n}\n"
    },
    "contracts/test/TestLockZap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"../prime/zap/LockZap.sol\";\nimport \"../interfaces/IPoolHelper.sol\";\n\ncontract TestnetLockZap is LockZap {\n\tfunction sell(uint256 _amount) public returns (uint256 ethOut) {\n\t\tIERC20(prntAddr).transferFrom(msg.sender, address(poolHelper), _amount);\n\t\treturn ITestPoolHelper(address(poolHelper)).sell(_amount);\n\t}\n}\n"
    },
    "contracts/test/TestUniswapPoolHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../prime/zap/helpers/UniswapPoolHelper.sol\";\n\ncontract TestUniswapPoolHelper is UniswapPoolHelper {\n\tusing SafeERC20 for IERC20;\n\n\tfunction swap(uint256 _amount, address, address, address) public returns (uint256 amountOut) {\n\t\tIUniswapV2Pair lpToken = IUniswapV2Pair(lpTokenAddr);\n\t\t(uint256 reserve0, uint256 reserve1, ) = lpToken.getReserves();\n\n\t\t(address token0, address token1) = UniswapV2Library.sortTokens(address(wethAddr), prntAddr);\n\n\t\tuint256 reserveWeth = token0 == address(wethAddr) ? reserve0 : reserve1;\n\t\tuint256 reserveTokens = token0 == address(wethAddr) ? reserve1 : reserve0;\n\n\t\tuint256 outETH = UniswapV2Library.getAmountOut(_amount, reserveTokens, reserveWeth);\n\n\t\tIERC20(prntAddr).safeTransfer(lpTokenAddr, _amount);\n\n\t\tIUniswapV2Pair(lpTokenAddr).swap(\n\t\t\taddress(wethAddr) == token0 ? outETH : 0,\n\t\t\taddress(wethAddr) == token1 ? outETH : 0,\n\t\t\taddress(this),\n\t\t\t\"\"\n\t\t);\n\n\t\tamountOut = IERC20(address(wethAddr)).balanceOf(address(this));\n\t}\n\n\tfunction sell(uint256 _amount) public returns (uint256 amountOut) {\n\t\treturn\n\t\t\tswap(\n\t\t\t\t_amount,\n\t\t\t\t0x0000000000000000000000000000000000000000,\n\t\t\t\t0x0000000000000000000000000000000000000000,\n\t\t\t\t0x0000000000000000000000000000000000000000\n\t\t\t);\n\t}\n}\n"
    },
    "contracts/test/uniswap/core/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n\tfunction feeTo() external view returns (address);\n\n\tfunction feeToSetter() external view returns (address);\n\n\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\n\n\tfunction allPairs(uint) external view returns (address pair);\n\n\tfunction allPairsLength() external view returns (uint);\n\n\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\n\n\tfunction setFeeTo(address) external;\n\n\tfunction setFeeToSetter(address) external;\n\n\tfunction getInitHash() external view returns (bytes32);\n}\n"
    },
    "contracts/test/uniswap/periphery/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.12;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n\t// credit for this implementation goes to\n\t// https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n\tfunction sqrt(uint256 x) internal pure returns (uint256) {\n\t\tif (x == 0) return 0;\n\t\t// this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n\t\t// however that code costs significantly more gas\n\t\tuint256 xx = x;\n\t\tuint256 r = 1;\n\t\tif (xx >= 0x100000000000000000000000000000000) {\n\t\t\txx >>= 128;\n\t\t\tr <<= 64;\n\t\t}\n\t\tif (xx >= 0x10000000000000000) {\n\t\t\txx >>= 64;\n\t\t\tr <<= 32;\n\t\t}\n\t\tif (xx >= 0x100000000) {\n\t\t\txx >>= 32;\n\t\t\tr <<= 16;\n\t\t}\n\t\tif (xx >= 0x10000) {\n\t\t\txx >>= 16;\n\t\t\tr <<= 8;\n\t\t}\n\t\tif (xx >= 0x100) {\n\t\t\txx >>= 8;\n\t\t\tr <<= 4;\n\t\t}\n\t\tif (xx >= 0x10) {\n\t\t\txx >>= 4;\n\t\t\tr <<= 2;\n\t\t}\n\t\tif (xx >= 0x8) {\n\t\t\tr <<= 1;\n\t\t}\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1; // Seven iterations should be enough\n\t\tuint256 r1 = x / r;\n\t\treturn (r < r1 ? r : r1);\n\t}\n}\n"
    },
    "contracts/test/uniswap/periphery/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n\t/// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n\t/// @param a The multiplicand\n\t/// @param b The multiplier\n\t/// @param denominator The divisor\n\t/// @return result The 256-bit result\n\t/// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n\tfunction mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n\t\tunchecked {\n\t\t\t// 512-bit multiply [prod1 prod0] = a * b\n\t\t\t// Compute the product mod 2**256 and mod 2**256 - 1\n\t\t\t// then use the Chinese Remainder Theorem to reconstruct\n\t\t\t// the 512 bit result. The result is stored in two 256\n\t\t\t// variables such that product = prod1 * 2**256 + prod0\n\t\t\tuint256 prod0; // Least significant 256 bits of the product\n\t\t\tuint256 prod1; // Most significant 256 bits of the product\n\t\t\tassembly {\n\t\t\t\tlet mm := mulmod(a, b, not(0))\n\t\t\t\tprod0 := mul(a, b)\n\t\t\t\tprod1 := sub(sub(mm, prod0), lt(mm, prod0))\n\t\t\t}\n\n\t\t\t// Handle non-overflow cases, 256 by 256 division\n\t\t\tif (prod1 == 0) {\n\t\t\t\trequire(denominator > 0);\n\t\t\t\tassembly {\n\t\t\t\t\tresult := div(prod0, denominator)\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// Make sure the result is less than 2**256.\n\t\t\t// Also prevents denominator == 0\n\t\t\trequire(denominator > prod1);\n\n\t\t\t///////////////////////////////////////////////\n\t\t\t// 512 by 256 division.\n\t\t\t///////////////////////////////////////////////\n\n\t\t\t// Make division exact by subtracting the remainder from [prod1 prod0]\n\t\t\t// Compute remainder using mulmod\n\t\t\tuint256 remainder;\n\t\t\tassembly {\n\t\t\t\tremainder := mulmod(a, b, denominator)\n\t\t\t}\n\t\t\t// Subtract 256 bit number from 512 bit number\n\t\t\tassembly {\n\t\t\t\tprod1 := sub(prod1, gt(remainder, prod0))\n\t\t\t\tprod0 := sub(prod0, remainder)\n\t\t\t}\n\n\t\t\t// Factor powers of two out of denominator\n\t\t\t// Compute largest power of two divisor of denominator.\n\t\t\t// Always >= 1.\n\t\t\tuint256 twos = (0 - denominator) & denominator;\n\t\t\t// Divide denominator by power of two\n\t\t\tassembly {\n\t\t\t\tdenominator := div(denominator, twos)\n\t\t\t}\n\n\t\t\t// Divide [prod1 prod0] by the factors of two\n\t\t\tassembly {\n\t\t\t\tprod0 := div(prod0, twos)\n\t\t\t}\n\t\t\t// Shift in bits from prod1 into prod0. For this we need\n\t\t\t// to flip `twos` such that it is 2**256 / twos.\n\t\t\t// If twos is zero, then it becomes one\n\t\t\tassembly {\n\t\t\t\ttwos := add(div(sub(0, twos), twos), 1)\n\t\t\t}\n\t\t\tprod0 |= prod1 * twos;\n\n\t\t\t// Invert denominator mod 2**256\n\t\t\t// Now that denominator is an odd number, it has an inverse\n\t\t\t// modulo 2**256 such that denominator * inv = 1 mod 2**256.\n\t\t\t// Compute the inverse by starting with a seed that is correct\n\t\t\t// correct for four bits. That is, denominator * inv = 1 mod 2**4\n\t\t\tuint256 inv = (3 * denominator) ^ 2;\n\t\t\t// Now use Newton-Raphson iteration to improve the precision.\n\t\t\t// Thanks to Hensel's lifting lemma, this also works in modular\n\t\t\t// arithmetic, doubling the correct bits in each step.\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**8\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**16\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**32\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**64\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**128\n\t\t\tinv *= 2 - denominator * inv; // inverse mod 2**256\n\n\t\t\t// Because the division is now exact we can divide by multiplying\n\t\t\t// with the modular inverse of denominator. This will give us the\n\t\t\t// correct result modulo 2**256. Since the precoditions guarantee\n\t\t\t// that the outcome is less than 2**256, this is the final result.\n\t\t\t// We don't need to compute the high bits of the result and prod1\n\t\t\t// is no longer required.\n\t\t\tresult = prod0 * inv;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n\t/// @param a The multiplicand\n\t/// @param b The multiplier\n\t/// @param denominator The divisor\n\t/// @return result The 256-bit result\n\tfunction mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n\t\tunchecked {\n\t\t\tresult = mulDiv(a, b, denominator);\n\t\t\tif (mulmod(a, b, denominator) > 0) {\n\t\t\t\trequire(result < type(uint256).max);\n\t\t\t\tresult++;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "contracts/test/uniswap/periphery/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.12;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n\tfunction add(uint x, uint y) internal pure returns (uint z) {\n\t\trequire((z = x + y) >= x, \"ds-math-add-overflow\");\n\t}\n\n\tfunction sub(uint x, uint y) internal pure returns (uint z) {\n\t\trequire((z = x - y) <= x, \"ds-math-sub-underflow\");\n\t}\n\n\tfunction mul(uint x, uint y) internal pure returns (uint z) {\n\t\trequire(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n\t}\n}\n"
    },
    "contracts/test/uniswap/periphery/libraries/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.12;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n// import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport \"../../core/interfaces/IUniswapV2Factory.sol\";\nimport \"./SafeMath.sol\";\n\nlibrary UniswapV2Library {\n\tusing SafeMath for uint;\n\n\t// returns sorted token addresses, used to handle return values from pairs sorted in this order\n\tfunction sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n\t\trequire(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n\t\t(token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n\t\trequire(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n\t}\n\n\t// calculates the CREATE2 address for a pair without making any external calls\n\tfunction pairFor(address factory, address tokenA, address tokenB) internal view returns (address pair) {\n\t\t(address token0, address token1) = sortTokens(tokenA, tokenB);\n\t\tpair = address(\n\t\t\tuint160(\n\t\t\t\tuint(\n\t\t\t\t\tkeccak256(\n\t\t\t\t\t\tabi.encodePacked(\n\t\t\t\t\t\t\thex\"ff\",\n\t\t\t\t\t\t\tfactory,\n\t\t\t\t\t\t\tkeccak256(abi.encodePacked(token0, token1)),\n\t\t\t\t\t\t\tIUniswapV2Factory(factory).getInitHash()\n\t\t\t\t\t\t\t// hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n\t// fetches and sorts the reserves for a pair\n\tfunction getReserves(\n\t\taddress factory,\n\t\taddress tokenA,\n\t\taddress tokenB\n\t) internal view returns (uint reserveA, uint reserveB) {\n\t\t(address token0, ) = sortTokens(tokenA, tokenB);\n\t\t(uint reserve0, uint reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n\n\t\t(reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n\t}\n\n\t// given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n\tfunction quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n\t\trequire(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n\t\trequire(reserveA > 0 && reserveB > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n\t\tamountB = amountA.mul(reserveB) / reserveA;\n\t}\n\n\t// given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n\t\trequire(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n\t\trequire(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n\t\tuint amountInWithFee = amountIn.mul(997);\n\t\tuint numerator = amountInWithFee.mul(reserveOut);\n\t\tuint denominator = reserveIn.mul(1000).add(amountInWithFee);\n\t\tamountOut = numerator / denominator;\n\t}\n\n\t// given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n\t\trequire(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n\t\trequire(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n\t\tuint numerator = reserveIn.mul(amountOut).mul(1000);\n\t\tuint denominator = reserveOut.sub(amountOut).mul(997);\n\t\tamountIn = (numerator / denominator).add(1);\n\t}\n\n\t// performs chained getAmountOut calculations on any number of pairs\n\tfunction getAmountsOut(\n\t\taddress factory,\n\t\tuint amountIn,\n\t\taddress[] memory path\n\t) internal view returns (uint[] memory amounts) {\n\t\trequire(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n\t\tamounts = new uint[](path.length);\n\t\tamounts[0] = amountIn;\n\t\tfor (uint i; i < path.length - 1; i++) {\n\t\t\t(uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n\t\t\tamounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n\t\t}\n\t}\n\n\t// performs chained getAmountIn calculations on any number of pairs\n\tfunction getAmountsIn(\n\t\taddress factory,\n\t\tuint amountOut,\n\t\taddress[] memory path\n\t) internal view returns (uint[] memory amounts) {\n\t\trequire(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n\t\tamounts = new uint[](path.length);\n\t\tamounts[amounts.length - 1] = amountOut;\n\t\tfor (uint i = path.length - 1; i > 0; i--) {\n\t\t\t(uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n\t\t\tamounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n\t\t}\n\t}\n}\n"
    },
    "contracts/test/uniswap/periphery/libraries/UniswapV2LiquidityMathLibrary.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.12;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n// import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport \"./Babylonian.sol\";\nimport \"./FullMath.sol\";\n\nimport \"./SafeMath.sol\";\nimport \"./UniswapV2Library.sol\";\n\n// library containing some math for dealing with the liquidity shares of a pair, e.g. computing their exact value\n// in terms of the underlying tokens\nlibrary UniswapV2LiquidityMathLibrary {\n\tusing SafeMath for uint256;\n\n\t// computes the direction and magnitude of the profit-maximizing trade\n\tfunction computeProfitMaximizingTrade(\n\t\tuint256 truePriceTokenA,\n\t\tuint256 truePriceTokenB,\n\t\tuint256 reserveA,\n\t\tuint256 reserveB\n\t) internal pure returns (bool aToB, uint256 amountIn) {\n\t\taToB = FullMath.mulDiv(reserveA, truePriceTokenB, reserveB) < truePriceTokenA;\n\n\t\tuint256 invariant = reserveA.mul(reserveB);\n\n\t\tuint256 leftSide = Babylonian.sqrt(\n\t\t\tFullMath.mulDiv(\n\t\t\t\tinvariant.mul(1000),\n\t\t\t\taToB ? truePriceTokenA : truePriceTokenB,\n\t\t\t\t(aToB ? truePriceTokenB : truePriceTokenA).mul(997)\n\t\t\t)\n\t\t);\n\t\tuint256 rightSide = (aToB ? reserveA.mul(1000) : reserveB.mul(1000)) / 997;\n\n\t\tif (leftSide < rightSide) return (false, 0);\n\n\t\t// compute the amount that must be sent to move the price to the profit-maximizing price\n\t\tamountIn = leftSide.sub(rightSide);\n\t}\n\n\t// gets the reserves after an arbitrage moves the price to the profit-maximizing ratio given an externally observed true price\n\tfunction getReservesAfterArbitrage(\n\t\taddress factory,\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 truePriceTokenA,\n\t\tuint256 truePriceTokenB\n\t) internal view returns (uint256 reserveA, uint256 reserveB) {\n\t\t// first get reserves before the swap\n\t\t(reserveA, reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n\n\t\trequire(reserveA > 0 && reserveB > 0, \"UniswapV2ArbitrageLibrary: ZERO_PAIR_RESERVES\");\n\n\t\t// then compute how much to swap to arb to the true price\n\t\t(bool aToB, uint256 amountIn) = computeProfitMaximizingTrade(\n\t\t\ttruePriceTokenA,\n\t\t\ttruePriceTokenB,\n\t\t\treserveA,\n\t\t\treserveB\n\t\t);\n\n\t\tif (amountIn == 0) {\n\t\t\treturn (reserveA, reserveB);\n\t\t}\n\n\t\t// now affect the trade to the reserves\n\t\tif (aToB) {\n\t\t\tuint amountOut = UniswapV2Library.getAmountOut(amountIn, reserveA, reserveB);\n\t\t\treserveA += amountIn;\n\t\t\treserveB -= amountOut;\n\t\t} else {\n\t\t\tuint amountOut = UniswapV2Library.getAmountOut(amountIn, reserveB, reserveA);\n\t\t\treserveB += amountIn;\n\t\t\treserveA -= amountOut;\n\t\t}\n\t}\n\n\t// computes liquidity value given all the parameters of the pair\n\tfunction computeLiquidityValue(\n\t\tuint256 reservesA,\n\t\tuint256 reservesB,\n\t\tuint256 totalSupply,\n\t\tuint256 liquidityAmount,\n\t\tbool feeOn,\n\t\tuint kLast\n\t) internal pure returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n\t\tif (feeOn && kLast > 0) {\n\t\t\tuint rootK = Babylonian.sqrt(reservesA.mul(reservesB));\n\t\t\tuint rootKLast = Babylonian.sqrt(kLast);\n\t\t\tif (rootK > rootKLast) {\n\t\t\t\tuint numerator1 = totalSupply;\n\t\t\t\tuint numerator2 = rootK.sub(rootKLast);\n\t\t\t\tuint denominator = rootK.mul(5).add(rootKLast);\n\t\t\t\tuint feeLiquidity = FullMath.mulDiv(numerator1, numerator2, denominator);\n\t\t\t\ttotalSupply = totalSupply.add(feeLiquidity);\n\t\t\t}\n\t\t}\n\t\treturn (reservesA.mul(liquidityAmount) / totalSupply, reservesB.mul(liquidityAmount) / totalSupply);\n\t}\n\n\t// get all current parameters from the pair and compute value of a liquidity amount\n\t// **note this is subject to manipulation, e.g. sandwich attacks**. prefer passing a manipulation resistant price to\n\t// #getLiquidityValueAfterArbitrageToPrice\n\tfunction getLiquidityValue(\n\t\taddress factory,\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 liquidityAmount\n\t) internal view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n\t\t(uint256 reservesA, uint256 reservesB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n\t\tIUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, tokenA, tokenB));\n\t\tbool feeOn = IUniswapV2Factory(factory).feeTo() != address(0);\n\t\tuint kLast = feeOn ? pair.kLast() : 0;\n\t\tuint totalSupply = pair.totalSupply();\n\t\treturn computeLiquidityValue(reservesA, reservesB, totalSupply, liquidityAmount, feeOn, kLast);\n\t}\n\n\t// given two tokens, tokenA and tokenB, and their \"true price\", i.e. the observed ratio of value of token A to token B,\n\t// and a liquidity amount, returns the value of the liquidity in terms of tokenA and tokenB\n\tfunction getLiquidityValueAfterArbitrageToPrice(\n\t\taddress factory,\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 truePriceTokenA,\n\t\tuint256 truePriceTokenB,\n\t\tuint256 liquidityAmount\n\t) internal view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n\t\tbool feeOn = IUniswapV2Factory(factory).feeTo() != address(0);\n\t\tIUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, tokenA, tokenB));\n\t\tuint kLast = feeOn ? pair.kLast() : 0;\n\t\tuint totalSupply = pair.totalSupply();\n\n\t\t// this also checks that totalSupply > 0\n\t\trequire(totalSupply >= liquidityAmount && liquidityAmount > 0, \"ComputeLiquidityValue: LIQUIDITY_AMOUNT\");\n\n\t\t(uint reservesA, uint reservesB) = getReservesAfterArbitrage(\n\t\t\tfactory,\n\t\t\ttokenA,\n\t\t\ttokenB,\n\t\t\ttruePriceTokenA,\n\t\t\ttruePriceTokenB\n\t\t);\n\n\t\treturn computeLiquidityValue(reservesA, reservesB, totalSupply, liquidityAmount, feeOn, kLast);\n\t}\n}\n"
    },
    "contracts/uniswap-solc-0.8/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n//solhint-disable-next-line compiler-version\npragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n"
    },
    "contracts/uniswap-solc-0.8/interfaces/IUniswapV2Callee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n//solhint-disable-next-line compiler-version\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/uniswap-solc-0.8/interfaces/IUniswapV2ERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n//solhint-disable-next-line compiler-version\npragma solidity >=0.5.0;\n\n//solhint-disable func-name-mixedcase\ninterface IUniswapV2ERC20 {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/uniswap-solc-0.8/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n//solhint-disable-next-line compiler-version\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/uniswap-solc-0.8/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n//solhint-disable-next-line compiler-version\npragma solidity >=0.5.0;\n\n//solhint-disable func-name-mixedcase\n\nimport \"./IUniswapV2ERC20.sol\";\n\ninterface IUniswapV2Pair is IUniswapV2ERC20 {\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(\n        address to\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/uniswap-solc-0.8/interfaces/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.12;\n\nimport \"./IUniswapV2Router01.sol\";\n\ninterface IUniswapV2Router is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "contracts/uniswap-solc-0.8/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.12;\n\n//solhint-disable func-name-mixedcase\n\ninterface IUniswapV2Router01 {\n    function factory() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(\n        uint256 amountIn,\n        address[] calldata path\n    ) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(\n        uint256 amountOut,\n        address[] calldata path\n    ) external view returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/uniswap-solc-0.8/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.12;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/uniswap-solc-0.8/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.12;\n\n// a library for performing various math operations\n\nlibrary Math {\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x < y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/uniswap-solc-0.8/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.12;\n\n//solhint-disable avoid-low-level-calls\n//solhint-disable reason-string\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper::safeApprove: approve failed\"\n        );\n    }\n\n    function safeTransfer(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper::safeTransfer: transfer failed\"\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper::transferFrom: transferFrom failed\"\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(\n            success,\n            \"TransferHelper::safeTransferETH: ETH transfer failed\"\n        );\n    }\n}\n"
    },
    "contracts/uniswap-solc-0.8/libraries/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.12;\n\n//solhint-disable reason-string\n\nimport \"../interfaces/IUniswapV2Pair.sol\";\n\nlibrary UniswapV2Library {\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(\n        address tokenA,\n        address tokenB\n    ) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            bytes1(0xff),\n                            factory,\n                            keccak256(abi.encodePacked(token0, token1)),\n                            hex\"443533a897cfad2762695078bf6ee9b78b4edcda64ec31e1c83066cee4c90a7e\" // init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(\n            pairFor(factory, tokenA, tokenB)\n        ).getReserves();\n        (reserveA, reserveB) = tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n        require(\n            reserveA > 0 && reserveB > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        amountB = (amountA * reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 numerator = reserveIn * amountOut * 1000;\n        uint256 denominator = (reserveOut - amountOut) * 997;\n        amountIn = numerator / denominator + 1;\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        uint256 amountIn,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                factory,\n                path[i],\n                path[i + 1]\n            );\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address factory,\n        uint256 amountOut,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                factory,\n                path[i - 1],\n                path[i]\n            );\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "contracts/uniswap-solc-0.8/libraries/UQ112x112.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.12;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    //solhint-disable-next-line state-visibility\n    uint224 constant Q112 = 2 ** 112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n"
    },
    "contracts/uniswap-solc-0.8/test/RouterEventEmitter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/IUniswapV2Router01.sol\";\n\ncontract RouterEventEmitter {\n    event Amounts(uint256[] amounts);\n\n    receive() external payable {}\n\n    function swapExactTokensForTokens(\n        address router,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(\n            abi.encodeWithSelector(\n                IUniswapV2Router01(router).swapExactTokensForTokens.selector,\n                amountIn,\n                amountOutMin,\n                path,\n                to,\n                deadline\n            )\n        );\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint256[])));\n    }\n\n    function swapTokensForExactTokens(\n        address router,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(\n            abi.encodeWithSelector(\n                IUniswapV2Router01(router).swapTokensForExactTokens.selector,\n                amountOut,\n                amountInMax,\n                path,\n                to,\n                deadline\n            )\n        );\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint256[])));\n    }\n\n    function swapExactETHForTokens(\n        address router,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable {\n        (bool success, bytes memory returnData) = router.delegatecall(\n            abi.encodeWithSelector(\n                IUniswapV2Router01(router).swapExactETHForTokens.selector,\n                amountOutMin,\n                path,\n                to,\n                deadline\n            )\n        );\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint256[])));\n    }\n\n    function swapTokensForExactETH(\n        address router,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(\n            abi.encodeWithSelector(\n                IUniswapV2Router01(router).swapTokensForExactETH.selector,\n                amountOut,\n                amountInMax,\n                path,\n                to,\n                deadline\n            )\n        );\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint256[])));\n    }\n\n    function swapExactTokensForETH(\n        address router,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(\n            abi.encodeWithSelector(\n                IUniswapV2Router01(router).swapExactTokensForETH.selector,\n                amountIn,\n                amountOutMin,\n                path,\n                to,\n                deadline\n            )\n        );\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint256[])));\n    }\n\n    function swapETHForExactTokens(\n        address router,\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable {\n        (bool success, bytes memory returnData) = router.delegatecall(\n            abi.encodeWithSelector(\n                IUniswapV2Router01(router).swapETHForExactTokens.selector,\n                amountOut,\n                path,\n                to,\n                deadline\n            )\n        );\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint256[])));\n    }\n}\n"
    },
    "contracts/uniswap-solc-0.8/test/WETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.12;\n\ncontract WETH9 {\n    string public name = \"Wrapped Ether\";\n    string public symbol = \"WETH\";\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    receive() external payable {\n        deposit();\n    }\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public {\n        require(balanceOf[msg.sender] >= wad, \"\");\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public returns (bool) {\n        require(balanceOf[src] >= wad, \"\");\n\n        if (\n            src != msg.sender && allowance[src][msg.sender] != type(uint256).max\n        ) {\n            require(allowance[src][msg.sender] >= wad, \"\");\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n"
    },
    "contracts/uniswap-solc-0.8/UniswapV2ERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.12;\n\nimport \"./interfaces/IUniswapV2ERC20.sol\";\n\n//solhint-disable var-name-mixedcase\n//solhint-disable reason-string\n//solhint-disable const-name-snakecase\n\ncontract UniswapV2ERC20 is IUniswapV2ERC20 {\n    string public constant override name = \"Uniswap V2\";\n    string public constant override symbol = \"UNI-V2\";\n    uint8 public constant override decimals = 18;\n    uint256 public override totalSupply;\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    bytes32 public override DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant override PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public override nonces;\n\n    constructor() {\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply += value;\n        balanceOf[to] += value;\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] -= value;\n        totalSupply -= value;\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint256 value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint256 value) private {\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    function approve(\n        address spender,\n        uint256 value\n    ) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(\n        address to,\n        uint256 value\n    ) external override returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external override returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] -= value;\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        //solhint-disable-next-line not-rely-on-time\n        require(deadline >= block.timestamp, \"UniswapV2: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"UniswapV2: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/uniswap-solc-0.8/UniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.12;\n\n//solhint-disable not-rely-on-time\n//solhint-disable var-name-mixedcase\n//solhint-disable reason-string\n\nimport \"./interfaces/IUniswapV2Factory.sol\";\nimport \"./libraries/TransferHelper.sol\";\n\nimport \"./interfaces/IUniswapV2Router.sol\";\nimport \"./libraries/UniswapV2Library.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IWETH.sol\";\n\ncontract UniswapV2Router is IUniswapV2Router {\n    address public immutable override factory;\n    address public immutable override WETH;\n\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"UniswapV2Router: EXPIRED\");\n        _;\n    }\n\n    constructor(address _factory, address _WETH) {\n        factory = _factory;\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) internal virtual returns (uint256 amountA, uint256 amountB) {\n        // create the pair if it doesn't exist yet\n        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n            IUniswapV2Factory(factory).createPair(tokenA, tokenB);\n        }\n        (uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(\n            factory,\n            tokenA,\n            tokenB\n        );\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint256 amountBOptimal = UniswapV2Library.quote(\n                amountADesired,\n                reserveA,\n                reserveB\n            );\n            if (amountBOptimal <= amountBDesired) {\n                require(\n                    amountBOptimal >= amountBMin,\n                    \"UniswapV2Router: INSUFFICIENT_B_AMOUNT\"\n                );\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal = UniswapV2Library.quote(\n                    amountBDesired,\n                    reserveB,\n                    reserveA\n                );\n                assert(amountAOptimal <= amountADesired);\n                require(\n                    amountAOptimal >= amountAMin,\n                    \"UniswapV2Router: INSUFFICIENT_A_AMOUNT\"\n                );\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint256 amountA, uint256 amountB, uint256 liquidity)\n    {\n        (amountA, amountB) = _addLiquidity(\n            tokenA,\n            tokenB,\n            amountADesired,\n            amountBDesired,\n            amountAMin,\n            amountBMin\n        );\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IUniswapV2Pair(pair).mint(to);\n    }\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        virtual\n        override\n        ensure(deadline)\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity)\n    {\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            WETH,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        IWETH(WETH).deposit{value: amountETH}();\n        assert(IWETH(WETH).transfer(pair, amountETH));\n        liquidity = IUniswapV2Pair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH)\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        public\n        virtual\n        override\n        ensure(deadline)\n        returns (uint256 amountA, uint256 amountB)\n    {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n        (uint256 amount0, uint256 amount1) = IUniswapV2Pair(pair).burn(to);\n        (address token0, ) = UniswapV2Library.sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0\n            ? (amount0, amount1)\n            : (amount1, amount0);\n        require(\n            amountA >= amountAMin,\n            \"UniswapV2Router: INSUFFICIENT_A_AMOUNT\"\n        );\n        require(\n            amountB >= amountBMin,\n            \"UniswapV2Router: INSUFFICIENT_B_AMOUNT\"\n        );\n    }\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        public\n        virtual\n        override\n        ensure(deadline)\n        returns (uint256 amountToken, uint256 amountETH)\n    {\n        (amountToken, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, amountToken);\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override returns (uint256 amountA, uint256 amountB) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        uint256 value = approveMax ? type(uint256).max : liquidity;\n        IUniswapV2Pair(pair).permit(\n            msg.sender,\n            address(this),\n            value,\n            deadline,\n            v,\n            r,\n            s\n        );\n        (amountA, amountB) = removeLiquidity(\n            tokenA,\n            tokenB,\n            liquidity,\n            amountAMin,\n            amountBMin,\n            to,\n            deadline\n        );\n    }\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n        virtual\n        override\n        returns (uint256 amountToken, uint256 amountETH)\n    {\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        uint256 value = approveMax ? type(uint256).max : liquidity;\n        IUniswapV2Pair(pair).permit(\n            msg.sender,\n            address(this),\n            value,\n            deadline,\n            v,\n            r,\n            s\n        );\n        (amountToken, amountETH) = removeLiquidityETH(\n            token,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            to,\n            deadline\n        );\n    }\n\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) public virtual override ensure(deadline) returns (uint256 amountETH) {\n        (, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(\n            token,\n            to,\n            IERC20(token).balanceOf(address(this))\n        );\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override returns (uint256 amountETH) {\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        uint256 value = approveMax ? type(uint256).max : liquidity;\n        IUniswapV2Pair(pair).permit(\n            msg.sender,\n            address(this),\n            value,\n            deadline,\n            v,\n            r,\n            s\n        );\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n            token,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            to,\n            deadline\n        );\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(\n        uint256[] memory amounts,\n        address[] memory path,\n        address _to\n    ) internal virtual {\n        for (uint256 i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0, ) = UniswapV2Library.sortTokens(input, output);\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\n                ? (uint256(0), amountOut)\n                : (amountOut, uint256(0));\n            address to = i < path.length - 2\n                ? UniswapV2Library.pairFor(factory, output, path[i + 2])\n                : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output))\n                .swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint256[] memory amounts)\n    {\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            UniswapV2Library.pairFor(factory, path[0], path[1]),\n            amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint256[] memory amounts)\n    {\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(\n            amounts[0] <= amountInMax,\n            \"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\"\n        );\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            UniswapV2Library.pairFor(factory, path[0], path[1]),\n            amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        virtual\n        override\n        ensure(deadline)\n        returns (uint256[] memory amounts)\n    {\n        require(path[0] == WETH, \"UniswapV2Router: INVALID_PATH\");\n        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(\n            IWETH(WETH).transfer(\n                UniswapV2Library.pairFor(factory, path[0], path[1]),\n                amounts[0]\n            )\n        );\n        _swap(amounts, path, to);\n    }\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint256[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, \"UniswapV2Router: INVALID_PATH\");\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(\n            amounts[0] <= amountInMax,\n            \"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\"\n        );\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            UniswapV2Library.pairFor(factory, path[0], path[1]),\n            amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint256[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, \"UniswapV2Router: INVALID_PATH\");\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            UniswapV2Library.pairFor(factory, path[0], path[1]),\n            amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        virtual\n        override\n        ensure(deadline)\n        returns (uint256[] memory amounts)\n    {\n        require(path[0] == WETH, \"UniswapV2Router: INVALID_PATH\");\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(\n            amounts[0] <= msg.value,\n            \"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\"\n        );\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(\n            IWETH(WETH).transfer(\n                UniswapV2Library.pairFor(factory, path[0], path[1]),\n                amounts[0]\n            )\n        );\n        _swap(amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0])\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(\n        address[] memory path,\n        address _to\n    ) internal virtual {\n        for (uint256 i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0, ) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(\n                UniswapV2Library.pairFor(factory, input, output)\n            );\n            uint256 amountInput;\n            uint256 amountOutput;\n            {\n                // scope to avoid stack too deep errors\n                (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n                (uint256 reserveInput, uint256 reserveOutput) = input == token0\n                    ? (reserve0, reserve1)\n                    : (reserve1, reserve0);\n                amountInput =\n                    IERC20(input).balanceOf(address(pair)) -\n                    reserveInput;\n                amountOutput = UniswapV2Library.getAmountOut(\n                    amountInput,\n                    reserveInput,\n                    reserveOutput\n                );\n            }\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\n                ? (uint256(0), amountOutput)\n                : (amountOutput, uint256(0));\n            address to = i < path.length - 2\n                ? UniswapV2Library.pairFor(factory, output, path[i + 2])\n                : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            UniswapV2Library.pairFor(factory, path[0], path[1]),\n            amountIn\n        );\n        uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to) - balanceBefore >=\n                amountOutMin,\n            \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n    }\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable virtual override ensure(deadline) {\n        require(path[0] == WETH, \"UniswapV2Router: INVALID_PATH\");\n        uint256 amountIn = msg.value;\n        IWETH(WETH).deposit{value: amountIn}();\n        assert(\n            IWETH(WETH).transfer(\n                UniswapV2Library.pairFor(factory, path[0], path[1]),\n                amountIn\n            )\n        );\n        uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to) - balanceBefore >=\n                amountOutMin,\n            \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n    }\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) {\n        require(path[path.length - 1] == WETH, \"UniswapV2Router: INVALID_PATH\");\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            UniswapV2Library.pairFor(factory, path[0], path[1]),\n            amountIn\n        );\n        _swapSupportingFeeOnTransferTokens(path, address(this));\n        uint256 amountOut = IERC20(WETH).balanceOf(address(this));\n        require(\n            amountOut >= amountOutMin,\n            \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        IWETH(WETH).withdraw(amountOut);\n        TransferHelper.safeTransferETH(to, amountOut);\n    }\n\n    // **** LIBRARY FUNCTIONS ****\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) public pure virtual override returns (uint256 amountB) {\n        return UniswapV2Library.quote(amountA, reserveA, reserveB);\n    }\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) public pure virtual override returns (uint256 amountOut) {\n        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n    }\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) public pure virtual override returns (uint256 amountIn) {\n        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n    }\n\n    function getAmountsOut(\n        uint256 amountIn,\n        address[] memory path\n    ) public view virtual override returns (uint256[] memory amounts) {\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\n    }\n\n    function getAmountsIn(\n        uint256 amountOut,\n        address[] memory path\n    ) public view virtual override returns (uint256[] memory amounts) {\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000,
      "details": {
        "yul": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}